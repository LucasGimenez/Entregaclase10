
out/programa.elf:     file format elf32-littlearm
out/programa.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x1a001b25

Program Header:
0x70000001 off    0x000129e4 vaddr 0x1a0029e4 paddr 0x1a0029e4 align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010048 vaddr 0x10000048 paddr 0x10000048 align 2**16
         filesz 0x00000000 memsz 0x00000128 flags rw-
    LOAD off    0x00010000 vaddr 0x1a000000 paddr 0x1a000000 align 2**16
         filesz 0x000029ec memsz 0x000029ec flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x1a0029ec align 2**16
         filesz 0x00000048 memsz 0x00000048 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000029e4  1a000000  1a000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  10000000  1a0029ec  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2    00000000  10080000  10080000  00020048  2**2
                  CONTENTS
  3 .data_RAM3    00000000  20000000  20000000  00020048  2**2
                  CONTENTS
  4 .data_RAM4    00000000  20008000  20008000  00020048  2**2
                  CONTENTS
  5 .data_RAM5    00000000  2000c000  2000c000  00020048  2**2
                  CONTENTS
  6 .bss          00000128  10000048  10000048  00010048  2**3
                  ALLOC
  7 .bss_RAM2     00000000  10080000  10080000  00020048  2**2
                  CONTENTS
  8 .bss_RAM3     00000000  20000000  20000000  00020048  2**2
                  CONTENTS
  9 .bss_RAM4     00000000  20008000  20008000  00020048  2**2
                  CONTENTS
 10 .bss_RAM5     00000000  2000c000  2000c000  00020048  2**2
                  CONTENTS
 11 .ARM.exidx    00000008  1a0029e4  1a0029e4  000129e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .uninit_RESERVED 00000000  10000000  10000000  00020048  2**2
                  CONTENTS
 13 .noinit_RAM2  00000000  10080000  10080000  00020048  2**2
                  CONTENTS
 14 .noinit_RAM3  00000000  20000000  20000000  00020048  2**2
                  CONTENTS
 15 .noinit_RAM4  00000000  20008000  20008000  00020048  2**2
                  CONTENTS
 16 .noinit_RAM5  00000000  2000c000  2000c000  00020048  2**2
                  CONTENTS
 17 .noinit       00000000  10000170  10000170  00020048  2**2
                  CONTENTS
 18 .debug_info   00016f4a  00000000  00000000  00020048  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 0000378f  00000000  00000000  00036f92  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_loc    000048ca  00000000  00000000  0003a721  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_aranges 00000728  00000000  00000000  0003efeb  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_ranges 00000670  00000000  00000000  0003f713  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_macro  0000aa28  00000000  00000000  0003fd83  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_line   0000b4d3  00000000  00000000  0004a7ab  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_str    0001c95c  00000000  00000000  00055c7e  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .comment      0000007f  00000000  00000000  000725da  2**0
                  CONTENTS, READONLY
 27 .ARM.attributes 00000039  00000000  00000000  00072659  2**0
                  CONTENTS, READONLY
 28 .debug_frame  00001068  00000000  00000000  00072694  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
1a000000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
10080000 l    d  .data_RAM2	00000000 .data_RAM2
20000000 l    d  .data_RAM3	00000000 .data_RAM3
20008000 l    d  .data_RAM4	00000000 .data_RAM4
2000c000 l    d  .data_RAM5	00000000 .data_RAM5
10000048 l    d  .bss	00000000 .bss
10080000 l    d  .bss_RAM2	00000000 .bss_RAM2
20000000 l    d  .bss_RAM3	00000000 .bss_RAM3
20008000 l    d  .bss_RAM4	00000000 .bss_RAM4
2000c000 l    d  .bss_RAM5	00000000 .bss_RAM5
1a0029e4 l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
10080000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
20000000 l    d  .noinit_RAM3	00000000 .noinit_RAM3
20008000 l    d  .noinit_RAM4	00000000 .noinit_RAM4
2000c000 l    d  .noinit_RAM5	00000000 .noinit_RAM5
10000170 l    d  .noinit	00000000 .noinit
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 cr_startup_lpc43xx.c
00000000 l    df *ABS*	00000000 sapi_uart.c
00000000 l    df *ABS*	00000000 crp.c
00000000 l    df *ABS*	00000000 Ascensor.c
00000000 l    df *ABS*	00000000 MEFAscensorPuertas.c
10000050 l     O .bss	00000018 timAbreCierraPuerta
10000068 l     O .bss	00000018 timAlarPuerta
10000080 l     O .bss	00000018 timPisoPiso
10000098 l     O .bss	00000018 timPuertaAbierta
100000b0 l     O .bss	00000018 timRetornoPB
00000000 l    df *ABS*	00000000 MEF_tecladoMatricial.c
100000c8 l     O .bss	00000002 confirmar
100000d0 l     O .bss	00000018 delayAntirebote
100000e8 l     O .bss	00000001 estadoMefScanTeclado
100000e9 l     O .bss	00000001 estadoMefTecladoMatricial
100000ea l     O .bss	00000001 flagEstadoApretandoTecla
100000eb l     O .bss	00000001 hayTeclaDisponible
100000f0 l     O .bss	00000004 indiceTeclaPresionada
100000f4 l     O .bss	00000002 key
100000f6 l     O .bss	00000002 primerDigito
100000f8 l     O .bss	00000002 segundoDigito
10000000 l     O .data	00000002 teclaPresionada
1a0024ec l     O .text	00000004 pinesColumna
1a0024f0 l     O .text	00000004 pinesFila
1a0024f4 l     O .text	00000020 pinesTeclado
00000000 l    df *ABS*	00000000 Test.c
00000000 l    df *ABS*	00000000 driverDisplay.c
100000fa l     O .bss	00000001 centenasB
100000fb l     O .bss	00000001 decenasB
100000fc l     O .bss	00000001 secuenciaB
100000fd l     O .bss	00000001 unidadesB
100000fe l     O .bss	00000001 unidadesmilB
1a002734 l     O .text	0000001b numeroadisplayB
1a002750 l     O .text	00000004 quedisplayB
1a002754 l     O .text	00000008 segmentosdisplayB
00000000 l    df *ABS*	00000000 chip_18xx_43xx.c
00000000 l    df *ABS*	00000000 clock_18xx_43xx.c
1a001104 l     F .text	000000a0 pll_calc_divs
1a0011a4 l     F .text	00000100 pll_get_frac
1a0012a4 l     F .text	0000004c Chip_Clock_FindBaseClock
1a001518 l     F .text	00000022 Chip_Clock_GetDivRate
10000100 l     O .bss	00000008 audio_usb_pll_freq
1a002768 l     O .text	0000006c periph_to_base
00000000 l    df *ABS*	00000000 fpu_init.c
00000000 l    df *ABS*	00000000 gpio_18xx_43xx.c
00000000 l    df *ABS*	00000000 sysinit_18xx_43xx.c
1a0027d4 l     O .text	00000048 InitClkStates
00000000 l    df *ABS*	00000000 uart_18xx_43xx.c
1a001824 l     F .text	0000002c Chip_UART_GetIndex
1a00281c l     O .text	00000008 UART_BClock
1a002824 l     O .text	00000008 UART_PClock
00000000 l    df *ABS*	00000000 board.c
1a0019cc l     F .text	00000044 Board_LED_Init
1a002834 l     O .text	0000000c gpioLEDBits
00000000 l    df *ABS*	00000000 board_sysinit.c
1a002840 l     O .text	0000000c InitClkStates
1a00284c l     O .text	00000060 pinmuxing
00000000 l    df *ABS*	00000000 sysinit.c
00000000 l    df *ABS*	00000000 sapi_board.c
00000000 l    df *ABS*	00000000 sapi_datatypes.c
00000000 l    df *ABS*	00000000 sapi_delay.c
00000000 l    df *ABS*	00000000 sapi_gpio.c
1a001d00 l     F .text	00000034 gpioObtainPinConfig
00000000 l    df *ABS*	00000000 sapi_tick.c
00000000 l    df *ABS*	00000000 sapi_timer.c
1a002010 l     F .text	00000002 errorOcurred
1a002012 l     F .text	00000002 doNothing
10000008 l     O .data	00000040 timer_dd
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 
1a000300 l       .text	00000000 __CRP_WORD_END__
1a0002fc l       .text	00000000 __CRP_WORD_START__
1a00133c g     F .text	0000001c Chip_Clock_GetDividerSource
1a000a44 g     F .text	00000084 ingresarDigito
1a002094 g     F .text	00000044 TIMER2_IRQHandler
1a000184  w    F .text	00000002 DebugMon_Handler
1a00018a  w    F .text	00000002 RIT_IRQHandler
1a080000 g       *ABS*	00000000 __top_MFlashA512
1a00018a  w    F .text	00000002 ADCHS_IRQHandler
1a000114 g       .text	00000000 __section_table_start
1a00018a  w    F .text	00000002 FLASH_EEPROM_IRQHandler
1a00018a  w    F .text	00000002 I2C0_IRQHandler
1a0016a6 g     F .text	00000024 Chip_GPIO_SetDir
1a000798 g     F .text	00000114 ActualizaMEFPuerta
1a001cc0 g     F .text	0000003e delayRead
1a00017a  w    F .text	00000002 HardFault_Handler
1a000000 g       *ABS*	00000000 __vectors_start__
1a001fec g     F .text	00000024 SysTick_Handler
1a0018a4 g     F .text	00000040 Chip_UART_SetBaud
1a00018a  w    F .text	00000002 SDIO_IRQHandler
1a00018a  w    F .text	00000002 ATIMER_IRQHandler
1000014c g     O .bss	0000000a numeroEnString
1a000186  w    F .text	00000002 PendSV_Handler
1a0008e4 g     F .text	0000001c InicializarMEF_tecladoMatrical
1a000178  w    F .text	00000002 NMI_Handler
1a0029ec g       .ARM.exidx	00000000 __exidx_end
1a000150 g       .text	00000000 __data_section_table_end
1a00018a  w    F .text	00000002 I2C1_IRQHandler
1a00018a  w    F .text	00000002 UART1_IRQHandler
1a00018a  w    F .text	00000002 GPIO5_IRQHandler
1a00018a  w    F .text	00000002 CAN1_IRQHandler
53ff5d6a g       *ABS*	00000000 __valid_user_code_checksum
1a0029ec g       .ARM.exidx	00000000 _etext
1a00018a  w    F .text	00000002 USB1_IRQHandler
1000004e g     O .bss	00000001 pisoDestino
1a00018a  w    F .text	00000002 I2S0_IRQHandler
10000048 g     O .bss	00000004 flag1DW
1a0020d8 g     F .text	00000044 TIMER3_IRQHandler
1a0015ba g     F .text	0000000c Chip_Clock_GetBaseClocktHz
1a0001bc g     F .text	00000002 UART0_IRQHandler
1a0001aa g     F .text	00000012 bss_init
1a00018a  w    F .text	00000002 SGPIO_IRQHandler
1000004c g     O .bss	00000001 flagConfiguracion
1a0021cc g     F .text	00000000 .hidden __aeabi_uldivmod
10000170 g       .noinit	00000000 _noinit
1a0021b0 g     F .text	00000018 uartWriteString
10000158 g     O .bss	00000004 SystemCoreClock
1a001850 g     F .text	00000054 Chip_UART_Init
1a00018a  w    F .text	00000002 ADC0_IRQHandler
1a001ca0 g     F .text	00000020 delayConfig
1a000180  w    F .text	00000002 UsageFault_Handler
100000ec g     O .bss	00000004 indice
1a001604 g     F .text	0000004c Chip_Clock_GetRate
1a00018a  w    F .text	00000002 GPIO6_IRQHandler
10000160 g     O .bss	00000008 tickCounter
1a001aac g     F .text	0000006c Board_SetupClocking
20008000 g       *ABS*	00000000 __top_RamAHB32
1a000c30 g     F .text	00000068 itoa
1a0021fc g     F .text	000002dc .hidden __udivmoddi4
1a00282c g     O .text	00000004 ExtRateIn
1a00018a  w    F .text	00000002 IntDefaultHandler
10000120 g     O .bss	00000001 estadoActualAsc
1a00018a  w    F .text	00000002 GPIO1_IRQHandler
1a001f68 g     F .text	00000078 tickConfig
1a00018a  w    F .text	00000002 SSP0_IRQHandler
1a001d34 g     F .text	00000174 gpioConfig
1a0029e4 g       .text	00000000 __exidx_start
1a0002fc g     O .text	00000004 CRP_WORD
1000004d g     O .bss	00000001 pisoActual
1a00018a  w    F .text	00000002 ADC1_IRQHandler
1a001a4c g     F .text	00000028 Board_Init
1a000114 g       .text	00000000 __data_section_table
1a00018a  w    F .text	00000002 RTC_IRQHandler
10000170 g       .bss	00000000 _ebss
1a002014 g     F .text	00000040 TIMER0_IRQHandler
20010000 g       *ABS*	00000000 __top_RamAHB_ETB16
1a00018a  w    F .text	00000002 SPI_IRQHandler
1a000ac8 g     F .text	00000044 guardarPisoSimple
1a00018a  w    F .text	00000002 LCD_IRQHandler
1a0012f0 g     F .text	0000004c Chip_Clock_EnableCrystal
1a001bac g     F .text	000000ee boardConfig
1a000b0c g     F .text	00000068 guardarPisoDoble
10008000 g       *ABS*	00000000 __top_RamLoc32
1a000eec g     F .text	0000005c SacaDigito
1a00018c g     F .text	0000001e data_init
10000121 g     O .bss	00000001 estadoActualPuerta
1a002054 g     F .text	00000040 TIMER1_IRQHandler
1a0021c8 g     F .text	00000002 UART2_IRQHandler
1a0014ac g     F .text	0000006c Chip_Clock_GetMainPLLHz
1a001c9a g     F .text	00000004 sAPI_NullFuncPtr
1a002180 g     F .text	00000030 uartWriteByte
1a001f52 g     F .text	00000016 gpioToggle
1a00018a  w    F .text	00000002 GPIO2_IRQHandler
1a001594 g     F .text	00000026 Chip_Clock_GetBaseClock
1a0003a8 g     F .text	00000034 InicializarMEFAsc
1a000f88 g     F .text	00000168 ActualizarDisplay
10000048 g       .bss	00000000 _bss
1a00018a  w    F .text	00000002 I2S1_IRQHandler
1a000300 g     F .text	0000000a IntTimer
1a0016a4 g     F .text	00000002 Chip_GPIO_Init
1a002830 g     O .text	00000004 OscRateIn
10000170 g       .noinit	00000000 _end_noinit
10008000 g       *ABS*	00000000 _vStackTop
1a000ccc g     F .text	000001d4 EnviaEstadoInterno
1a00018a  w    F .text	00000002 SSP1_IRQHandler
1a000178 g       .text	00000000 __bss_section_table_end
1a000994 g     F .text	000000b0 ActualizaMEFScanTecla
1a0024d8  w    F .text	00000002 .hidden __aeabi_ldiv0
1a00018a  w    F .text	00000002 USB0_IRQHandler
1a00018a  w    F .text	00000002 GPIO3_IRQHandler
1a00018a  w    F .text	00000002 SCT_IRQHandler
1a001358 g     F .text	0000001c Chip_Clock_GetDividerDivisor
1a0024dc g     F .text	00000010 memset
1a00017c  w    F .text	00000002 MemManage_Handler
1a00030c g     F .text	0000009c main
1a00018a  w    F .text	00000002 WDT_IRQHandler
2000c000 g       *ABS*	00000000 __top_RamAHB16
1008a000 g       *ABS*	00000000 __top_RamLoc40
1a000182  w    F .text	00000002 SVC_Handler
1a00042c g     F .text	00000064 CargaNuevoPiso
1a0008ac g     F .text	00000038 configurarTecladoMatricial
1a00018a  w    F .text	00000002 GPIO7_IRQHandler
1a0015c8 g     F .text	0000003c Chip_Clock_EnableOpts
1a0028ac g     O .text	00000136 gpioPinsConfig
1a000490 g     F .text	00000308 ActualizarMEFAsc
1a0003dc g     F .text	00000050 InicializarMEFPuerta
1a001374 g     F .text	000000b8 Chip_Clock_GetClockInputHz
1a001650 g     F .text	00000054 fpuInit
1a00142c g     F .text	00000080 Chip_Clock_CalcMainPLLValue
1a001ba0 g     F .text	0000000c SystemInit
1a00018a  w    F .text	00000002 SPIFI_IRQHandler
1a00018a  w    F .text	00000002 QEI_IRQHandler
10000124 g     O .bss	00000028 almacenarPisos
1a000150 g       .text	00000000 __bss_section_table
1a000b74 g     F .text	000000bc ActualizarMEF_tecladoMatricial
1a001ea8 g     F .text	00000056 gpioWrite
1a001a74 g     F .text	00000038 Board_SetupMuxing
1a0018e4 g     F .text	000000e8 Chip_UART_SetBaudFDR
1a001fe0 g     F .text	0000000c tickRead
10000168 g     O .bss	00000008 tickRateMS
1a00018a  w    F .text	00000002 ETH_IRQHandler
10000004 g     O .data	00000004 tickHookFunction
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
1a00018a  w    F .text	00000002 CAN0_IRQHandler
1a000900 g     F .text	00000094 ScanTeclas
10000000 g       .data	00000000 _data
1a000c98 g     F .text	00000034 uartWriteMiDato
10000170 g       .bss	00000000 _pvHeapStart
1a000178 g       .text	00000000 __section_table_end
1a00211c g     F .text	00000064 uartConfig
1a00018a  w    F .text	00000002 GINT0_IRQHandler
1a00018a  w    F .text	00000002 DAC_IRQHandler
1a001a24 g     F .text	00000028 Board_Debug_Init
10000048 g       .data	00000000 _edata
1a00018a  w    F .text	00000002 M0SUB_IRQHandler
1a0016cc g     F .text	00000158 Chip_SetupCoreClock
1a00018a  w    F .text	00000002 GPIO0_IRQHandler
1a000000 g     O .text	00000114 g_pfnVectors
1a001b24 g     F .text	0000007c ResetISR
1a0010f0 g     F .text	00000014 SystemCoreClockUpdate
1a00018a  w    F .text	00000002 DMA_IRQHandler
1a00018a  w    F .text	00000002 EVRT_IRQHandler
1b080000 g       *ABS*	00000000 __top_MFlashB512
1a0024d8  w    F .text	00000002 .hidden __aeabi_idiv0
1a00017e  w    F .text	00000002 BusFault_Handler
1a0021ca g     F .text	00000002 UART3_IRQHandler
1a00018a  w    F .text	00000002 MCPWM_IRQHandler
1a00018a  w    F .text	00000002 M0APP_IRQHandler
1a001efe g     F .text	00000054 gpioRead
10000108 g     O .bss	00000018 timSerial
1a000f48 g     F .text	00000040 ConvierteByte
1a00018a  w    F .text	00000002 GINT1_IRQHandler
1a001a10 g     F .text	00000014 Board_UART_Init
1a000ea0 g     F .text	0000004c ConfigDisplay
1a00153c g     F .text	00000058 Chip_Clock_SetBaseClock
1a00018a  w    F .text	00000002 GPIO4_IRQHandler
1a001b18 g     F .text	0000000c Board_SystemInit



Disassembly of section .text:

1a000000 <g_pfnVectors>:
1a000000:	00 80 00 10 25 1b 00 1a 79 01 00 1a 7b 01 00 1a     ....%...y...{...
1a000010:	7d 01 00 1a 7f 01 00 1a 81 01 00 1a 6a 5d ff 53     }...........j].S
	...
1a00002c:	83 01 00 1a 85 01 00 1a 00 00 00 00 87 01 00 1a     ................
1a00003c:	ed 1f 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00004c:	00 00 00 00 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00005c:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00006c:	8b 01 00 1a 15 20 00 1a 55 20 00 1a 95 20 00 1a     ..... ..U ... ..
1a00007c:	d9 20 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     . ..............
1a00008c:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00009c:	8b 01 00 1a bd 01 00 1a 8b 01 00 1a c9 21 00 1a     .............!..
1a0000ac:	cb 21 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     .!..............
1a0000bc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000cc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000dc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000ec:	8b 01 00 1a 00 00 00 00 8b 01 00 1a 8b 01 00 1a     ................
1a0000fc:	8b 01 00 1a 00 00 00 00 8b 01 00 1a 8b 01 00 1a     ................
1a00010c:	8b 01 00 1a 8b 01 00 1a                             ........

1a000114 <__data_section_table>:
1a000114:	1a0029ec 	.word	0x1a0029ec
1a000118:	10000000 	.word	0x10000000
1a00011c:	00000048 	.word	0x00000048
1a000120:	1a0029ec 	.word	0x1a0029ec
1a000124:	10080000 	.word	0x10080000
1a000128:	00000000 	.word	0x00000000
1a00012c:	1a0029ec 	.word	0x1a0029ec
1a000130:	20000000 	.word	0x20000000
1a000134:	00000000 	.word	0x00000000
1a000138:	1a0029ec 	.word	0x1a0029ec
1a00013c:	20008000 	.word	0x20008000
1a000140:	00000000 	.word	0x00000000
1a000144:	1a0029ec 	.word	0x1a0029ec
1a000148:	2000c000 	.word	0x2000c000
1a00014c:	00000000 	.word	0x00000000

1a000150 <__bss_section_table>:
1a000150:	10000048 	.word	0x10000048
1a000154:	00000128 	.word	0x00000128
1a000158:	10080000 	.word	0x10080000
1a00015c:	00000000 	.word	0x00000000
1a000160:	20000000 	.word	0x20000000
1a000164:	00000000 	.word	0x00000000
1a000168:	20008000 	.word	0x20008000
1a00016c:	00000000 	.word	0x00000000
1a000170:	2000c000 	.word	0x2000c000
1a000174:	00000000 	.word	0x00000000

1a000178 <NMI_Handler>:
//*****************************************************************************
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void) {
1a000178:	e7fe      	b.n	1a000178 <NMI_Handler>

1a00017a <HardFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void) {
1a00017a:	e7fe      	b.n	1a00017a <HardFault_Handler>

1a00017c <MemManage_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void MemManage_Handler(void) {
1a00017c:	e7fe      	b.n	1a00017c <MemManage_Handler>

1a00017e <BusFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void BusFault_Handler(void) {
1a00017e:	e7fe      	b.n	1a00017e <BusFault_Handler>

1a000180 <UsageFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void UsageFault_Handler(void) {
1a000180:	e7fe      	b.n	1a000180 <UsageFault_Handler>

1a000182 <SVC_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void) {
1a000182:	e7fe      	b.n	1a000182 <SVC_Handler>

1a000184 <DebugMon_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void DebugMon_Handler(void) {
1a000184:	e7fe      	b.n	1a000184 <DebugMon_Handler>

1a000186 <PendSV_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void) {
1a000186:	e7fe      	b.n	1a000186 <PendSV_Handler>
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void) {
1a000188:	e7fe      	b.n	1a000188 <PendSV_Handler+0x2>

1a00018a <ADC0_IRQHandler>:
// Processor ends up here if an unexpected interrupt occurs or a specific
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void) {
1a00018a:	e7fe      	b.n	1a00018a <ADC0_IRQHandler>

1a00018c <data_init>:
    for (loop = 0; loop < len; loop = loop + 4)
1a00018c:	2300      	movs	r3, #0
1a00018e:	4293      	cmp	r3, r2
1a000190:	d20a      	bcs.n	1a0001a8 <data_init+0x1c>
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
1a000192:	b410      	push	{r4}
        *pulDest++ = *pulSrc++;
1a000194:	6804      	ldr	r4, [r0, #0]
1a000196:	600c      	str	r4, [r1, #0]
    for (loop = 0; loop < len; loop = loop + 4)
1a000198:	3304      	adds	r3, #4
        *pulDest++ = *pulSrc++;
1a00019a:	3004      	adds	r0, #4
1a00019c:	3104      	adds	r1, #4
    for (loop = 0; loop < len; loop = loop + 4)
1a00019e:	4293      	cmp	r3, r2
1a0001a0:	d3f8      	bcc.n	1a000194 <data_init+0x8>
}
1a0001a2:	f85d 4b04 	ldr.w	r4, [sp], #4
1a0001a6:	4770      	bx	lr
1a0001a8:	4770      	bx	lr

1a0001aa <bss_init>:
    for (loop = 0; loop < len; loop = loop + 4)
1a0001aa:	2300      	movs	r3, #0
1a0001ac:	e003      	b.n	1a0001b6 <bss_init+0xc>
        *pulDest++ = 0;
1a0001ae:	2200      	movs	r2, #0
1a0001b0:	6002      	str	r2, [r0, #0]
    for (loop = 0; loop < len; loop = loop + 4)
1a0001b2:	3304      	adds	r3, #4
        *pulDest++ = 0;
1a0001b4:	3004      	adds	r0, #4
    for (loop = 0; loop < len; loop = loop + 4)
1a0001b6:	428b      	cmp	r3, r1
1a0001b8:	d3f9      	bcc.n	1a0001ae <bss_init+0x4>
}
1a0001ba:	4770      	bx	lr

1a0001bc <UART0_IRQHandler>:
/*==================[ISR external functions definition]======================*/

__attribute__ ((section(".after_vectors")))

/* 0x28 0x000000A0 - Handler for ISR UART0 (IRQ 24) */
void UART0_IRQHandler(void){
1a0001bc:	4770      	bx	lr
1a0001be:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001c2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001c6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ce:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001d2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001d6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001da:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001de:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ea:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ee:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001fa:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001fe:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000202:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000206:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00020a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00020e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000212:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000216:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00021a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00021e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000222:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000226:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00022a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00022e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000232:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000236:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00023a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00023e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000242:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000246:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00024a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00024e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000252:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000256:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00025a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00025e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000262:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000266:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00026a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00026e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000272:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000276:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00027a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00027e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000282:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000286:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00028a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00028e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000292:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000296:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00029a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00029e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002aa:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ae:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ba:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002be:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ce:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002da:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002de:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ea:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ee:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002fa:	Address 0x1a0002fa is out of bounds.


1a0002fc <CRP_WORD>:
1a0002fc:	ffff ffff                                   ....

1a000300 <IntTimer>:

//*************************************************************************************************
//			Interrupci贸n cada 5ms
//*************************************************************************************************
bool_t IntTimer (void *ptr)
{
1a000300:	b508      	push	{r3, lr}


// Llama a la rutina que actualiza el display de 4 digitos de 7 segmentos.
ActualizarDisplay();
1a000302:	f000 fe41 	bl	1a000f88 <ActualizarDisplay>
	

return 1;
}
1a000306:	2001      	movs	r0, #1
1a000308:	bd08      	pop	{r3, pc}
1a00030a:	Address 0x1a00030a is out of bounds.


1a00030c <main>:


/*==================[funcion principal]======================================*/

// FUNCION PRINCIPAL, PUNTO DE ENTRADA AL PROGRAMA LUEGO DE ENCENDIDO O RESET.
int main( void ){
1a00030c:	b508      	push	{r3, lr}

// ---------- CONFIGURACIONES ------------------------------
// Inicializar y configurar la plataforma
boardConfig();   
1a00030e:	f001 fc4d 	bl	1a001bac <boardConfig>

// Interupcion cada 5ms.
tickConfig (5, IntTimer);
1a000312:	4a21      	ldr	r2, [pc, #132]	; (1a000398 <main+0x8c>)
1a000314:	2005      	movs	r0, #5
1a000316:	2100      	movs	r1, #0
1a000318:	f001 fe26 	bl	1a001f68 <tickConfig>

// Configuraci贸n de pines para el display 7 segmentos
ConfigDisplay();
1a00031c:	f000 fdc0 	bl	1a000ea0 <ConfigDisplay>

// Se inicializa la MEF que maneja el teclado matricial
InicializarMEF_tecladoMatrical();
1a000320:	f000 fae0 	bl	1a0008e4 <InicializarMEF_tecladoMatrical>


// Se inicializa la MEF que maneja el ascensor.
InicializarMEFAsc();
1a000324:	f000 f840 	bl	1a0003a8 <InicializarMEFAsc>

// Se inicializa la MEF que maneja la puerta del ascensor.
InicializarMEFPuerta();
1a000328:	f000 f858 	bl	1a0003dc <InicializarMEFPuerta>



// UART_USB a 115200 baudios.
uartConfig( UART_USB, 115200 );
1a00032c:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
1a000330:	2000      	movs	r0, #0
1a000332:	f001 fef3 	bl	1a00211c <uartConfig>
delayConfig(&timSerial, 200);   
1a000336:	22c8      	movs	r2, #200	; 0xc8
1a000338:	2300      	movs	r3, #0
1a00033a:	4818      	ldr	r0, [pc, #96]	; (1a00039c <main+0x90>)
1a00033c:	f001 fcb0 	bl	1a001ca0 <delayConfig>
// ---------- REPETIR POR SIEMPRE --------------------------
while(TRUE)
{      

// Funci贸n Actualizar MEF del Teclado.
ActualizarMEF_tecladoMatricial();
1a000340:	f000 fc18 	bl	1a000b74 <ActualizarMEF_tecladoMatricial>


// Funci贸n Actualizar MEF del Ascensor.
ActualizarMEFAsc();
1a000344:	f000 f8a4 	bl	1a000490 <ActualizarMEFAsc>


// Funci贸n Actualizar MEF de las Puertas.
ActualizaMEFPuerta();
1a000348:	f000 fa26 	bl	1a000798 <ActualizaMEFPuerta>



// Codigo de prueba, presionando la tecla 4 se cargan valores en las 10 posiciones del buffer de pisos
// y de fija indice a 10.
if (delayRead(&timSerial))
1a00034c:	4813      	ldr	r0, [pc, #76]	; (1a00039c <main+0x90>)
1a00034e:	f001 fcb7 	bl	1a001cc0 <delayRead>
1a000352:	2800      	cmp	r0, #0
1a000354:	d0f4      	beq.n	1a000340 <main+0x34>
	{
	EnviaEstadoInterno();
1a000356:	f000 fcb9 	bl	1a000ccc <EnviaEstadoInterno>
	
	if (!gpioRead(TEC4))
1a00035a:	2027      	movs	r0, #39	; 0x27
1a00035c:	f001 fdcf 	bl	1a001efe <gpioRead>
1a000360:	2800      	cmp	r0, #0
1a000362:	d1ed      	bne.n	1a000340 <main+0x34>
		{
		almacenarPisos[0] = 6;
1a000364:	4b0e      	ldr	r3, [pc, #56]	; (1a0003a0 <main+0x94>)
1a000366:	2206      	movs	r2, #6
1a000368:	601a      	str	r2, [r3, #0]
		almacenarPisos[1] = 9;
1a00036a:	2209      	movs	r2, #9
1a00036c:	605a      	str	r2, [r3, #4]
		almacenarPisos[2] = 12;
1a00036e:	220c      	movs	r2, #12
1a000370:	609a      	str	r2, [r3, #8]
		almacenarPisos[3] = 17;
1a000372:	2211      	movs	r2, #17
1a000374:	60da      	str	r2, [r3, #12]
		almacenarPisos[4] = 20;
1a000376:	2214      	movs	r2, #20
1a000378:	611a      	str	r2, [r3, #16]
		almacenarPisos[5] = 10;
1a00037a:	220a      	movs	r2, #10
1a00037c:	615a      	str	r2, [r3, #20]
		almacenarPisos[6] = -5;
1a00037e:	f06f 0104 	mvn.w	r1, #4
1a000382:	6199      	str	r1, [r3, #24]
		almacenarPisos[7] = 5;
1a000384:	2105      	movs	r1, #5
1a000386:	61d9      	str	r1, [r3, #28]
		almacenarPisos[8] = -3;
1a000388:	f06f 0102 	mvn.w	r1, #2
1a00038c:	6219      	str	r1, [r3, #32]
		almacenarPisos[9] = 8;
1a00038e:	2108      	movs	r1, #8
1a000390:	6259      	str	r1, [r3, #36]	; 0x24
		indice = 10;
1a000392:	4b04      	ldr	r3, [pc, #16]	; (1a0003a4 <main+0x98>)
1a000394:	601a      	str	r2, [r3, #0]
1a000396:	e7d3      	b.n	1a000340 <main+0x34>
1a000398:	1a000301 	.word	0x1a000301
1a00039c:	10000108 	.word	0x10000108
1a0003a0:	10000124 	.word	0x10000124
1a0003a4:	100000ec 	.word	0x100000ec

1a0003a8 <InicializarMEFAsc>:

//*********************************************************************************************************************
//		Funcin inicializar MEF del ascensor
//*********************************************************************************************************************
void InicializarMEFAsc(void)
{
1a0003a8:	b508      	push	{r3, lr}
// Estado inicial.
estadoActualAsc = EN_PLANTA_BAJA;
1a0003aa:	2200      	movs	r2, #0
1a0003ac:	4b08      	ldr	r3, [pc, #32]	; (1a0003d0 <InicializarMEFAsc+0x28>)
1a0003ae:	701a      	strb	r2, [r3, #0]
gpioWrite (LED_PBDETENIDO, 1);
1a0003b0:	2101      	movs	r1, #1
1a0003b2:	202d      	movs	r0, #45	; 0x2d
1a0003b4:	f001 fd78 	bl	1a001ea8 <gpioWrite>


// Se Configura el tiempo de desplazamiento del ascensor.
delayConfig(&timPisoPiso, velPisoPiso);   
1a0003b8:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
1a0003bc:	2300      	movs	r3, #0
1a0003be:	4805      	ldr	r0, [pc, #20]	; (1a0003d4 <InicializarMEFAsc+0x2c>)
1a0003c0:	f001 fc6e 	bl	1a001ca0 <delayConfig>

// Se Configura el tiempo de espera para retornar a la PB.
//delayConfig(&timRetornoPB, TRETORNOPB);   

// Resetea flag que indica ejecucion unica de bloque dentro de estado PARADO.
Clr_AscParadoFlag;
1a0003c4:	4a04      	ldr	r2, [pc, #16]	; (1a0003d8 <InicializarMEFAsc+0x30>)
1a0003c6:	6813      	ldr	r3, [r2, #0]
1a0003c8:	f023 0301 	bic.w	r3, r3, #1
1a0003cc:	6013      	str	r3, [r2, #0]
1a0003ce:	bd08      	pop	{r3, pc}
1a0003d0:	10000120 	.word	0x10000120
1a0003d4:	10000080 	.word	0x10000080
1a0003d8:	10000048 	.word	0x10000048

1a0003dc <InicializarMEFPuerta>:

//*********************************************************************************************************************
//		Funcin inicializar MEF de la puerta del ascensor
//*********************************************************************************************************************
void InicializarMEFPuerta(void)
{
1a0003dc:	b508      	push	{r3, lr}
// Estado inicial.
estadoActualPuerta = PUERTA_CERRADA;
1a0003de:	2200      	movs	r2, #0
1a0003e0:	4b0d      	ldr	r3, [pc, #52]	; (1a000418 <InicializarMEFPuerta+0x3c>)
1a0003e2:	701a      	strb	r2, [r3, #0]

// Se Configura el tiempo para el parpadeo del led de alarma indicador de puerta abierta, 0,5seg.
delayConfig(&timAlarPuerta, TALARMAPUERTA);   
1a0003e4:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
1a0003e8:	2300      	movs	r3, #0
1a0003ea:	480c      	ldr	r0, [pc, #48]	; (1a00041c <InicializarMEFPuerta+0x40>)
1a0003ec:	f001 fc58 	bl	1a001ca0 <delayConfig>

// Se configura tiempo de apertura de la puerta.
delayConfig(&timAbreCierraPuerta, velAbreCierraPuerta);   
1a0003f0:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
1a0003f4:	2300      	movs	r3, #0
1a0003f6:	480a      	ldr	r0, [pc, #40]	; (1a000420 <InicializarMEFPuerta+0x44>)
1a0003f8:	f001 fc52 	bl	1a001ca0 <delayConfig>

// Se configura tiempo que queda la puerta abierta.
delayConfig(&timPuertaAbierta, TPUETAABIERTA);   
1a0003fc:	f241 3288 	movw	r2, #5000	; 0x1388
1a000400:	2300      	movs	r3, #0
1a000402:	4808      	ldr	r0, [pc, #32]	; (1a000424 <InicializarMEFPuerta+0x48>)
1a000404:	f001 fc4c 	bl	1a001ca0 <delayConfig>

// Se configura tiempo que espera antes de retornar a Planta Baja.
delayConfig(&timRetornoPB, TRETORNOPB);
1a000408:	f242 7210 	movw	r2, #10000	; 0x2710
1a00040c:	2300      	movs	r3, #0
1a00040e:	4806      	ldr	r0, [pc, #24]	; (1a000428 <InicializarMEFPuerta+0x4c>)
1a000410:	f001 fc46 	bl	1a001ca0 <delayConfig>
1a000414:	bd08      	pop	{r3, pc}
1a000416:	bf00      	nop
1a000418:	10000121 	.word	0x10000121
1a00041c:	10000068 	.word	0x10000068
1a000420:	10000050 	.word	0x10000050
1a000424:	10000098 	.word	0x10000098
1a000428:	100000b0 	.word	0x100000b0

1a00042c <CargaNuevoPiso>:
void CargaNuevoPiso(void)
{
uint8_t i ;

// Si indice es distinto de cero significa que hay algun piso cargado en el buffer.
if (indice && !Ask_PideNuevoPisoFlag)
1a00042c:	4b13      	ldr	r3, [pc, #76]	; (1a00047c <CargaNuevoPiso+0x50>)
1a00042e:	681b      	ldr	r3, [r3, #0]
1a000430:	b31b      	cbz	r3, 1a00047a <CargaNuevoPiso+0x4e>
1a000432:	4a13      	ldr	r2, [pc, #76]	; (1a000480 <CargaNuevoPiso+0x54>)
1a000434:	6812      	ldr	r2, [r2, #0]
1a000436:	f012 0f10 	tst.w	r2, #16
1a00043a:	d11e      	bne.n	1a00047a <CargaNuevoPiso+0x4e>
	{
	// Si el piso actual es distinto del piso destino, se lo fija como nuevo, si no solo se desplaza el buffer.
	if (pisoActual != almacenarPisos[0])
1a00043c:	4a11      	ldr	r2, [pc, #68]	; (1a000484 <CargaNuevoPiso+0x58>)
1a00043e:	f992 1000 	ldrsb.w	r1, [r2]
1a000442:	4a11      	ldr	r2, [pc, #68]	; (1a000488 <CargaNuevoPiso+0x5c>)
1a000444:	6812      	ldr	r2, [r2, #0]
1a000446:	4291      	cmp	r1, r2
1a000448:	d006      	beq.n	1a000458 <CargaNuevoPiso+0x2c>
		{
		pisoDestino = almacenarPisos[0];
1a00044a:	4910      	ldr	r1, [pc, #64]	; (1a00048c <CargaNuevoPiso+0x60>)
1a00044c:	700a      	strb	r2, [r1, #0]
		Set_PideNuevoPisoFlag;
1a00044e:	490c      	ldr	r1, [pc, #48]	; (1a000480 <CargaNuevoPiso+0x54>)
1a000450:	680a      	ldr	r2, [r1, #0]
1a000452:	f042 0210 	orr.w	r2, r2, #16
1a000456:	600a      	str	r2, [r1, #0]
		}
	indice--;
1a000458:	3b01      	subs	r3, #1
1a00045a:	4a08      	ldr	r2, [pc, #32]	; (1a00047c <CargaNuevoPiso+0x50>)
1a00045c:	6013      	str	r3, [r2, #0]
	for (i=0; i<9; i++)
1a00045e:	2300      	movs	r3, #0
1a000460:	e006      	b.n	1a000470 <CargaNuevoPiso+0x44>
		almacenarPisos[i] = almacenarPisos[i+1];
1a000462:	1c5a      	adds	r2, r3, #1
1a000464:	4908      	ldr	r1, [pc, #32]	; (1a000488 <CargaNuevoPiso+0x5c>)
1a000466:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
1a00046a:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
	for (i=0; i<9; i++)
1a00046e:	b2d3      	uxtb	r3, r2
1a000470:	2b08      	cmp	r3, #8
1a000472:	d9f6      	bls.n	1a000462 <CargaNuevoPiso+0x36>
	almacenarPisos[9] = 0;
1a000474:	2200      	movs	r2, #0
1a000476:	4b04      	ldr	r3, [pc, #16]	; (1a000488 <CargaNuevoPiso+0x5c>)
1a000478:	625a      	str	r2, [r3, #36]	; 0x24
1a00047a:	4770      	bx	lr
1a00047c:	100000ec 	.word	0x100000ec
1a000480:	10000048 	.word	0x10000048
1a000484:	1000004d 	.word	0x1000004d
1a000488:	10000124 	.word	0x10000124
1a00048c:	1000004e 	.word	0x1000004e

1a000490 <ActualizarMEFAsc>:

//*********************************************************************************************************************
//		Funcin Actualizar MEF del Ascensor
//*********************************************************************************************************************
void ActualizarMEFAsc(void)
{
1a000490:	b510      	push	{r4, lr}


	

switch(estadoActualAsc)
1a000492:	4bae      	ldr	r3, [pc, #696]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a000494:	781b      	ldrb	r3, [r3, #0]
1a000496:	2b05      	cmp	r3, #5
1a000498:	f200 8174 	bhi.w	1a000784 <ActualizarMEFAsc+0x2f4>
1a00049c:	e8df f013 	tbh	[pc, r3, lsl #1]
1a0004a0:	00470006 	.word	0x00470006
1a0004a4:	00a50076 	.word	0x00a50076
1a0004a8:	016e010d 	.word	0x016e010d
	{
	case EN_PLANTA_BAJA:
		// Se solicita la apertura de puertas, una sola vez.
		if (!Ask_PidioAperturaFlag)
1a0004ac:	4ba8      	ldr	r3, [pc, #672]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a0004ae:	681b      	ldr	r3, [r3, #0]
1a0004b0:	f013 0f08 	tst.w	r3, #8
1a0004b4:	d108      	bne.n	1a0004c8 <ActualizarMEFAsc+0x38>
			{
			Set_PidioAperturaFlag;
1a0004b6:	4ba6      	ldr	r3, [pc, #664]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a0004b8:	681a      	ldr	r2, [r3, #0]
1a0004ba:	f042 0208 	orr.w	r2, r2, #8
1a0004be:	601a      	str	r2, [r3, #0]
			Set_AbrePuertasFlag;
1a0004c0:	681a      	ldr	r2, [r3, #0]
1a0004c2:	f042 0202 	orr.w	r2, r2, #2
1a0004c6:	601a      	str	r2, [r3, #0]
			}
		// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
		CargaNuevoPiso();
1a0004c8:	f7ff ffb0 	bl	1a00042c <CargaNuevoPiso>
		
		if (Ask_PideNuevoPisoFlag)
1a0004cc:	4ba0      	ldr	r3, [pc, #640]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a0004ce:	681b      	ldr	r3, [r3, #0]
1a0004d0:	f013 0f10 	tst.w	r3, #16
1a0004d4:	f000 8158 	beq.w	1a000788 <ActualizarMEFAsc+0x2f8>
			{
			if (estadoActualPuerta == PUERTA_ABIERTA)
1a0004d8:	4b9e      	ldr	r3, [pc, #632]	; (1a000754 <ActualizarMEFAsc+0x2c4>)
1a0004da:	781b      	ldrb	r3, [r3, #0]
1a0004dc:	2b02      	cmp	r3, #2
1a0004de:	d013      	beq.n	1a000508 <ActualizarMEFAsc+0x78>
				Set_CierraPuertasFlag;			// Pide cerrar puertas.
			
			
			if (estadoActualPuerta == PUERTA_CERRADA)
1a0004e0:	2b00      	cmp	r3, #0
1a0004e2:	f040 8151 	bne.w	1a000788 <ActualizarMEFAsc+0x2f8>
				{
				if (pisoActual < pisoDestino)
1a0004e6:	4b9c      	ldr	r3, [pc, #624]	; (1a000758 <ActualizarMEFAsc+0x2c8>)
1a0004e8:	f993 2000 	ldrsb.w	r2, [r3]
1a0004ec:	4b9b      	ldr	r3, [pc, #620]	; (1a00075c <ActualizarMEFAsc+0x2cc>)
1a0004ee:	f993 3000 	ldrsb.w	r3, [r3]
1a0004f2:	429a      	cmp	r2, r3
1a0004f4:	da0e      	bge.n	1a000514 <ActualizarMEFAsc+0x84>
					{
					
					// El piso destino se encuentra arriba.
					estadoActualAsc = SUBIENDO;
1a0004f6:	2201      	movs	r2, #1
1a0004f8:	4b94      	ldr	r3, [pc, #592]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a0004fa:	701a      	strb	r2, [r3, #0]
					Clr_PidioAperturaFlag;
1a0004fc:	4a94      	ldr	r2, [pc, #592]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a0004fe:	6813      	ldr	r3, [r2, #0]
1a000500:	f023 0308 	bic.w	r3, r3, #8
1a000504:	6013      	str	r3, [r2, #0]
1a000506:	bd10      	pop	{r4, pc}
				Set_CierraPuertasFlag;			// Pide cerrar puertas.
1a000508:	4991      	ldr	r1, [pc, #580]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a00050a:	680a      	ldr	r2, [r1, #0]
1a00050c:	f042 0204 	orr.w	r2, r2, #4
1a000510:	600a      	str	r2, [r1, #0]
1a000512:	e7e5      	b.n	1a0004e0 <ActualizarMEFAsc+0x50>
					}
				else	{
					// Ante un cambio de estado se ejecuta el cierre de las puertas.
					Set_CierraPuertasFlag;
1a000514:	4b8e      	ldr	r3, [pc, #568]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a000516:	681a      	ldr	r2, [r3, #0]
1a000518:	f042 0204 	orr.w	r2, r2, #4
1a00051c:	601a      	str	r2, [r3, #0]
					// El piso destino se encuentra abajo.
					estadoActualAsc = BAJANDO;
1a00051e:	2102      	movs	r1, #2
1a000520:	4a8a      	ldr	r2, [pc, #552]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a000522:	7011      	strb	r1, [r2, #0]
					Clr_PidioAperturaFlag;
1a000524:	681a      	ldr	r2, [r3, #0]
1a000526:	f022 0208 	bic.w	r2, r2, #8
1a00052a:	601a      	str	r2, [r3, #0]
1a00052c:	bd10      	pop	{r4, pc}

		break;
			
	case SUBIENDO:
		// Se cerraron las puertas cambia de estado?
		if (estadoActualPuerta == PUERTA_CERRADA)
1a00052e:	4b89      	ldr	r3, [pc, #548]	; (1a000754 <ActualizarMEFAsc+0x2c4>)
1a000530:	781b      	ldrb	r3, [r3, #0]
1a000532:	2b00      	cmp	r3, #0
1a000534:	f040 8128 	bne.w	1a000788 <ActualizarMEFAsc+0x2f8>
			{
			gpioWrite (LED_PBDETENIDO, 0);
1a000538:	2100      	movs	r1, #0
1a00053a:	202d      	movs	r0, #45	; 0x2d
1a00053c:	f001 fcb4 	bl	1a001ea8 <gpioWrite>
			gpioWrite (LED_ASCMOVIENDO, 1);
1a000540:	2101      	movs	r1, #1
1a000542:	202a      	movs	r0, #42	; 0x2a
1a000544:	f001 fcb0 	bl	1a001ea8 <gpioWrite>
	
			// SALIDA EN EL ESTADO:
			// Se hace subir el ascensor, demorara en subir lo configurado en "velPisoPiso".
			if (delayRead(&timPisoPiso))
1a000548:	4885      	ldr	r0, [pc, #532]	; (1a000760 <ActualizarMEFAsc+0x2d0>)
1a00054a:	f001 fbb9 	bl	1a001cc0 <delayRead>
1a00054e:	2800      	cmp	r0, #0
1a000550:	f000 811a 	beq.w	1a000788 <ActualizarMEFAsc+0x2f8>
				{
				pisoActual = pisoActual + 1;
1a000554:	4a80      	ldr	r2, [pc, #512]	; (1a000758 <ActualizarMEFAsc+0x2c8>)
1a000556:	7813      	ldrb	r3, [r2, #0]
1a000558:	3301      	adds	r3, #1
1a00055a:	b25b      	sxtb	r3, r3
1a00055c:	7013      	strb	r3, [r2, #0]
				//Se consulta si llego.
				if (pisoActual == pisoDestino)
1a00055e:	4a7f      	ldr	r2, [pc, #508]	; (1a00075c <ActualizarMEFAsc+0x2cc>)
1a000560:	f992 2000 	ldrsb.w	r2, [r2]
1a000564:	4293      	cmp	r3, r2
1a000566:	f040 810f 	bne.w	1a000788 <ActualizarMEFAsc+0x2f8>
					{
					// CAMBIO DE ESTADO:
					estadoActualAsc = PARADO;
1a00056a:	2203      	movs	r2, #3
1a00056c:	4b77      	ldr	r3, [pc, #476]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a00056e:	701a      	strb	r2, [r3, #0]
					Clr_PideNuevoPisoFlag;
1a000570:	4a77      	ldr	r2, [pc, #476]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a000572:	6813      	ldr	r3, [r2, #0]
1a000574:	f023 0310 	bic.w	r3, r3, #16
1a000578:	6013      	str	r3, [r2, #0]
					gpioWrite (LED_ASCMOVIENDO, 0);
1a00057a:	2100      	movs	r1, #0
1a00057c:	202a      	movs	r0, #42	; 0x2a
1a00057e:	f001 fc93 	bl	1a001ea8 <gpioWrite>
					gpioWrite (LED_PBDETENIDO, 1);
1a000582:	2101      	movs	r1, #1
1a000584:	202d      	movs	r0, #45	; 0x2d
1a000586:	f001 fc8f 	bl	1a001ea8 <gpioWrite>
1a00058a:	bd10      	pop	{r4, pc}
			}
		break;

	case BAJANDO:
		// Se cerraron las puertas cambia de estado?
		if (estadoActualPuerta == PUERTA_CERRADA)
1a00058c:	4b71      	ldr	r3, [pc, #452]	; (1a000754 <ActualizarMEFAsc+0x2c4>)
1a00058e:	781b      	ldrb	r3, [r3, #0]
1a000590:	2b00      	cmp	r3, #0
1a000592:	f040 80f9 	bne.w	1a000788 <ActualizarMEFAsc+0x2f8>
			{
			gpioWrite (LED_PBDETENIDO, 0);
1a000596:	2100      	movs	r1, #0
1a000598:	202d      	movs	r0, #45	; 0x2d
1a00059a:	f001 fc85 	bl	1a001ea8 <gpioWrite>
			gpioWrite (LED_ASCMOVIENDO, 1);
1a00059e:	2101      	movs	r1, #1
1a0005a0:	202a      	movs	r0, #42	; 0x2a
1a0005a2:	f001 fc81 	bl	1a001ea8 <gpioWrite>
		
			// SALIDA EN EL ESTADO:
			// Se hace bajar el ascensor, demorara en subir lo configurado en "velPisoPiso".
			if (delayRead(&timPisoPiso))
1a0005a6:	486e      	ldr	r0, [pc, #440]	; (1a000760 <ActualizarMEFAsc+0x2d0>)
1a0005a8:	f001 fb8a 	bl	1a001cc0 <delayRead>
1a0005ac:	2800      	cmp	r0, #0
1a0005ae:	f000 80eb 	beq.w	1a000788 <ActualizarMEFAsc+0x2f8>
				{
				pisoActual = pisoActual - 1;
1a0005b2:	4a69      	ldr	r2, [pc, #420]	; (1a000758 <ActualizarMEFAsc+0x2c8>)
1a0005b4:	7813      	ldrb	r3, [r2, #0]
1a0005b6:	3b01      	subs	r3, #1
1a0005b8:	b25b      	sxtb	r3, r3
1a0005ba:	7013      	strb	r3, [r2, #0]
				//Se consulta si llego.
				if (pisoActual == pisoDestino)
1a0005bc:	4a67      	ldr	r2, [pc, #412]	; (1a00075c <ActualizarMEFAsc+0x2cc>)
1a0005be:	f992 2000 	ldrsb.w	r2, [r2]
1a0005c2:	4293      	cmp	r3, r2
1a0005c4:	f040 80e0 	bne.w	1a000788 <ActualizarMEFAsc+0x2f8>
					{
					// CAMBIO DE ESTADO:
					estadoActualAsc = PARADO;
1a0005c8:	2203      	movs	r2, #3
1a0005ca:	4b60      	ldr	r3, [pc, #384]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a0005cc:	701a      	strb	r2, [r3, #0]
					Clr_PideNuevoPisoFlag;
1a0005ce:	4a60      	ldr	r2, [pc, #384]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a0005d0:	6813      	ldr	r3, [r2, #0]
1a0005d2:	f023 0310 	bic.w	r3, r3, #16
1a0005d6:	6013      	str	r3, [r2, #0]
					gpioWrite (LED_ASCMOVIENDO, 0);
1a0005d8:	2100      	movs	r1, #0
1a0005da:	202a      	movs	r0, #42	; 0x2a
1a0005dc:	f001 fc64 	bl	1a001ea8 <gpioWrite>
					gpioWrite (LED_PBDETENIDO, 1);
1a0005e0:	2101      	movs	r1, #1
1a0005e2:	202d      	movs	r0, #45	; 0x2d
1a0005e4:	f001 fc60 	bl	1a001ea8 <gpioWrite>
1a0005e8:	bd10      	pop	{r4, pc}
			}
		break;

	case PARADO:
		// AL INGRESAR AL EL ESTADO SE EJECUTA POR UNICA VEZ:
		if (!Ask_AscParadoFlag)
1a0005ea:	4b59      	ldr	r3, [pc, #356]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a0005ec:	681b      	ldr	r3, [r3, #0]
1a0005ee:	f013 0f01 	tst.w	r3, #1
1a0005f2:	d115      	bne.n	1a000620 <ActualizarMEFAsc+0x190>
			{
			if (estadoActualPuerta == PUERTA_CERRADA)
1a0005f4:	4b57      	ldr	r3, [pc, #348]	; (1a000754 <ActualizarMEFAsc+0x2c4>)
1a0005f6:	781b      	ldrb	r3, [r3, #0]
1a0005f8:	b163      	cbz	r3, 1a000614 <ActualizarMEFAsc+0x184>
				Set_AbrePuertasFlag;			// MEF ascensor solicita apertura de puertas
			else if (estadoActualPuerta == PUERTA_ABIERTA)
1a0005fa:	2b02      	cmp	r3, #2
1a0005fc:	f040 80c4 	bne.w	1a000788 <ActualizarMEFAsc+0x2f8>
				{
				Set_CierraPuertasFlag;			// MEF ascensor solicita cierre de puertas
1a000600:	4b53      	ldr	r3, [pc, #332]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a000602:	681a      	ldr	r2, [r3, #0]
1a000604:	f042 0204 	orr.w	r2, r2, #4
1a000608:	601a      	str	r2, [r3, #0]
				Set_AscParadoFlag;
1a00060a:	681a      	ldr	r2, [r3, #0]
1a00060c:	f042 0201 	orr.w	r2, r2, #1
1a000610:	601a      	str	r2, [r3, #0]
1a000612:	bd10      	pop	{r4, pc}
				Set_AbrePuertasFlag;			// MEF ascensor solicita apertura de puertas
1a000614:	4a4e      	ldr	r2, [pc, #312]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a000616:	6813      	ldr	r3, [r2, #0]
1a000618:	f043 0302 	orr.w	r3, r3, #2
1a00061c:	6013      	str	r3, [r2, #0]
1a00061e:	bd10      	pop	{r4, pc}
				}
			}
			
		else if (estadoActualPuerta == PUERTA_CERRADA)
1a000620:	4b4c      	ldr	r3, [pc, #304]	; (1a000754 <ActualizarMEFAsc+0x2c4>)
1a000622:	781b      	ldrb	r3, [r3, #0]
1a000624:	2b00      	cmp	r3, #0
1a000626:	f040 80af 	bne.w	1a000788 <ActualizarMEFAsc+0x2f8>
			{
			// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
			CargaNuevoPiso();
1a00062a:	f7ff feff 	bl	1a00042c <CargaNuevoPiso>
			
			if (Ask_PideNuevoPisoFlag)
1a00062e:	4b48      	ldr	r3, [pc, #288]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a000630:	681b      	ldr	r3, [r3, #0]
1a000632:	f013 0f10 	tst.w	r3, #16
1a000636:	d024      	beq.n	1a000682 <ActualizarMEFAsc+0x1f2>
				{
				Clr_AscParadoFlag;
1a000638:	4a45      	ldr	r2, [pc, #276]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a00063a:	6813      	ldr	r3, [r2, #0]
1a00063c:	f023 0301 	bic.w	r3, r3, #1
1a000640:	6013      	str	r3, [r2, #0]
				if (pisoActual < pisoDestino) //COMPLETAR!!! no tendria que venir el mismo piso...
1a000642:	4b45      	ldr	r3, [pc, #276]	; (1a000758 <ActualizarMEFAsc+0x2c8>)
1a000644:	f993 2000 	ldrsb.w	r2, [r3]
1a000648:	4b44      	ldr	r3, [pc, #272]	; (1a00075c <ActualizarMEFAsc+0x2cc>)
1a00064a:	f993 3000 	ldrsb.w	r3, [r3]
1a00064e:	429a      	cmp	r2, r3
1a000650:	da0b      	bge.n	1a00066a <ActualizarMEFAsc+0x1da>
					{
					// El piso se encuentra arriba.
					estadoActualAsc = SUBIENDO;
1a000652:	2401      	movs	r4, #1
1a000654:	4b3d      	ldr	r3, [pc, #244]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a000656:	701c      	strb	r4, [r3, #0]
					gpioWrite (LED_PBDETENIDO, 0);
1a000658:	2100      	movs	r1, #0
1a00065a:	202d      	movs	r0, #45	; 0x2d
1a00065c:	f001 fc24 	bl	1a001ea8 <gpioWrite>
					gpioWrite (LED_ASCMOVIENDO, 1);
1a000660:	4621      	mov	r1, r4
1a000662:	202a      	movs	r0, #42	; 0x2a
1a000664:	f001 fc20 	bl	1a001ea8 <gpioWrite>
1a000668:	bd10      	pop	{r4, pc}
					}
				else	{
					// El piso se encuentra abajo.
					estadoActualAsc = BAJANDO;
1a00066a:	2202      	movs	r2, #2
1a00066c:	4b37      	ldr	r3, [pc, #220]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a00066e:	701a      	strb	r2, [r3, #0]
					gpioWrite (LED_PBDETENIDO, 0);
1a000670:	2100      	movs	r1, #0
1a000672:	202d      	movs	r0, #45	; 0x2d
1a000674:	f001 fc18 	bl	1a001ea8 <gpioWrite>
					gpioWrite (LED_ASCMOVIENDO, 1);
1a000678:	2101      	movs	r1, #1
1a00067a:	202a      	movs	r0, #42	; 0x2a
1a00067c:	f001 fc14 	bl	1a001ea8 <gpioWrite>
1a000680:	bd10      	pop	{r4, pc}
					}
				}
			
			//VER!!! si esta en plata baja!
			// Se consulta si hay que ir a PB por tiempo.
			else if (delayRead(&timRetornoPB))
1a000682:	4838      	ldr	r0, [pc, #224]	; (1a000764 <ActualizarMEFAsc+0x2d4>)
1a000684:	f001 fb1c 	bl	1a001cc0 <delayRead>
1a000688:	2800      	cmp	r0, #0
1a00068a:	d07d      	beq.n	1a000788 <ActualizarMEFAsc+0x2f8>
				{
				Clr_AscParadoFlag;
1a00068c:	4c30      	ldr	r4, [pc, #192]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a00068e:	6823      	ldr	r3, [r4, #0]
1a000690:	f023 0301 	bic.w	r3, r3, #1
1a000694:	6023      	str	r3, [r4, #0]
				estadoActualAsc = YENDO_A_PLANTA_BAJA;
1a000696:	2204      	movs	r2, #4
1a000698:	4b2c      	ldr	r3, [pc, #176]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a00069a:	701a      	strb	r2, [r3, #0]
				pisoDestino = 0;
1a00069c:	2100      	movs	r1, #0
1a00069e:	4b2f      	ldr	r3, [pc, #188]	; (1a00075c <ActualizarMEFAsc+0x2cc>)
1a0006a0:	7019      	strb	r1, [r3, #0]
				gpioWrite (LED_PBDETENIDO, 0);
1a0006a2:	202d      	movs	r0, #45	; 0x2d
1a0006a4:	f001 fc00 	bl	1a001ea8 <gpioWrite>
				gpioWrite (LED_ASCMOVIENDO, 1);
1a0006a8:	2101      	movs	r1, #1
1a0006aa:	202a      	movs	r0, #42	; 0x2a
1a0006ac:	f001 fbfc 	bl	1a001ea8 <gpioWrite>
				
				Clr_PideNuevoPisoFlag;			// SACAR!!!
1a0006b0:	6823      	ldr	r3, [r4, #0]
1a0006b2:	f023 0310 	bic.w	r3, r3, #16
1a0006b6:	6023      	str	r3, [r4, #0]
1a0006b8:	bd10      	pop	{r4, pc}
			}
		break;

	case YENDO_A_PLANTA_BAJA:
		// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
		CargaNuevoPiso();
1a0006ba:	f7ff feb7 	bl	1a00042c <CargaNuevoPiso>
			
		if (Ask_PideNuevoPisoFlag)	
1a0006be:	4b24      	ldr	r3, [pc, #144]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a0006c0:	681b      	ldr	r3, [r3, #0]
1a0006c2:	f013 0f10 	tst.w	r3, #16
1a0006c6:	d013      	beq.n	1a0006f0 <ActualizarMEFAsc+0x260>
			{
			if (pisoActual < pisoDestino)
1a0006c8:	4b23      	ldr	r3, [pc, #140]	; (1a000758 <ActualizarMEFAsc+0x2c8>)
1a0006ca:	f993 2000 	ldrsb.w	r2, [r3]
1a0006ce:	4b23      	ldr	r3, [pc, #140]	; (1a00075c <ActualizarMEFAsc+0x2cc>)
1a0006d0:	f993 3000 	ldrsb.w	r3, [r3]
1a0006d4:	429a      	cmp	r2, r3
1a0006d6:	da19      	bge.n	1a00070c <ActualizarMEFAsc+0x27c>
				{
				// Ante un cambio de estado se ejecuta el cierre de las puertas.
				Set_CierraPuertasFlag;
1a0006d8:	4b1d      	ldr	r3, [pc, #116]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a0006da:	681a      	ldr	r2, [r3, #0]
1a0006dc:	f042 0204 	orr.w	r2, r2, #4
1a0006e0:	601a      	str	r2, [r3, #0]
				// El piso destino se encuentra arriba.
				estadoActualAsc = SUBIENDO;
1a0006e2:	2101      	movs	r1, #1
1a0006e4:	4a19      	ldr	r2, [pc, #100]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a0006e6:	7011      	strb	r1, [r2, #0]
				Clr_PidioAperturaFlag;
1a0006e8:	681a      	ldr	r2, [r3, #0]
1a0006ea:	f022 0208 	bic.w	r2, r2, #8
1a0006ee:	601a      	str	r2, [r3, #0]
				}
			}

		// SALIDA EN EL ESTADO:
		// Se hace bajar o subir el ascensor, demorara en subir lo configurado en "velPisoPiso"
		if (pisoActual > 0) //COMPLETAR!!! no tendria que venir el mismo piso...
1a0006f0:	4b19      	ldr	r3, [pc, #100]	; (1a000758 <ActualizarMEFAsc+0x2c8>)
1a0006f2:	f993 3000 	ldrsb.w	r3, [r3]
1a0006f6:	2b00      	cmp	r3, #0
1a0006f8:	dd15      	ble.n	1a000726 <ActualizarMEFAsc+0x296>
			{
			// El piso actual se encuentra arriba.
			if (delayRead(&timPisoPiso))
1a0006fa:	4819      	ldr	r0, [pc, #100]	; (1a000760 <ActualizarMEFAsc+0x2d0>)
1a0006fc:	f001 fae0 	bl	1a001cc0 <delayRead>
1a000700:	b198      	cbz	r0, 1a00072a <ActualizarMEFAsc+0x29a>
				pisoActual = pisoActual - 1;
1a000702:	4a15      	ldr	r2, [pc, #84]	; (1a000758 <ActualizarMEFAsc+0x2c8>)
1a000704:	7813      	ldrb	r3, [r2, #0]
1a000706:	3b01      	subs	r3, #1
1a000708:	7013      	strb	r3, [r2, #0]
1a00070a:	e00e      	b.n	1a00072a <ActualizarMEFAsc+0x29a>
				Set_CierraPuertasFlag;
1a00070c:	4b10      	ldr	r3, [pc, #64]	; (1a000750 <ActualizarMEFAsc+0x2c0>)
1a00070e:	681a      	ldr	r2, [r3, #0]
1a000710:	f042 0204 	orr.w	r2, r2, #4
1a000714:	601a      	str	r2, [r3, #0]
				estadoActualAsc = BAJANDO;
1a000716:	2102      	movs	r1, #2
1a000718:	4a0c      	ldr	r2, [pc, #48]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a00071a:	7011      	strb	r1, [r2, #0]
				Clr_PidioAperturaFlag;
1a00071c:	681a      	ldr	r2, [r3, #0]
1a00071e:	f022 0208 	bic.w	r2, r2, #8
1a000722:	601a      	str	r2, [r3, #0]
1a000724:	e7e4      	b.n	1a0006f0 <ActualizarMEFAsc+0x260>
			}
		else if (pisoActual < 0) 
1a000726:	2b00      	cmp	r3, #0
1a000728:	db1e      	blt.n	1a000768 <ActualizarMEFAsc+0x2d8>

			}
		
		// CAMBIO DE ESTADO:
		// Se consulta si llego a PB
		if (pisoActual == 0)
1a00072a:	4b0b      	ldr	r3, [pc, #44]	; (1a000758 <ActualizarMEFAsc+0x2c8>)
1a00072c:	f993 3000 	ldrsb.w	r3, [r3]
1a000730:	bb53      	cbnz	r3, 1a000788 <ActualizarMEFAsc+0x2f8>
			{
			gpioWrite (LED_ASCMOVIENDO, 0);
1a000732:	2100      	movs	r1, #0
1a000734:	202a      	movs	r0, #42	; 0x2a
1a000736:	f001 fbb7 	bl	1a001ea8 <gpioWrite>
			estadoActualAsc = EN_PLANTA_BAJA;
1a00073a:	2200      	movs	r2, #0
1a00073c:	4b03      	ldr	r3, [pc, #12]	; (1a00074c <ActualizarMEFAsc+0x2bc>)
1a00073e:	701a      	strb	r2, [r3, #0]
			gpioWrite (LED_PBDETENIDO, 1);
1a000740:	2101      	movs	r1, #1
1a000742:	202d      	movs	r0, #45	; 0x2d
1a000744:	f001 fbb0 	bl	1a001ea8 <gpioWrite>
1a000748:	bd10      	pop	{r4, pc}
1a00074a:	bf00      	nop
1a00074c:	10000120 	.word	0x10000120
1a000750:	10000048 	.word	0x10000048
1a000754:	10000121 	.word	0x10000121
1a000758:	1000004d 	.word	0x1000004d
1a00075c:	1000004e 	.word	0x1000004e
1a000760:	10000080 	.word	0x10000080
1a000764:	100000b0 	.word	0x100000b0
			if (delayRead(&timPisoPiso))
1a000768:	4808      	ldr	r0, [pc, #32]	; (1a00078c <ActualizarMEFAsc+0x2fc>)
1a00076a:	f001 faa9 	bl	1a001cc0 <delayRead>
1a00076e:	2800      	cmp	r0, #0
1a000770:	d0db      	beq.n	1a00072a <ActualizarMEFAsc+0x29a>
				pisoActual = pisoActual + 1;
1a000772:	4a07      	ldr	r2, [pc, #28]	; (1a000790 <ActualizarMEFAsc+0x300>)
1a000774:	7813      	ldrb	r3, [r2, #0]
1a000776:	3301      	adds	r3, #1
1a000778:	7013      	strb	r3, [r2, #0]
1a00077a:	e7d6      	b.n	1a00072a <ActualizarMEFAsc+0x29a>
		
		
	
		// CAMBIO DE ESTADO:
		// Se completo la configuracion.
		estadoActualAsc = EN_PLANTA_BAJA;
1a00077c:	2200      	movs	r2, #0
1a00077e:	4b05      	ldr	r3, [pc, #20]	; (1a000794 <ActualizarMEFAsc+0x304>)
1a000780:	701a      	strb	r2, [r3, #0]
		break;
1a000782:	bd10      	pop	{r4, pc}
	
	

	default:
		// Si "estadoActualAsc" adquiere un valor invalido se configura un estado de recuperacion.
		InicializarMEFAsc();
1a000784:	f7ff fe10 	bl	1a0003a8 <InicializarMEFAsc>
1a000788:	bd10      	pop	{r4, pc}
1a00078a:	bf00      	nop
1a00078c:	10000080 	.word	0x10000080
1a000790:	1000004d 	.word	0x1000004d
1a000794:	10000120 	.word	0x10000120

1a000798 <ActualizaMEFPuerta>:

//*********************************************************************************************************************
//		Funcin Actualizar MEF de la puerta del ascensor
//*********************************************************************************************************************
void ActualizaMEFPuerta(void)
{
1a000798:	b508      	push	{r3, lr}
switch(estadoActualPuerta)
1a00079a:	4b3f      	ldr	r3, [pc, #252]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a00079c:	781b      	ldrb	r3, [r3, #0]
1a00079e:	2b05      	cmp	r3, #5
1a0007a0:	d877      	bhi.n	1a000892 <ActualizaMEFPuerta+0xfa>
1a0007a2:	e8df f003 	tbb	[pc, r3]
1a0007a6:	1403      	.short	0x1403
1a0007a8:	624f3f28 	.word	0x624f3f28
	{
	case PUERTA_CERRADA:
		// CAMBIO DE ESTADO:
		// MEF ascensor solicita apertura de puertas?
		if (Ask_AbrePuertasFlag)
1a0007ac:	4b3b      	ldr	r3, [pc, #236]	; (1a00089c <ActualizaMEFPuerta+0x104>)
1a0007ae:	681b      	ldr	r3, [r3, #0]
1a0007b0:	f013 0f02 	tst.w	r3, #2
1a0007b4:	d06f      	beq.n	1a000896 <ActualizaMEFPuerta+0xfe>
			{
			Clr_AbrePuertasFlag;
1a0007b6:	4a39      	ldr	r2, [pc, #228]	; (1a00089c <ActualizaMEFPuerta+0x104>)
1a0007b8:	6813      	ldr	r3, [r2, #0]
1a0007ba:	f023 0302 	bic.w	r3, r3, #2
1a0007be:	6013      	str	r3, [r2, #0]
			estadoActualPuerta = ABRIENDO_PUERTA;
1a0007c0:	2101      	movs	r1, #1
1a0007c2:	4b35      	ldr	r3, [pc, #212]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a0007c4:	7019      	strb	r1, [r3, #0]
			gpioWrite(LED_ABRIENDOPUERTA, 1);
1a0007c6:	202b      	movs	r0, #43	; 0x2b
1a0007c8:	f001 fb6e 	bl	1a001ea8 <gpioWrite>
1a0007cc:	bd08      	pop	{r3, pc}
		break;

	case ABRIENDO_PUERTA:
		// CAMBIO DE ESTADO:
		// Se cumplio tiempo de apertura?
		if (delayRead(&timAbreCierraPuerta))
1a0007ce:	4834      	ldr	r0, [pc, #208]	; (1a0008a0 <ActualizaMEFPuerta+0x108>)
1a0007d0:	f001 fa76 	bl	1a001cc0 <delayRead>
1a0007d4:	2800      	cmp	r0, #0
1a0007d6:	d05e      	beq.n	1a000896 <ActualizaMEFPuerta+0xfe>
			{
			estadoActualPuerta = PUERTA_ABIERTA;
1a0007d8:	2202      	movs	r2, #2
1a0007da:	4b2f      	ldr	r3, [pc, #188]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a0007dc:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_ABRIENDOPUERTA, 0);
1a0007de:	2100      	movs	r1, #0
1a0007e0:	202b      	movs	r0, #43	; 0x2b
1a0007e2:	f001 fb61 	bl	1a001ea8 <gpioWrite>
			gpioWrite(LED_PUERTAABIERTA, 1);
1a0007e6:	2101      	movs	r1, #1
1a0007e8:	2029      	movs	r0, #41	; 0x29
1a0007ea:	f001 fb5d 	bl	1a001ea8 <gpioWrite>
			delayRead(&timPuertaAbierta);
1a0007ee:	482d      	ldr	r0, [pc, #180]	; (1a0008a4 <ActualizaMEFPuerta+0x10c>)
1a0007f0:	f001 fa66 	bl	1a001cc0 <delayRead>
1a0007f4:	bd08      	pop	{r3, pc}
		break;

	case PUERTA_ABIERTA:
		// CAMBIO DE ESTADO:
		// MEF ascensor solicita cierre de puertas y paso el tiempo que tiene que estar abierta la puerta?
		if (Ask_CierraPuertasFlag && delayRead(&timPuertaAbierta))
1a0007f6:	4b29      	ldr	r3, [pc, #164]	; (1a00089c <ActualizaMEFPuerta+0x104>)
1a0007f8:	681b      	ldr	r3, [r3, #0]
1a0007fa:	f013 0f04 	tst.w	r3, #4
1a0007fe:	d04a      	beq.n	1a000896 <ActualizaMEFPuerta+0xfe>
1a000800:	4828      	ldr	r0, [pc, #160]	; (1a0008a4 <ActualizaMEFPuerta+0x10c>)
1a000802:	f001 fa5d 	bl	1a001cc0 <delayRead>
1a000806:	2800      	cmp	r0, #0
1a000808:	d045      	beq.n	1a000896 <ActualizaMEFPuerta+0xfe>
			{
			Clr_CierraPuertasFlag;
1a00080a:	4a24      	ldr	r2, [pc, #144]	; (1a00089c <ActualizaMEFPuerta+0x104>)
1a00080c:	6813      	ldr	r3, [r2, #0]
1a00080e:	f023 0304 	bic.w	r3, r3, #4
1a000812:	6013      	str	r3, [r2, #0]
			estadoActualPuerta = INTENTANDO_CERRAR_PUERTAS;
1a000814:	2203      	movs	r2, #3
1a000816:	4b20      	ldr	r3, [pc, #128]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a000818:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_PUERTAABIERTA, 0);
1a00081a:	2100      	movs	r1, #0
1a00081c:	2029      	movs	r0, #41	; 0x29
1a00081e:	f001 fb43 	bl	1a001ea8 <gpioWrite>
1a000822:	bd08      	pop	{r3, pc}
		break;

	case INTENTANDO_CERRAR_PUERTAS:
		// CAMBIO DE ESTADO:
		// Hay gente?
		if (!gpioRead(TEC1))
1a000824:	2024      	movs	r0, #36	; 0x24
1a000826:	f001 fb6a 	bl	1a001efe <gpioRead>
1a00082a:	b918      	cbnz	r0, 1a000834 <ActualizaMEFPuerta+0x9c>
			estadoActualPuerta = ALARMA_PUERTA_ABIERTA;	// Hay gente.
1a00082c:	2205      	movs	r2, #5
1a00082e:	4b1a      	ldr	r3, [pc, #104]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a000830:	701a      	strb	r2, [r3, #0]
1a000832:	bd08      	pop	{r3, pc}
		else	{
			estadoActualPuerta = CERRANDO_PUERTA;		// No hay gente.
1a000834:	2204      	movs	r2, #4
1a000836:	4b18      	ldr	r3, [pc, #96]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a000838:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_CERRANDOPUERTA, 1);
1a00083a:	2101      	movs	r1, #1
1a00083c:	202c      	movs	r0, #44	; 0x2c
1a00083e:	f001 fb33 	bl	1a001ea8 <gpioWrite>
1a000842:	bd08      	pop	{r3, pc}
	
	
	case CERRANDO_PUERTA:
		// CAMBIO DE ESTADO:
		// Se cumplio tiempo de cierre? 
		if (delayRead(&timAbreCierraPuerta))
1a000844:	4816      	ldr	r0, [pc, #88]	; (1a0008a0 <ActualizaMEFPuerta+0x108>)
1a000846:	f001 fa3b 	bl	1a001cc0 <delayRead>
1a00084a:	b938      	cbnz	r0, 1a00085c <ActualizaMEFPuerta+0xc4>
			{
			estadoActualPuerta = PUERTA_CERRADA;
			gpioWrite(LED_CERRANDOPUERTA, 0);
			}
		// Hay gente?
		if (!gpioRead(TEC1))
1a00084c:	2024      	movs	r0, #36	; 0x24
1a00084e:	f001 fb56 	bl	1a001efe <gpioRead>
1a000852:	bb00      	cbnz	r0, 1a000896 <ActualizaMEFPuerta+0xfe>
			estadoActualPuerta = ABRIENDO_PUERTA;	// Hay gente.
1a000854:	2201      	movs	r2, #1
1a000856:	4b10      	ldr	r3, [pc, #64]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a000858:	701a      	strb	r2, [r3, #0]
1a00085a:	bd08      	pop	{r3, pc}
			estadoActualPuerta = PUERTA_CERRADA;
1a00085c:	2100      	movs	r1, #0
1a00085e:	4b0e      	ldr	r3, [pc, #56]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a000860:	7019      	strb	r1, [r3, #0]
			gpioWrite(LED_CERRANDOPUERTA, 0);
1a000862:	202c      	movs	r0, #44	; 0x2c
1a000864:	f001 fb20 	bl	1a001ea8 <gpioWrite>
1a000868:	e7f0      	b.n	1a00084c <ActualizaMEFPuerta+0xb4>
		break;

	case ALARMA_PUERTA_ABIERTA:
		// SALIDA EN EL ESTADO:
		if (delayRead(&timAlarPuerta))
1a00086a:	480f      	ldr	r0, [pc, #60]	; (1a0008a8 <ActualizaMEFPuerta+0x110>)
1a00086c:	f001 fa28 	bl	1a001cc0 <delayRead>
1a000870:	b958      	cbnz	r0, 1a00088a <ActualizaMEFPuerta+0xf2>
			gpioToggle(LED_ALARMAPABIERTA);		// Parpadeo led que Indica alarma de puerta abierta.
	
		// CAMBIO DE ESTADO:
		// Hay gente?
		if (gpioRead(TEC1))
1a000872:	2024      	movs	r0, #36	; 0x24
1a000874:	f001 fb43 	bl	1a001efe <gpioRead>
1a000878:	b168      	cbz	r0, 1a000896 <ActualizaMEFPuerta+0xfe>
			{
			estadoActualPuerta = CERRANDO_PUERTA;	// No hay gente.
1a00087a:	2204      	movs	r2, #4
1a00087c:	4b06      	ldr	r3, [pc, #24]	; (1a000898 <ActualizaMEFPuerta+0x100>)
1a00087e:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_ALARMAPABIERTA, 0);
1a000880:	2100      	movs	r1, #0
1a000882:	2028      	movs	r0, #40	; 0x28
1a000884:	f001 fb10 	bl	1a001ea8 <gpioWrite>
1a000888:	bd08      	pop	{r3, pc}
			gpioToggle(LED_ALARMAPABIERTA);		// Parpadeo led que Indica alarma de puerta abierta.
1a00088a:	2028      	movs	r0, #40	; 0x28
1a00088c:	f001 fb61 	bl	1a001f52 <gpioToggle>
1a000890:	e7ef      	b.n	1a000872 <ActualizaMEFPuerta+0xda>
		break;


	default:
		// Si "estadoActualPuerta" adquiere un valor invalido se configura un estado de recuperacion.
		InicializarMEFPuerta();
1a000892:	f7ff fda3 	bl	1a0003dc <InicializarMEFPuerta>
1a000896:	bd08      	pop	{r3, pc}
1a000898:	10000121 	.word	0x10000121
1a00089c:	10000048 	.word	0x10000048
1a0008a0:	10000050 	.word	0x10000050
1a0008a4:	10000098 	.word	0x10000098
1a0008a8:	10000068 	.word	0x10000068

1a0008ac <configurarTecladoMatricial>:


//*********************************************************************************************************************
//
//*********************************************************************************************************************
void configurarTecladoMatricial (void){
1a0008ac:	b510      	push	{r4, lr}
    
uint8_t i = 0;  // Variable para recorrer el vector de filas y columnas.
    
/* Se recorre todo el vector de filas para configurar los pines como salida.*/
    for ( i = 0; i < 4; i++){
1a0008ae:	2400      	movs	r4, #0
1a0008b0:	e006      	b.n	1a0008c0 <configurarTecladoMatricial+0x14>
        gpioConfig(pinesFila[i], GPIO_OUTPUT);
1a0008b2:	2101      	movs	r1, #1
1a0008b4:	4b09      	ldr	r3, [pc, #36]	; (1a0008dc <configurarTecladoMatricial+0x30>)
1a0008b6:	5d18      	ldrb	r0, [r3, r4]
1a0008b8:	f001 fa3c 	bl	1a001d34 <gpioConfig>
    for ( i = 0; i < 4; i++){
1a0008bc:	3401      	adds	r4, #1
1a0008be:	b2e4      	uxtb	r4, r4
1a0008c0:	2c03      	cmp	r4, #3
1a0008c2:	d9f6      	bls.n	1a0008b2 <configurarTecladoMatricial+0x6>
1a0008c4:	2400      	movs	r4, #0
1a0008c6:	e006      	b.n	1a0008d6 <configurarTecladoMatricial+0x2a>
    } 

/* Se recorre todo el vector de columnas para configurar los pines como entrada en PULLUP (resistencia interna).*/
    for ( i = 0; i < 4; i++){
        gpioConfig(pinesColumna[i], GPIO_INPUT_PULLUP);
1a0008c8:	2102      	movs	r1, #2
1a0008ca:	4b05      	ldr	r3, [pc, #20]	; (1a0008e0 <configurarTecladoMatricial+0x34>)
1a0008cc:	5d18      	ldrb	r0, [r3, r4]
1a0008ce:	f001 fa31 	bl	1a001d34 <gpioConfig>
    for ( i = 0; i < 4; i++){
1a0008d2:	3401      	adds	r4, #1
1a0008d4:	b2e4      	uxtb	r4, r4
1a0008d6:	2c03      	cmp	r4, #3
1a0008d8:	d9f6      	bls.n	1a0008c8 <configurarTecladoMatricial+0x1c>
    }
}
1a0008da:	bd10      	pop	{r4, pc}
1a0008dc:	1a0024f0 	.word	0x1a0024f0
1a0008e0:	1a0024ec 	.word	0x1a0024ec

1a0008e4 <InicializarMEF_tecladoMatrical>:


//*********************************************************************************************************************
//
//*********************************************************************************************************************
void InicializarMEF_tecladoMatrical(void) {
1a0008e4:	b510      	push	{r4, lr}

estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a0008e6:	2400      	movs	r4, #0
1a0008e8:	4b03      	ldr	r3, [pc, #12]	; (1a0008f8 <InicializarMEF_tecladoMatrical+0x14>)
1a0008ea:	701c      	strb	r4, [r3, #0]
configurarTecladoMatricial();
1a0008ec:	f7ff ffde 	bl	1a0008ac <configurarTecladoMatricial>
estadoMefScanTeclado = ESCANEANDO_TECLADO;
1a0008f0:	4b02      	ldr	r3, [pc, #8]	; (1a0008fc <InicializarMEF_tecladoMatrical+0x18>)
1a0008f2:	701c      	strb	r4, [r3, #0]
1a0008f4:	bd10      	pop	{r4, pc}
1a0008f6:	bf00      	nop
1a0008f8:	100000e9 	.word	0x100000e9
1a0008fc:	100000e8 	.word	0x100000e8

1a000900 <ScanTeclas>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
bool_t ScanTeclas(void)
{
1a000900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

uint8_t f = 0; // Variable para recorrer los vectores de filas.
uint8_t c = 0; // Variable para recorrer los vectores de columnas.

// Lo primero que hacemos es poner todas las filas en estado "bajo".
for (f=0; f<4; f++)
1a000902:	2400      	movs	r4, #0
1a000904:	e006      	b.n	1a000914 <ScanTeclas+0x14>
	gpioWrite(pinesFila[f], 0);
1a000906:	2100      	movs	r1, #0
1a000908:	4b1f      	ldr	r3, [pc, #124]	; (1a000988 <ScanTeclas+0x88>)
1a00090a:	5d18      	ldrb	r0, [r3, r4]
1a00090c:	f001 facc 	bl	1a001ea8 <gpioWrite>
for (f=0; f<4; f++)
1a000910:	3401      	adds	r4, #1
1a000912:	b2e4      	uxtb	r4, r4
1a000914:	2c03      	cmp	r4, #3
1a000916:	d9f6      	bls.n	1a000906 <ScanTeclas+0x6>
1a000918:	2600      	movs	r6, #0
1a00091a:	e027      	b.n	1a00096c <ScanTeclas+0x6c>
	// Si leo un estado BAJO en una columna entonces puede haber una tecla presionada-
        if (!gpioRead(pinesColumna[c]))
		{
		//Se ponen todas las filas en "alto", excepto la primera que se deja en "bajo".
		for (f=1; f<4 ; f++)
			gpioWrite(pinesFila[f], 1);
1a00091c:	2101      	movs	r1, #1
1a00091e:	4b1a      	ldr	r3, [pc, #104]	; (1a000988 <ScanTeclas+0x88>)
1a000920:	5d58      	ldrb	r0, [r3, r5]
1a000922:	f001 fac1 	bl	1a001ea8 <gpioWrite>
		for (f=1; f<4 ; f++)
1a000926:	3501      	adds	r5, #1
1a000928:	b2ed      	uxtb	r5, r5
1a00092a:	2d03      	cmp	r5, #3
1a00092c:	d9f6      	bls.n	1a00091c <ScanTeclas+0x1c>
1a00092e:	2400      	movs	r4, #0
		// Se procede a buscar la tecla presionada, para ello se recorren las filas. Ac谩 lo que buscamos es la coordenada de la fila.
		for (f=0; f<4; f++)
1a000930:	2c03      	cmp	r4, #3
1a000932:	d819      	bhi.n	1a000968 <ScanTeclas+0x68>
			{
			// El siguiente if es para evitar un 铆ndice negativo en el vector.
			if (f > 0)
1a000934:	b12c      	cbz	r4, 1a000942 <ScanTeclas+0x42>
				gpioWrite(pinesFila[f-1], 1);
1a000936:	1e63      	subs	r3, r4, #1
1a000938:	2101      	movs	r1, #1
1a00093a:	4a13      	ldr	r2, [pc, #76]	; (1a000988 <ScanTeclas+0x88>)
1a00093c:	5cd0      	ldrb	r0, [r2, r3]
1a00093e:	f001 fab3 	bl	1a001ea8 <gpioWrite>
			gpioWrite(pinesFila[f], 0);
1a000942:	2100      	movs	r1, #0
1a000944:	4b10      	ldr	r3, [pc, #64]	; (1a000988 <ScanTeclas+0x88>)
1a000946:	5d18      	ldrb	r0, [r3, r4]
1a000948:	f001 faae 	bl	1a001ea8 <gpioWrite>

			//Se testea la columna actual con la fila actual, si detectamos un estado "BAJO"
			//en alguna columna, significa que hemos encontrado la coordenada de la fila 
			//correspondiente. Con esta coordenada ya podemos detectar que tecla fue presionada.
			if (!gpioRead(pinesColumna[c]))
1a00094c:	4b0f      	ldr	r3, [pc, #60]	; (1a00098c <ScanTeclas+0x8c>)
1a00094e:	5dd8      	ldrb	r0, [r3, r7]
1a000950:	f001 fad5 	bl	1a001efe <gpioRead>
1a000954:	b110      	cbz	r0, 1a00095c <ScanTeclas+0x5c>
		for (f=0; f<4; f++)
1a000956:	3401      	adds	r4, #1
1a000958:	b2e4      	uxtb	r4, r4
1a00095a:	e7e9      	b.n	1a000930 <ScanTeclas+0x30>
				{
				ret = 1;
				key = f * 4 + c;
1a00095c:	eb06 0484 	add.w	r4, r6, r4, lsl #2
1a000960:	4b0b      	ldr	r3, [pc, #44]	; (1a000990 <ScanTeclas+0x90>)
1a000962:	801c      	strh	r4, [r3, #0]
				return ret;
1a000964:	2001      	movs	r0, #1
1a000966:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
for (c=0; c<4; c++)
1a000968:	3601      	adds	r6, #1
1a00096a:	b2f6      	uxtb	r6, r6
1a00096c:	2e03      	cmp	r6, #3
1a00096e:	d808      	bhi.n	1a000982 <ScanTeclas+0x82>
        if (!gpioRead(pinesColumna[c]))
1a000970:	4637      	mov	r7, r6
1a000972:	4b06      	ldr	r3, [pc, #24]	; (1a00098c <ScanTeclas+0x8c>)
1a000974:	5d98      	ldrb	r0, [r3, r6]
1a000976:	f001 fac2 	bl	1a001efe <gpioRead>
1a00097a:	2800      	cmp	r0, #0
1a00097c:	d1f4      	bne.n	1a000968 <ScanTeclas+0x68>
1a00097e:	2501      	movs	r5, #1
1a000980:	e7d3      	b.n	1a00092a <ScanTeclas+0x2a>
				*/
				}
			}
		}
	}
return ret;
1a000982:	2000      	movs	r0, #0
}
1a000984:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
1a000986:	bf00      	nop
1a000988:	1a0024f0 	.word	0x1a0024f0
1a00098c:	1a0024ec 	.word	0x1a0024ec
1a000990:	100000f4 	.word	0x100000f4

1a000994 <ActualizaMEFScanTecla>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void ActualizaMEFScanTecla(void)
{
1a000994:	b508      	push	{r3, lr}
// Esta rutina hace la captura de una tecla con anti-bouncing.
// Al haber confirmado el proceso de una tecla pone "hayTeclaDisponible" en 1;
// Y la tecla confirmada en "teclaPresionada".

switch(estadoMefScanTeclado)
1a000996:	4b25      	ldr	r3, [pc, #148]	; (1a000a2c <ActualizaMEFScanTecla+0x98>)
1a000998:	781b      	ldrb	r3, [r3, #0]
1a00099a:	2b01      	cmp	r3, #1
1a00099c:	d011      	beq.n	1a0009c2 <ActualizaMEFScanTecla+0x2e>
1a00099e:	b123      	cbz	r3, 1a0009aa <ActualizaMEFScanTecla+0x16>
1a0009a0:	2b02      	cmp	r3, #2
1a0009a2:	d037      	beq.n	1a000a14 <ActualizaMEFScanTecla+0x80>
			}
	break;

	
	default:
	InicializarMEF_tecladoMatrical();
1a0009a4:	f7ff ff9e 	bl	1a0008e4 <InicializarMEF_tecladoMatrical>
1a0009a8:	bd08      	pop	{r3, pc}
		if (ScanTeclas())
1a0009aa:	f7ff ffa9 	bl	1a000900 <ScanTeclas>
1a0009ae:	2800      	cmp	r0, #0
1a0009b0:	d0fa      	beq.n	1a0009a8 <ActualizaMEFScanTecla+0x14>
			teclaPresionada = key;
1a0009b2:	4b1f      	ldr	r3, [pc, #124]	; (1a000a30 <ActualizaMEFScanTecla+0x9c>)
1a0009b4:	881a      	ldrh	r2, [r3, #0]
1a0009b6:	4b1f      	ldr	r3, [pc, #124]	; (1a000a34 <ActualizaMEFScanTecla+0xa0>)
1a0009b8:	801a      	strh	r2, [r3, #0]
			estadoMefScanTeclado = APRETANDO_TECLA;
1a0009ba:	2201      	movs	r2, #1
1a0009bc:	4b1b      	ldr	r3, [pc, #108]	; (1a000a2c <ActualizaMEFScanTecla+0x98>)
1a0009be:	701a      	strb	r2, [r3, #0]
1a0009c0:	bd08      	pop	{r3, pc}
		if (flagEstadoApretandoTecla == 0)
1a0009c2:	4b1d      	ldr	r3, [pc, #116]	; (1a000a38 <ActualizaMEFScanTecla+0xa4>)
1a0009c4:	781b      	ldrb	r3, [r3, #0]
1a0009c6:	b1ab      	cbz	r3, 1a0009f4 <ActualizaMEFScanTecla+0x60>
		if (delayRead(&delayAntirebote))
1a0009c8:	481c      	ldr	r0, [pc, #112]	; (1a000a3c <ActualizaMEFScanTecla+0xa8>)
1a0009ca:	f001 f979 	bl	1a001cc0 <delayRead>
1a0009ce:	2800      	cmp	r0, #0
1a0009d0:	d0ea      	beq.n	1a0009a8 <ActualizaMEFScanTecla+0x14>
			ScanTeclas();
1a0009d2:	f7ff ff95 	bl	1a000900 <ScanTeclas>
			if (teclaPresionada == key)
1a0009d6:	4b17      	ldr	r3, [pc, #92]	; (1a000a34 <ActualizaMEFScanTecla+0xa0>)
1a0009d8:	881a      	ldrh	r2, [r3, #0]
1a0009da:	4b15      	ldr	r3, [pc, #84]	; (1a000a30 <ActualizaMEFScanTecla+0x9c>)
1a0009dc:	881b      	ldrh	r3, [r3, #0]
1a0009de:	429a      	cmp	r2, r3
1a0009e0:	d011      	beq.n	1a000a06 <ActualizaMEFScanTecla+0x72>
				estadoMefScanTeclado = ESCANEANDO_TECLADO;
1a0009e2:	2300      	movs	r3, #0
1a0009e4:	4a11      	ldr	r2, [pc, #68]	; (1a000a2c <ActualizaMEFScanTecla+0x98>)
1a0009e6:	7013      	strb	r3, [r2, #0]
				teclaPresionada = 0xff;
1a0009e8:	21ff      	movs	r1, #255	; 0xff
1a0009ea:	4a12      	ldr	r2, [pc, #72]	; (1a000a34 <ActualizaMEFScanTecla+0xa0>)
1a0009ec:	8011      	strh	r1, [r2, #0]
				flagEstadoApretandoTecla = 0;
1a0009ee:	4a12      	ldr	r2, [pc, #72]	; (1a000a38 <ActualizaMEFScanTecla+0xa4>)
1a0009f0:	7013      	strb	r3, [r2, #0]
1a0009f2:	bd08      	pop	{r3, pc}
			flagEstadoApretandoTecla= 1;
1a0009f4:	2201      	movs	r2, #1
1a0009f6:	4b10      	ldr	r3, [pc, #64]	; (1a000a38 <ActualizaMEFScanTecla+0xa4>)
1a0009f8:	701a      	strb	r2, [r3, #0]
			delayConfig(&delayAntirebote, 40);
1a0009fa:	2228      	movs	r2, #40	; 0x28
1a0009fc:	2300      	movs	r3, #0
1a0009fe:	480f      	ldr	r0, [pc, #60]	; (1a000a3c <ActualizaMEFScanTecla+0xa8>)
1a000a00:	f001 f94e 	bl	1a001ca0 <delayConfig>
1a000a04:	e7e0      	b.n	1a0009c8 <ActualizaMEFScanTecla+0x34>
				estadoMefScanTeclado = IDENTIFICAR_TECLA_Y_ESCRIBIR;
1a000a06:	2202      	movs	r2, #2
1a000a08:	4b08      	ldr	r3, [pc, #32]	; (1a000a2c <ActualizaMEFScanTecla+0x98>)
1a000a0a:	701a      	strb	r2, [r3, #0]
				flagEstadoApretandoTecla = 0;
1a000a0c:	2200      	movs	r2, #0
1a000a0e:	4b0a      	ldr	r3, [pc, #40]	; (1a000a38 <ActualizaMEFScanTecla+0xa4>)
1a000a10:	701a      	strb	r2, [r3, #0]
1a000a12:	bd08      	pop	{r3, pc}
		if (!(ScanTeclas()))
1a000a14:	f7ff ff74 	bl	1a000900 <ScanTeclas>
1a000a18:	2800      	cmp	r0, #0
1a000a1a:	d1c5      	bne.n	1a0009a8 <ActualizaMEFScanTecla+0x14>
			estadoMefScanTeclado = ESCANEANDO_TECLADO;  
1a000a1c:	2200      	movs	r2, #0
1a000a1e:	4b03      	ldr	r3, [pc, #12]	; (1a000a2c <ActualizaMEFScanTecla+0x98>)
1a000a20:	701a      	strb	r2, [r3, #0]
			hayTeclaDisponible = 1;
1a000a22:	2201      	movs	r2, #1
1a000a24:	4b06      	ldr	r3, [pc, #24]	; (1a000a40 <ActualizaMEFScanTecla+0xac>)
1a000a26:	701a      	strb	r2, [r3, #0]
1a000a28:	bd08      	pop	{r3, pc}
1a000a2a:	bf00      	nop
1a000a2c:	100000e8 	.word	0x100000e8
1a000a30:	100000f4 	.word	0x100000f4
1a000a34:	10000000 	.word	0x10000000
1a000a38:	100000ea 	.word	0x100000ea
1a000a3c:	100000d0 	.word	0x100000d0
1a000a40:	100000eb 	.word	0x100000eb

1a000a44 <ingresarDigito>:
bool_t ret = FALSE;	

/* Se testea la columna actual con la fila actual, si detectamos un estado "BAJO"
    en alguna columna, significa que hemos encontrado la coordenada de la fila 
    correspondiente. Con esta coordenada ya podemos detectar que tecla fue presionada.*/
if (hayTeclaDisponible)
1a000a44:	4b19      	ldr	r3, [pc, #100]	; (1a000aac <ingresarDigito+0x68>)
1a000a46:	7818      	ldrb	r0, [r3, #0]
1a000a48:	b148      	cbz	r0, 1a000a5e <ingresarDigito+0x1a>
	{
	hayTeclaDisponible = 0;
1a000a4a:	2200      	movs	r2, #0
1a000a4c:	701a      	strb	r2, [r3, #0]
	ret = TRUE;
                
	/* Etapa en la cual se evalua que digito se ingreso, basicamente llevando la cuenta de las veces que se presion贸 una tecla*/
	switch (indiceTeclaPresionada)
1a000a4e:	4b18      	ldr	r3, [pc, #96]	; (1a000ab0 <ingresarDigito+0x6c>)
1a000a50:	681b      	ldr	r3, [r3, #0]
1a000a52:	2b01      	cmp	r3, #1
1a000a54:	d00c      	beq.n	1a000a70 <ingresarDigito+0x2c>
1a000a56:	b11b      	cbz	r3, 1a000a60 <ingresarDigito+0x1c>
1a000a58:	2b02      	cmp	r3, #2
1a000a5a:	d01e      	beq.n	1a000a9a <ingresarDigito+0x56>
	ret = TRUE;
1a000a5c:	2001      	movs	r0, #1
			   indiceTeclaGuardar = 1;
		break;
		}
	}
return ret;
}    
1a000a5e:	4770      	bx	lr
		case 0:  primerDigito = teclaPresionada;
1a000a60:	4b14      	ldr	r3, [pc, #80]	; (1a000ab4 <ingresarDigito+0x70>)
1a000a62:	881a      	ldrh	r2, [r3, #0]
1a000a64:	4b14      	ldr	r3, [pc, #80]	; (1a000ab8 <ingresarDigito+0x74>)
1a000a66:	801a      	strh	r2, [r3, #0]
			   indiceTeclaPresionada = 1;
1a000a68:	2001      	movs	r0, #1
1a000a6a:	4b11      	ldr	r3, [pc, #68]	; (1a000ab0 <ingresarDigito+0x6c>)
1a000a6c:	6018      	str	r0, [r3, #0]
		break;
1a000a6e:	4770      	bx	lr
		case 1:  segundoDigito = teclaPresionada;
1a000a70:	4b10      	ldr	r3, [pc, #64]	; (1a000ab4 <ingresarDigito+0x70>)
1a000a72:	881b      	ldrh	r3, [r3, #0]
1a000a74:	4a11      	ldr	r2, [pc, #68]	; (1a000abc <ingresarDigito+0x78>)
1a000a76:	8013      	strh	r3, [r2, #0]
			    if ((pinesTeclado[segundoDigito] == 'A') || (pinesTeclado[segundoDigito] == 'B')) {
1a000a78:	4a11      	ldr	r2, [pc, #68]	; (1a000ac0 <ingresarDigito+0x7c>)
1a000a7a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
1a000a7e:	3b41      	subs	r3, #65	; 0x41
1a000a80:	b29b      	uxth	r3, r3
1a000a82:	2b01      	cmp	r3, #1
1a000a84:	d904      	bls.n	1a000a90 <ingresarDigito+0x4c>
				indiceTeclaPresionada = 2;
1a000a86:	2202      	movs	r2, #2
1a000a88:	4b09      	ldr	r3, [pc, #36]	; (1a000ab0 <ingresarDigito+0x6c>)
1a000a8a:	601a      	str	r2, [r3, #0]
	ret = TRUE;
1a000a8c:	2001      	movs	r0, #1
1a000a8e:	4770      	bx	lr
				indiceTeclaPresionada = 0;
1a000a90:	2200      	movs	r2, #0
1a000a92:	4b07      	ldr	r3, [pc, #28]	; (1a000ab0 <ingresarDigito+0x6c>)
1a000a94:	601a      	str	r2, [r3, #0]
	ret = TRUE;
1a000a96:	2001      	movs	r0, #1
1a000a98:	4770      	bx	lr
		case 2:  confirmar = teclaPresionada;
1a000a9a:	4b06      	ldr	r3, [pc, #24]	; (1a000ab4 <ingresarDigito+0x70>)
1a000a9c:	881a      	ldrh	r2, [r3, #0]
1a000a9e:	4b09      	ldr	r3, [pc, #36]	; (1a000ac4 <ingresarDigito+0x80>)
1a000aa0:	801a      	strh	r2, [r3, #0]
			   indiceTeclaPresionada= 0;
1a000aa2:	2200      	movs	r2, #0
1a000aa4:	4b02      	ldr	r3, [pc, #8]	; (1a000ab0 <ingresarDigito+0x6c>)
1a000aa6:	601a      	str	r2, [r3, #0]
	ret = TRUE;
1a000aa8:	2001      	movs	r0, #1
		break;
1a000aaa:	4770      	bx	lr
1a000aac:	100000eb 	.word	0x100000eb
1a000ab0:	100000f0 	.word	0x100000f0
1a000ab4:	10000000 	.word	0x10000000
1a000ab8:	100000f6 	.word	0x100000f6
1a000abc:	100000f8 	.word	0x100000f8
1a000ac0:	1a0024f4 	.word	0x1a0024f4
1a000ac4:	100000c8 	.word	0x100000c8

1a000ac8 <guardarPisoSimple>:
//*********************************************************************************************************************
//
//*********************************************************************************************************************
void guardarPisoSimple (int primerDigito) {
	/*======= Funcion que almacena el piso ingresado, de un solo digito, en el vector =======*/
	if (indice < 10) {
1a000ac8:	4b0c      	ldr	r3, [pc, #48]	; (1a000afc <guardarPisoSimple+0x34>)
1a000aca:	681b      	ldr	r3, [r3, #0]
1a000acc:	2b09      	cmp	r3, #9
1a000ace:	dc0a      	bgt.n	1a000ae6 <guardarPisoSimple+0x1e>

		if (indice > 0)
1a000ad0:	2b00      	cmp	r3, #0
1a000ad2:	dd0c      	ble.n	1a000aee <guardarPisoSimple+0x26>
			almacenarPisos[indice] = pinesTeclado[primerDigito];
1a000ad4:	4a0a      	ldr	r2, [pc, #40]	; (1a000b00 <guardarPisoSimple+0x38>)
1a000ad6:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
1a000ada:	4a0a      	ldr	r2, [pc, #40]	; (1a000b04 <guardarPisoSimple+0x3c>)
1a000adc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		else
			almacenarPisos[0] = pinesTeclado[primerDigito];

		indice ++;
1a000ae0:	3301      	adds	r3, #1
1a000ae2:	4a06      	ldr	r2, [pc, #24]	; (1a000afc <guardarPisoSimple+0x34>)
1a000ae4:	6013      	str	r3, [r2, #0]
	}

	/*======= Etapa para reinicializar las variables utilizadas y prepararlas para el proximo ingreso =======*/
	primerDigito  = 0;
	segundoDigito = 0;
1a000ae6:	2200      	movs	r2, #0
1a000ae8:	4b07      	ldr	r3, [pc, #28]	; (1a000b08 <guardarPisoSimple+0x40>)
1a000aea:	801a      	strh	r2, [r3, #0]
1a000aec:	4770      	bx	lr
			almacenarPisos[0] = pinesTeclado[primerDigito];
1a000aee:	4a04      	ldr	r2, [pc, #16]	; (1a000b00 <guardarPisoSimple+0x38>)
1a000af0:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
1a000af4:	4a03      	ldr	r2, [pc, #12]	; (1a000b04 <guardarPisoSimple+0x3c>)
1a000af6:	6011      	str	r1, [r2, #0]
1a000af8:	e7f2      	b.n	1a000ae0 <guardarPisoSimple+0x18>
1a000afa:	bf00      	nop
1a000afc:	100000ec 	.word	0x100000ec
1a000b00:	1a0024f4 	.word	0x1a0024f4
1a000b04:	10000124 	.word	0x10000124
1a000b08:	100000f8 	.word	0x100000f8

1a000b0c <guardarPisoDoble>:
	/*======= Funcion que almacena el piso ingresado, de dos digitos, en el vector =======*/
	
	int carga = 0;
	
	/*======= Etapa de guardar un subsuelo (numero negativo) en el vector de almacenamiento =======*/
	if (pinesTeclado[primerDigito] == '#' && pinesTeclado[segundoDigito] <= 5)
1a000b0c:	4b15      	ldr	r3, [pc, #84]	; (1a000b64 <guardarPisoDoble+0x58>)
1a000b0e:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
1a000b12:	2b23      	cmp	r3, #35	; 0x23
1a000b14:	d017      	beq.n	1a000b46 <guardarPisoDoble+0x3a>
		carga = 0 - pinesTeclado[segundoDigito];
	else 
		carga = (pinesTeclado[primerDigito] * 10) + pinesTeclado[segundoDigito];
1a000b16:	eb03 0383 	add.w	r3, r3, r3, lsl #2
1a000b1a:	005a      	lsls	r2, r3, #1
1a000b1c:	4b11      	ldr	r3, [pc, #68]	; (1a000b64 <guardarPisoDoble+0x58>)
1a000b1e:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
1a000b22:	4413      	add	r3, r2
	
	/*======= Etapa para verificar si se desea entrar al modo configuracion =======*/
    if (carga == 99) {
1a000b24:	2b63      	cmp	r3, #99	; 0x63
1a000b26:	d015      	beq.n	1a000b54 <guardarPisoDoble+0x48>
    flagConfiguracion = TRUE;
    }
	
	/*======= Etapa de carga en el vector que almacena los pisos ingresados =======*/	
	if (indice < 10){
1a000b28:	4a0f      	ldr	r2, [pc, #60]	; (1a000b68 <guardarPisoDoble+0x5c>)
1a000b2a:	6812      	ldr	r2, [r2, #0]
1a000b2c:	2a09      	cmp	r2, #9
1a000b2e:	dc09      	bgt.n	1a000b44 <guardarPisoDoble+0x38>

		if (carga <= 20){
1a000b30:	2b14      	cmp	r3, #20
1a000b32:	dc07      	bgt.n	1a000b44 <guardarPisoDoble+0x38>

			if (indice > 0)
1a000b34:	2a00      	cmp	r2, #0
1a000b36:	dd11      	ble.n	1a000b5c <guardarPisoDoble+0x50>
				almacenarPisos[indice] = carga;
1a000b38:	490c      	ldr	r1, [pc, #48]	; (1a000b6c <guardarPisoDoble+0x60>)
1a000b3a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
			else 
				almacenarPisos[0] = carga;

			indice++;
1a000b3e:	3201      	adds	r2, #1
1a000b40:	4b09      	ldr	r3, [pc, #36]	; (1a000b68 <guardarPisoDoble+0x5c>)
1a000b42:	601a      	str	r2, [r3, #0]
1a000b44:	4770      	bx	lr
	if (pinesTeclado[primerDigito] == '#' && pinesTeclado[segundoDigito] <= 5)
1a000b46:	4a07      	ldr	r2, [pc, #28]	; (1a000b64 <guardarPisoDoble+0x58>)
1a000b48:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
1a000b4c:	2a05      	cmp	r2, #5
1a000b4e:	d8e2      	bhi.n	1a000b16 <guardarPisoDoble+0xa>
		carga = 0 - pinesTeclado[segundoDigito];
1a000b50:	4253      	negs	r3, r2
1a000b52:	e7e7      	b.n	1a000b24 <guardarPisoDoble+0x18>
    flagConfiguracion = TRUE;
1a000b54:	2101      	movs	r1, #1
1a000b56:	4a06      	ldr	r2, [pc, #24]	; (1a000b70 <guardarPisoDoble+0x64>)
1a000b58:	7011      	strb	r1, [r2, #0]
1a000b5a:	e7e5      	b.n	1a000b28 <guardarPisoDoble+0x1c>
				almacenarPisos[0] = carga;
1a000b5c:	4903      	ldr	r1, [pc, #12]	; (1a000b6c <guardarPisoDoble+0x60>)
1a000b5e:	600b      	str	r3, [r1, #0]
1a000b60:	e7ed      	b.n	1a000b3e <guardarPisoDoble+0x32>
1a000b62:	bf00      	nop
1a000b64:	1a0024f4 	.word	0x1a0024f4
1a000b68:	100000ec 	.word	0x100000ec
1a000b6c:	10000124 	.word	0x10000124
1a000b70:	1000004c 	.word	0x1000004c

1a000b74 <ActualizarMEF_tecladoMatricial>:
void ActualizarMEF_tecladoMatricial (void) { 
1a000b74:	b508      	push	{r3, lr}
ActualizaMEFScanTecla();
1a000b76:	f7ff ff0d 	bl	1a000994 <ActualizaMEFScanTecla>
switch (estadoMefTecladoMatricial) {
1a000b7a:	4b28      	ldr	r3, [pc, #160]	; (1a000c1c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000b7c:	781b      	ldrb	r3, [r3, #0]
1a000b7e:	2b01      	cmp	r3, #1
1a000b80:	d00d      	beq.n	1a000b9e <ActualizarMEF_tecladoMatricial+0x2a>
1a000b82:	b123      	cbz	r3, 1a000b8e <ActualizarMEF_tecladoMatricial+0x1a>
1a000b84:	2b02      	cmp	r3, #2
1a000b86:	d02b      	beq.n	1a000be0 <ActualizarMEF_tecladoMatricial+0x6c>
		InicializarMEF_tecladoMatrical();
1a000b88:	f7ff feac 	bl	1a0008e4 <InicializarMEF_tecladoMatrical>
1a000b8c:	bd08      	pop	{r3, pc}
		if( ingresarDigito() ) {
1a000b8e:	f7ff ff59 	bl	1a000a44 <ingresarDigito>
1a000b92:	2800      	cmp	r0, #0
1a000b94:	d0fa      	beq.n	1a000b8c <ActualizarMEF_tecladoMatricial+0x18>
				estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_2;
1a000b96:	2201      	movs	r2, #1
1a000b98:	4b20      	ldr	r3, [pc, #128]	; (1a000c1c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000b9a:	701a      	strb	r2, [r3, #0]
1a000b9c:	bd08      	pop	{r3, pc}
			if( ingresarDigito() ) {
1a000b9e:	f7ff ff51 	bl	1a000a44 <ingresarDigito>
1a000ba2:	2800      	cmp	r0, #0
1a000ba4:	d0f2      	beq.n	1a000b8c <ActualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_LETRA;
1a000ba6:	2202      	movs	r2, #2
1a000ba8:	4b1c      	ldr	r3, [pc, #112]	; (1a000c1c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000baa:	701a      	strb	r2, [r3, #0]
				if (pinesTeclado[segundoDigito] == 'A') {
1a000bac:	4b1c      	ldr	r3, [pc, #112]	; (1a000c20 <ActualizarMEF_tecladoMatricial+0xac>)
1a000bae:	881a      	ldrh	r2, [r3, #0]
1a000bb0:	4b1c      	ldr	r3, [pc, #112]	; (1a000c24 <ActualizarMEF_tecladoMatricial+0xb0>)
1a000bb2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000bb6:	2b41      	cmp	r3, #65	; 0x41
1a000bb8:	d00a      	beq.n	1a000bd0 <ActualizarMEF_tecladoMatricial+0x5c>
				else if (pinesTeclado[confirmar] == 'B') {
1a000bba:	4b1b      	ldr	r3, [pc, #108]	; (1a000c28 <ActualizarMEF_tecladoMatricial+0xb4>)
1a000bbc:	881a      	ldrh	r2, [r3, #0]
1a000bbe:	4b19      	ldr	r3, [pc, #100]	; (1a000c24 <ActualizarMEF_tecladoMatricial+0xb0>)
1a000bc0:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000bc4:	2b42      	cmp	r3, #66	; 0x42
1a000bc6:	d1e1      	bne.n	1a000b8c <ActualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000bc8:	2200      	movs	r2, #0
1a000bca:	4b14      	ldr	r3, [pc, #80]	; (1a000c1c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000bcc:	701a      	strb	r2, [r3, #0]
1a000bce:	bd08      	pop	{r3, pc}
					guardarPisoSimple (primerDigito);
1a000bd0:	4b16      	ldr	r3, [pc, #88]	; (1a000c2c <ActualizarMEF_tecladoMatricial+0xb8>)
1a000bd2:	8818      	ldrh	r0, [r3, #0]
1a000bd4:	f7ff ff78 	bl	1a000ac8 <guardarPisoSimple>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000bd8:	2200      	movs	r2, #0
1a000bda:	4b10      	ldr	r3, [pc, #64]	; (1a000c1c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000bdc:	701a      	strb	r2, [r3, #0]
1a000bde:	bd08      	pop	{r3, pc}
			if ( ingresarDigito() ) {
1a000be0:	f7ff ff30 	bl	1a000a44 <ingresarDigito>
1a000be4:	2800      	cmp	r0, #0
1a000be6:	d0d1      	beq.n	1a000b8c <ActualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_LETRA;
1a000be8:	2202      	movs	r2, #2
1a000bea:	4b0c      	ldr	r3, [pc, #48]	; (1a000c1c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000bec:	701a      	strb	r2, [r3, #0]
				if (pinesTeclado[confirmar] == 'A' ) {
1a000bee:	4b0e      	ldr	r3, [pc, #56]	; (1a000c28 <ActualizarMEF_tecladoMatricial+0xb4>)
1a000bf0:	881a      	ldrh	r2, [r3, #0]
1a000bf2:	4b0c      	ldr	r3, [pc, #48]	; (1a000c24 <ActualizarMEF_tecladoMatricial+0xb0>)
1a000bf4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000bf8:	2b41      	cmp	r3, #65	; 0x41
1a000bfa:	d005      	beq.n	1a000c08 <ActualizarMEF_tecladoMatricial+0x94>
				else if (pinesTeclado[confirmar] == 'B') {
1a000bfc:	2b42      	cmp	r3, #66	; 0x42
1a000bfe:	d1c5      	bne.n	1a000b8c <ActualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000c00:	2200      	movs	r2, #0
1a000c02:	4b06      	ldr	r3, [pc, #24]	; (1a000c1c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000c04:	701a      	strb	r2, [r3, #0]
1a000c06:	bd08      	pop	{r3, pc}
					estadoMefTecladoMatricial = GUARDAR_PISO;
1a000c08:	2203      	movs	r2, #3
1a000c0a:	4b04      	ldr	r3, [pc, #16]	; (1a000c1c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000c0c:	701a      	strb	r2, [r3, #0]
					guardarPisoDoble (primerDigito, segundoDigito);
1a000c0e:	4b04      	ldr	r3, [pc, #16]	; (1a000c20 <ActualizarMEF_tecladoMatricial+0xac>)
1a000c10:	8819      	ldrh	r1, [r3, #0]
1a000c12:	4b06      	ldr	r3, [pc, #24]	; (1a000c2c <ActualizarMEF_tecladoMatricial+0xb8>)
1a000c14:	8818      	ldrh	r0, [r3, #0]
1a000c16:	f7ff ff79 	bl	1a000b0c <guardarPisoDoble>
1a000c1a:	bd08      	pop	{r3, pc}
1a000c1c:	100000e9 	.word	0x100000e9
1a000c20:	100000f8 	.word	0x100000f8
1a000c24:	1a0024f4 	.word	0x1a0024f4
1a000c28:	100000c8 	.word	0x100000c8
1a000c2c:	100000f6 	.word	0x100000f6

1a000c30 <itoa>:

 */
char* itoa(int value, char* result, int base)
{
   // check that the base if valid
   if (base < 2 || base > 36) { *result = '\0'; return result; }
1a000c30:	1e93      	subs	r3, r2, #2
1a000c32:	2b22      	cmp	r3, #34	; 0x22
1a000c34:	d802      	bhi.n	1a000c3c <itoa+0xc>
{
1a000c36:	b4f0      	push	{r4, r5, r6, r7}
1a000c38:	460d      	mov	r5, r1
1a000c3a:	e005      	b.n	1a000c48 <itoa+0x18>
   if (base < 2 || base > 36) { *result = '\0'; return result; }
1a000c3c:	2300      	movs	r3, #0
1a000c3e:	700b      	strb	r3, [r1, #0]
      tmp_char = *ptr;
      *ptr--= *ptr1;
      *ptr1++ = tmp_char;
   }
   return result;
}
1a000c40:	4608      	mov	r0, r1
1a000c42:	4770      	bx	lr
      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
1a000c44:	4635      	mov	r5, r6
      value /= base;
1a000c46:	4620      	mov	r0, r4
1a000c48:	fb90 f4f2 	sdiv	r4, r0, r2
      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
1a000c4c:	1c6e      	adds	r6, r5, #1
1a000c4e:	fb02 0314 	mls	r3, r2, r4, r0
1a000c52:	3323      	adds	r3, #35	; 0x23
1a000c54:	4f0f      	ldr	r7, [pc, #60]	; (1a000c94 <itoa+0x64>)
1a000c56:	5cfb      	ldrb	r3, [r7, r3]
1a000c58:	702b      	strb	r3, [r5, #0]
   } while ( value );
1a000c5a:	2c00      	cmp	r4, #0
1a000c5c:	d1f2      	bne.n	1a000c44 <itoa+0x14>
   if (tmp_value < 0) *ptr++ = '-';
1a000c5e:	2800      	cmp	r0, #0
1a000c60:	db04      	blt.n	1a000c6c <itoa+0x3c>
   *ptr-- = '\0';
1a000c62:	1e72      	subs	r2, r6, #1
1a000c64:	2300      	movs	r3, #0
1a000c66:	7033      	strb	r3, [r6, #0]
   char* ptr = result, *ptr1 = result, tmp_char;
1a000c68:	460b      	mov	r3, r1
   while(ptr1 < ptr) {
1a000c6a:	e00d      	b.n	1a000c88 <itoa+0x58>
   if (tmp_value < 0) *ptr++ = '-';
1a000c6c:	232d      	movs	r3, #45	; 0x2d
1a000c6e:	7033      	strb	r3, [r6, #0]
1a000c70:	1cae      	adds	r6, r5, #2
1a000c72:	e7f6      	b.n	1a000c62 <itoa+0x32>
      tmp_char = *ptr;
1a000c74:	4614      	mov	r4, r2
1a000c76:	f814 0901 	ldrb.w	r0, [r4], #-1
      *ptr--= *ptr1;
1a000c7a:	461d      	mov	r5, r3
1a000c7c:	f815 6b01 	ldrb.w	r6, [r5], #1
1a000c80:	7016      	strb	r6, [r2, #0]
      *ptr1++ = tmp_char;
1a000c82:	7018      	strb	r0, [r3, #0]
1a000c84:	462b      	mov	r3, r5
      *ptr--= *ptr1;
1a000c86:	4622      	mov	r2, r4
   while(ptr1 < ptr) {
1a000c88:	429a      	cmp	r2, r3
1a000c8a:	d8f3      	bhi.n	1a000c74 <itoa+0x44>
}
1a000c8c:	4608      	mov	r0, r1
1a000c8e:	bcf0      	pop	{r4, r5, r6, r7}
1a000c90:	4770      	bx	lr
1a000c92:	bf00      	nop
1a000c94:	1a0026ec 	.word	0x1a0026ec

1a000c98 <uartWriteMiDato>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void uartWriteMiDato(char* str, int value, int base)
{
1a000c98:	b570      	push	{r4, r5, r6, lr}
1a000c9a:	460d      	mov	r5, r1
1a000c9c:	4616      	mov	r6, r2

uartWriteString(UART_USB, str);
1a000c9e:	4601      	mov	r1, r0
1a000ca0:	2000      	movs	r0, #0
1a000ca2:	f001 fa85 	bl	1a0021b0 <uartWriteString>
itoa( value, numeroEnString, base);         
1a000ca6:	4c07      	ldr	r4, [pc, #28]	; (1a000cc4 <uartWriteMiDato+0x2c>)
1a000ca8:	4632      	mov	r2, r6
1a000caa:	4621      	mov	r1, r4
1a000cac:	4628      	mov	r0, r5
1a000cae:	f7ff ffbf 	bl	1a000c30 <itoa>
uartWriteString( UART_USB, numeroEnString );  
1a000cb2:	4621      	mov	r1, r4
1a000cb4:	2000      	movs	r0, #0
1a000cb6:	f001 fa7b 	bl	1a0021b0 <uartWriteString>
uartWriteString( UART_USB, "\r\n" );  
1a000cba:	4903      	ldr	r1, [pc, #12]	; (1a000cc8 <uartWriteMiDato+0x30>)
1a000cbc:	2000      	movs	r0, #0
1a000cbe:	f001 fa77 	bl	1a0021b0 <uartWriteString>
1a000cc2:	bd70      	pop	{r4, r5, r6, pc}
1a000cc4:	1000014c 	.word	0x1000014c
1a000cc8:	1a0026b0 	.word	0x1a0026b0

1a000ccc <EnviaEstadoInterno>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void EnviaEstadoInterno(void)
{
1a000ccc:	b510      	push	{r4, lr}
// Esta linea permite el borrado de la terminal en la PC usando RealTerm.
uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
1a000cce:	4952      	ldr	r1, [pc, #328]	; (1a000e18 <EnviaEstadoInterno+0x14c>)
1a000cd0:	2000      	movs	r0, #0
1a000cd2:	f001 fa6d 	bl	1a0021b0 <uartWriteString>


uartWriteMiDato("Buf[0]= ", almacenarPisos[0], 10);
1a000cd6:	4c51      	ldr	r4, [pc, #324]	; (1a000e1c <EnviaEstadoInterno+0x150>)
1a000cd8:	220a      	movs	r2, #10
1a000cda:	6821      	ldr	r1, [r4, #0]
1a000cdc:	4850      	ldr	r0, [pc, #320]	; (1a000e20 <EnviaEstadoInterno+0x154>)
1a000cde:	f7ff ffdb 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[1]= ", almacenarPisos[1], 10);
1a000ce2:	220a      	movs	r2, #10
1a000ce4:	6861      	ldr	r1, [r4, #4]
1a000ce6:	484f      	ldr	r0, [pc, #316]	; (1a000e24 <EnviaEstadoInterno+0x158>)
1a000ce8:	f7ff ffd6 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[2]= ", almacenarPisos[2], 10);
1a000cec:	220a      	movs	r2, #10
1a000cee:	68a1      	ldr	r1, [r4, #8]
1a000cf0:	484d      	ldr	r0, [pc, #308]	; (1a000e28 <EnviaEstadoInterno+0x15c>)
1a000cf2:	f7ff ffd1 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[3]= ", almacenarPisos[3], 10);
1a000cf6:	220a      	movs	r2, #10
1a000cf8:	68e1      	ldr	r1, [r4, #12]
1a000cfa:	484c      	ldr	r0, [pc, #304]	; (1a000e2c <EnviaEstadoInterno+0x160>)
1a000cfc:	f7ff ffcc 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[4]= ", almacenarPisos[4], 10);
1a000d00:	220a      	movs	r2, #10
1a000d02:	6921      	ldr	r1, [r4, #16]
1a000d04:	484a      	ldr	r0, [pc, #296]	; (1a000e30 <EnviaEstadoInterno+0x164>)
1a000d06:	f7ff ffc7 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[5]= ", almacenarPisos[5], 10);
1a000d0a:	220a      	movs	r2, #10
1a000d0c:	6961      	ldr	r1, [r4, #20]
1a000d0e:	4849      	ldr	r0, [pc, #292]	; (1a000e34 <EnviaEstadoInterno+0x168>)
1a000d10:	f7ff ffc2 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[6]= ", almacenarPisos[6], 10);
1a000d14:	220a      	movs	r2, #10
1a000d16:	69a1      	ldr	r1, [r4, #24]
1a000d18:	4847      	ldr	r0, [pc, #284]	; (1a000e38 <EnviaEstadoInterno+0x16c>)
1a000d1a:	f7ff ffbd 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[7]= ", almacenarPisos[7], 10);
1a000d1e:	220a      	movs	r2, #10
1a000d20:	69e1      	ldr	r1, [r4, #28]
1a000d22:	4846      	ldr	r0, [pc, #280]	; (1a000e3c <EnviaEstadoInterno+0x170>)
1a000d24:	f7ff ffb8 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[8]= ", almacenarPisos[8], 10);
1a000d28:	220a      	movs	r2, #10
1a000d2a:	6a21      	ldr	r1, [r4, #32]
1a000d2c:	4844      	ldr	r0, [pc, #272]	; (1a000e40 <EnviaEstadoInterno+0x174>)
1a000d2e:	f7ff ffb3 	bl	1a000c98 <uartWriteMiDato>
uartWriteMiDato("Buf[9]= ", almacenarPisos[9], 10);
1a000d32:	220a      	movs	r2, #10
1a000d34:	6a61      	ldr	r1, [r4, #36]	; 0x24
1a000d36:	4843      	ldr	r0, [pc, #268]	; (1a000e44 <EnviaEstadoInterno+0x178>)
1a000d38:	f7ff ffae 	bl	1a000c98 <uartWriteMiDato>

// uartWriteMiDato("Indice = ", indice, 10);


//uartWriteString(UART_USB, "estadoActualAsc = ");
uartWriteString(UART_USB, "Estado del Ascensor: ");
1a000d3c:	4942      	ldr	r1, [pc, #264]	; (1a000e48 <EnviaEstadoInterno+0x17c>)
1a000d3e:	2000      	movs	r0, #0
1a000d40:	f001 fa36 	bl	1a0021b0 <uartWriteString>
switch(estadoActualAsc)
1a000d44:	4b41      	ldr	r3, [pc, #260]	; (1a000e4c <EnviaEstadoInterno+0x180>)
1a000d46:	781b      	ldrb	r3, [r3, #0]
1a000d48:	2b05      	cmp	r3, #5
1a000d4a:	d808      	bhi.n	1a000d5e <EnviaEstadoInterno+0x92>
1a000d4c:	e8df f003 	tbb	[pc, r3]
1a000d50:	1a151003 	.word	0x1a151003
1a000d54:	241f      	.short	0x241f
	{
	case EN_PLANTA_BAJA:
		uartWriteString(UART_USB, "En Planta Baja y ");
1a000d56:	493e      	ldr	r1, [pc, #248]	; (1a000e50 <EnviaEstadoInterno+0x184>)
1a000d58:	2000      	movs	r0, #0
1a000d5a:	f001 fa29 	bl	1a0021b0 <uartWriteString>
		break;
 	}      	
	
	
// uartWriteString(UART_USB, "estadoActualPuerta = ");	
switch(estadoActualPuerta)
1a000d5e:	4b3d      	ldr	r3, [pc, #244]	; (1a000e54 <EnviaEstadoInterno+0x188>)
1a000d60:	781b      	ldrb	r3, [r3, #0]
1a000d62:	2b05      	cmp	r3, #5
1a000d64:	d821      	bhi.n	1a000daa <EnviaEstadoInterno+0xde>
1a000d66:	e8df f003 	tbb	[pc, r3]
1a000d6a:	381c      	.short	0x381c
1a000d6c:	4c47423d 	.word	0x4c47423d
		uartWriteString(UART_USB, "Subiendo y ");
1a000d70:	4939      	ldr	r1, [pc, #228]	; (1a000e58 <EnviaEstadoInterno+0x18c>)
1a000d72:	2000      	movs	r0, #0
1a000d74:	f001 fa1c 	bl	1a0021b0 <uartWriteString>
		break;
1a000d78:	e7f1      	b.n	1a000d5e <EnviaEstadoInterno+0x92>
		uartWriteString(UART_USB, "Bajando y ");	
1a000d7a:	4938      	ldr	r1, [pc, #224]	; (1a000e5c <EnviaEstadoInterno+0x190>)
1a000d7c:	2000      	movs	r0, #0
1a000d7e:	f001 fa17 	bl	1a0021b0 <uartWriteString>
		break;
1a000d82:	e7ec      	b.n	1a000d5e <EnviaEstadoInterno+0x92>
		uartWriteString(UART_USB, "Parado y ");	
1a000d84:	4936      	ldr	r1, [pc, #216]	; (1a000e60 <EnviaEstadoInterno+0x194>)
1a000d86:	2000      	movs	r0, #0
1a000d88:	f001 fa12 	bl	1a0021b0 <uartWriteString>
		break;
1a000d8c:	e7e7      	b.n	1a000d5e <EnviaEstadoInterno+0x92>
		uartWriteString(UART_USB, "Yendo a Planta Baja y ");
1a000d8e:	4935      	ldr	r1, [pc, #212]	; (1a000e64 <EnviaEstadoInterno+0x198>)
1a000d90:	2000      	movs	r0, #0
1a000d92:	f001 fa0d 	bl	1a0021b0 <uartWriteString>
		break;
1a000d96:	e7e2      	b.n	1a000d5e <EnviaEstadoInterno+0x92>
		uartWriteString(UART_USB, "Modo Configuracion y ");
1a000d98:	4933      	ldr	r1, [pc, #204]	; (1a000e68 <EnviaEstadoInterno+0x19c>)
1a000d9a:	2000      	movs	r0, #0
1a000d9c:	f001 fa08 	bl	1a0021b0 <uartWriteString>
		break;
1a000da0:	e7dd      	b.n	1a000d5e <EnviaEstadoInterno+0x92>
	{
	case PUERTA_CERRADA:
		uartWriteString(UART_USB, "Puertas Cerradas\r\n");
1a000da2:	4932      	ldr	r1, [pc, #200]	; (1a000e6c <EnviaEstadoInterno+0x1a0>)
1a000da4:	2000      	movs	r0, #0
1a000da6:	f001 fa03 	bl	1a0021b0 <uartWriteString>
	default:

		break;
 	}      

if (Ask_PideNuevoPisoFlag)
1a000daa:	4b31      	ldr	r3, [pc, #196]	; (1a000e70 <EnviaEstadoInterno+0x1a4>)
1a000dac:	681b      	ldr	r3, [r3, #0]
1a000dae:	f013 0f10 	tst.w	r3, #16
1a000db2:	d12b      	bne.n	1a000e0c <EnviaEstadoInterno+0x140>
	uartWriteString(UART_USB, "Pide nuevo piso = SI\r\n");
else	uartWriteString(UART_USB, "Pide nuevo piso = NO\r\n");
1a000db4:	492f      	ldr	r1, [pc, #188]	; (1a000e74 <EnviaEstadoInterno+0x1a8>)
1a000db6:	2000      	movs	r0, #0
1a000db8:	f001 f9fa 	bl	1a0021b0 <uartWriteString>

uartWriteMiDato ("Piso Destino = ", pisoDestino, 10);
1a000dbc:	220a      	movs	r2, #10
1a000dbe:	4b2e      	ldr	r3, [pc, #184]	; (1a000e78 <EnviaEstadoInterno+0x1ac>)
1a000dc0:	f993 1000 	ldrsb.w	r1, [r3]
1a000dc4:	482d      	ldr	r0, [pc, #180]	; (1a000e7c <EnviaEstadoInterno+0x1b0>)
1a000dc6:	f7ff ff67 	bl	1a000c98 <uartWriteMiDato>

uartWriteMiDato ("Piso Actual = ", pisoActual, 10);
1a000dca:	220a      	movs	r2, #10
1a000dcc:	4b2c      	ldr	r3, [pc, #176]	; (1a000e80 <EnviaEstadoInterno+0x1b4>)
1a000dce:	f993 1000 	ldrsb.w	r1, [r3]
1a000dd2:	482c      	ldr	r0, [pc, #176]	; (1a000e84 <EnviaEstadoInterno+0x1b8>)
1a000dd4:	f7ff ff60 	bl	1a000c98 <uartWriteMiDato>
1a000dd8:	bd10      	pop	{r4, pc}
		uartWriteString(UART_USB, "Abriendo Puertas\r\n");
1a000dda:	492b      	ldr	r1, [pc, #172]	; (1a000e88 <EnviaEstadoInterno+0x1bc>)
1a000ddc:	2000      	movs	r0, #0
1a000dde:	f001 f9e7 	bl	1a0021b0 <uartWriteString>
		break;
1a000de2:	e7e2      	b.n	1a000daa <EnviaEstadoInterno+0xde>
		uartWriteString(UART_USB, "Puertas Abiertas\r\n");
1a000de4:	4929      	ldr	r1, [pc, #164]	; (1a000e8c <EnviaEstadoInterno+0x1c0>)
1a000de6:	2000      	movs	r0, #0
1a000de8:	f001 f9e2 	bl	1a0021b0 <uartWriteString>
		break;
1a000dec:	e7dd      	b.n	1a000daa <EnviaEstadoInterno+0xde>
		uartWriteString(UART_USB, "Intentado Cerrar Puertas\r\n");
1a000dee:	4928      	ldr	r1, [pc, #160]	; (1a000e90 <EnviaEstadoInterno+0x1c4>)
1a000df0:	2000      	movs	r0, #0
1a000df2:	f001 f9dd 	bl	1a0021b0 <uartWriteString>
		break;
1a000df6:	e7d8      	b.n	1a000daa <EnviaEstadoInterno+0xde>
		uartWriteString(UART_USB, "Cerrando Puertas\r\n");
1a000df8:	4926      	ldr	r1, [pc, #152]	; (1a000e94 <EnviaEstadoInterno+0x1c8>)
1a000dfa:	2000      	movs	r0, #0
1a000dfc:	f001 f9d8 	bl	1a0021b0 <uartWriteString>
		break;
1a000e00:	e7d3      	b.n	1a000daa <EnviaEstadoInterno+0xde>
		uartWriteString(UART_USB, "Alarma Puertas Abiertas\r\n");
1a000e02:	4925      	ldr	r1, [pc, #148]	; (1a000e98 <EnviaEstadoInterno+0x1cc>)
1a000e04:	2000      	movs	r0, #0
1a000e06:	f001 f9d3 	bl	1a0021b0 <uartWriteString>
		break;
1a000e0a:	e7ce      	b.n	1a000daa <EnviaEstadoInterno+0xde>
	uartWriteString(UART_USB, "Pide nuevo piso = SI\r\n");
1a000e0c:	4923      	ldr	r1, [pc, #140]	; (1a000e9c <EnviaEstadoInterno+0x1d0>)
1a000e0e:	2000      	movs	r0, #0
1a000e10:	f001 f9ce 	bl	1a0021b0 <uartWriteString>
1a000e14:	e7d2      	b.n	1a000dbc <EnviaEstadoInterno+0xf0>
1a000e16:	bf00      	nop
1a000e18:	1a002514 	.word	0x1a002514
1a000e1c:	10000124 	.word	0x10000124
1a000e20:	1a00251c 	.word	0x1a00251c
1a000e24:	1a002528 	.word	0x1a002528
1a000e28:	1a002534 	.word	0x1a002534
1a000e2c:	1a002540 	.word	0x1a002540
1a000e30:	1a00254c 	.word	0x1a00254c
1a000e34:	1a002558 	.word	0x1a002558
1a000e38:	1a002564 	.word	0x1a002564
1a000e3c:	1a002570 	.word	0x1a002570
1a000e40:	1a00257c 	.word	0x1a00257c
1a000e44:	1a002588 	.word	0x1a002588
1a000e48:	1a002594 	.word	0x1a002594
1a000e4c:	10000120 	.word	0x10000120
1a000e50:	1a0025ac 	.word	0x1a0025ac
1a000e54:	10000121 	.word	0x10000121
1a000e58:	1a0025c0 	.word	0x1a0025c0
1a000e5c:	1a0025cc 	.word	0x1a0025cc
1a000e60:	1a0025d8 	.word	0x1a0025d8
1a000e64:	1a0025e4 	.word	0x1a0025e4
1a000e68:	1a0025fc 	.word	0x1a0025fc
1a000e6c:	1a002614 	.word	0x1a002614
1a000e70:	10000048 	.word	0x10000048
1a000e74:	1a0026b4 	.word	0x1a0026b4
1a000e78:	1000004e 	.word	0x1000004e
1a000e7c:	1a0026cc 	.word	0x1a0026cc
1a000e80:	1000004d 	.word	0x1000004d
1a000e84:	1a0026dc 	.word	0x1a0026dc
1a000e88:	1a002628 	.word	0x1a002628
1a000e8c:	1a00263c 	.word	0x1a00263c
1a000e90:	1a002650 	.word	0x1a002650
1a000e94:	1a00266c 	.word	0x1a00266c
1a000e98:	1a002680 	.word	0x1a002680
1a000e9c:	1a00269c 	.word	0x1a00269c

1a000ea0 <ConfigDisplay>:

//*************************************************************************************************
//			Configura pines para los dgitos Anodo Comun!
//*************************************************************************************************
void ConfigDisplay(void)
{
1a000ea0:	b538      	push	{r3, r4, r5, lr}
uint8_t i = 0;

// Se setean los pines correspondientes a los segmentos como salida y en cero.
for (i=0; i<8; i++)
1a000ea2:	2400      	movs	r4, #0
1a000ea4:	e00b      	b.n	1a000ebe <ConfigDisplay+0x1e>
	{
	gpioConfig (segmentosdisplayB[i], GPIO_OUTPUT);
1a000ea6:	4b0f      	ldr	r3, [pc, #60]	; (1a000ee4 <ConfigDisplay+0x44>)
1a000ea8:	5d1d      	ldrb	r5, [r3, r4]
1a000eaa:	2101      	movs	r1, #1
1a000eac:	4628      	mov	r0, r5
1a000eae:	f000 ff41 	bl	1a001d34 <gpioConfig>
	#ifdef ANODO_COMUN
	gpioWrite (segmentosdisplayB[i], 1);
1a000eb2:	2101      	movs	r1, #1
1a000eb4:	4628      	mov	r0, r5
1a000eb6:	f000 fff7 	bl	1a001ea8 <gpioWrite>
for (i=0; i<8; i++)
1a000eba:	3401      	adds	r4, #1
1a000ebc:	b2e4      	uxtb	r4, r4
1a000ebe:	2c07      	cmp	r4, #7
1a000ec0:	d9f1      	bls.n	1a000ea6 <ConfigDisplay+0x6>
1a000ec2:	2400      	movs	r4, #0
1a000ec4:	e00b      	b.n	1a000ede <ConfigDisplay+0x3e>
	}

// Se setean los pines correspondientes al control de los anodos comn de los dgitos, en salida y cero.
for (i=0; i<4; i++)
	{
	gpioConfig (quedisplayB[i], GPIO_OUTPUT);
1a000ec6:	4b08      	ldr	r3, [pc, #32]	; (1a000ee8 <ConfigDisplay+0x48>)
1a000ec8:	5d1d      	ldrb	r5, [r3, r4]
1a000eca:	2101      	movs	r1, #1
1a000ecc:	4628      	mov	r0, r5
1a000ece:	f000 ff31 	bl	1a001d34 <gpioConfig>
	#ifdef ANODO_COMUN
		gpioWrite (quedisplayB[i], 1);
1a000ed2:	2101      	movs	r1, #1
1a000ed4:	4628      	mov	r0, r5
1a000ed6:	f000 ffe7 	bl	1a001ea8 <gpioWrite>
for (i=0; i<4; i++)
1a000eda:	3401      	adds	r4, #1
1a000edc:	b2e4      	uxtb	r4, r4
1a000ede:	2c03      	cmp	r4, #3
1a000ee0:	d9f1      	bls.n	1a000ec6 <ConfigDisplay+0x26>
	#elif defined(CATODO_COMUN)
		gpioWrite (quedisplayB[i], 0);
	#endif   		
	}
}
1a000ee2:	bd38      	pop	{r3, r4, r5, pc}
1a000ee4:	1a002754 	.word	0x1a002754
1a000ee8:	1a002750 	.word	0x1a002750

1a000eec <SacaDigito>:

//*********************************************************************************************************************
//			Actualiza un dgito Anodo Comun!
//*********************************************************************************************************************
void SacaDigito(uint8_t numero, uint8_t lcdx)
{
1a000eec:	b538      	push	{r3, r4, r5, lr}
1a000eee:	4605      	mov	r5, r0
1a000ef0:	460c      	mov	r4, r1
uint8_t i = 0;

gpioWrite (LCD1, 1);
1a000ef2:	2101      	movs	r1, #1
1a000ef4:	2010      	movs	r0, #16
1a000ef6:	f000 ffd7 	bl	1a001ea8 <gpioWrite>
gpioWrite (LCD2, 1);
1a000efa:	2101      	movs	r1, #1
1a000efc:	2011      	movs	r0, #17
1a000efe:	f000 ffd3 	bl	1a001ea8 <gpioWrite>
gpioWrite (LCD3, 1);
1a000f02:	2101      	movs	r1, #1
1a000f04:	2012      	movs	r0, #18
1a000f06:	f000 ffcf 	bl	1a001ea8 <gpioWrite>
gpioWrite (LCD4, 1);
1a000f0a:	2101      	movs	r1, #1
1a000f0c:	2014      	movs	r0, #20
1a000f0e:	f000 ffcb 	bl	1a001ea8 <gpioWrite>
gpioWrite (lcdx, 0);
1a000f12:	2100      	movs	r1, #0
1a000f14:	4620      	mov	r0, r4
1a000f16:	f000 ffc7 	bl	1a001ea8 <gpioWrite>

for (i=0; i<=7; i++)
1a000f1a:	2400      	movs	r4, #0
1a000f1c:	e00d      	b.n	1a000f3a <SacaDigito+0x4e>
	#ifdef ANODO_COMUN
		gpioWrite (segmentosdisplayB[i], !(numeroadisplayB[numero] & (1 << i)));
1a000f1e:	4b08      	ldr	r3, [pc, #32]	; (1a000f40 <SacaDigito+0x54>)
1a000f20:	5d5b      	ldrb	r3, [r3, r5]
1a000f22:	4123      	asrs	r3, r4
1a000f24:	f013 0f01 	tst.w	r3, #1
1a000f28:	bf0c      	ite	eq
1a000f2a:	2101      	moveq	r1, #1
1a000f2c:	2100      	movne	r1, #0
1a000f2e:	4b05      	ldr	r3, [pc, #20]	; (1a000f44 <SacaDigito+0x58>)
1a000f30:	5d18      	ldrb	r0, [r3, r4]
1a000f32:	f000 ffb9 	bl	1a001ea8 <gpioWrite>
for (i=0; i<=7; i++)
1a000f36:	3401      	adds	r4, #1
1a000f38:	b2e4      	uxtb	r4, r4
1a000f3a:	2c07      	cmp	r4, #7
1a000f3c:	d9ef      	bls.n	1a000f1e <SacaDigito+0x32>
	#elif defined(CATODO_COMUN)
		gpioWrite (segmentosdisplayB[i], (numeroadisplayB[numero] & (1 << i)));
	#endif   	
}
1a000f3e:	bd38      	pop	{r3, r4, r5, pc}
1a000f40:	1a002734 	.word	0x1a002734
1a000f44:	1a002754 	.word	0x1a002754

1a000f48 <ConvierteByte>:
//*********************************************************************************************************************
//
//*********************************************************************************************************************
void ConvierteByte(uint8_t X, uint8_t *p)
{   
if (X)
1a000f48:	4603      	mov	r3, r0
1a000f4a:	b920      	cbnz	r0, 1a000f56 <ConvierteByte+0xe>
	p[1] = X/10;
	X = X%10;
	p[0] = X;
	}
else	{
	p[2] = 0;
1a000f4c:	2300      	movs	r3, #0
1a000f4e:	708b      	strb	r3, [r1, #2]
	p[1] = 0;
1a000f50:	704b      	strb	r3, [r1, #1]
	p[0] = 0;
1a000f52:	700b      	strb	r3, [r1, #0]
1a000f54:	4770      	bx	lr
	p[2] = X/100;
1a000f56:	480a      	ldr	r0, [pc, #40]	; (1a000f80 <ConvierteByte+0x38>)
1a000f58:	fba0 2003 	umull	r2, r0, r0, r3
1a000f5c:	0940      	lsrs	r0, r0, #5
1a000f5e:	7088      	strb	r0, [r1, #2]
	X = X%100;
1a000f60:	2264      	movs	r2, #100	; 0x64
1a000f62:	fb02 3010 	mls	r0, r2, r0, r3
1a000f66:	b2c0      	uxtb	r0, r0
	p[1] = X/10;
1a000f68:	4b06      	ldr	r3, [pc, #24]	; (1a000f84 <ConvierteByte+0x3c>)
1a000f6a:	fba3 2300 	umull	r2, r3, r3, r0
1a000f6e:	08db      	lsrs	r3, r3, #3
1a000f70:	704b      	strb	r3, [r1, #1]
	X = X%10;
1a000f72:	eb03 0383 	add.w	r3, r3, r3, lsl #2
1a000f76:	005a      	lsls	r2, r3, #1
1a000f78:	1a80      	subs	r0, r0, r2
	p[0] = X;
1a000f7a:	7008      	strb	r0, [r1, #0]
1a000f7c:	4770      	bx	lr
1a000f7e:	bf00      	nop
1a000f80:	51eb851f 	.word	0x51eb851f
1a000f84:	cccccccd 	.word	0xcccccccd

1a000f88 <ActualizarDisplay>:

//*********************************************************************************************************************
//			Funcion que se encarga de actualizar el display de 4 gigitos 7 segmentos
//*********************************************************************************************************************
void ActualizarDisplay(void)
{
1a000f88:	b500      	push	{lr}
1a000f8a:	b083      	sub	sp, #12

uint8_t valores[3];

// Esta en planta baja?
if (pisoActual == 0 && estadoActualAsc != SUBIENDO && estadoActualAsc != BAJANDO)
1a000f8c:	4b51      	ldr	r3, [pc, #324]	; (1a0010d4 <ActualizarDisplay+0x14c>)
1a000f8e:	f993 0000 	ldrsb.w	r0, [r3]
1a000f92:	b9c8      	cbnz	r0, 1a000fc8 <ActualizarDisplay+0x40>
1a000f94:	4b50      	ldr	r3, [pc, #320]	; (1a0010d8 <ActualizarDisplay+0x150>)
1a000f96:	781b      	ldrb	r3, [r3, #0]
1a000f98:	2b01      	cmp	r3, #1
1a000f9a:	d015      	beq.n	1a000fc8 <ActualizarDisplay+0x40>
1a000f9c:	2b02      	cmp	r3, #2
1a000f9e:	d013      	beq.n	1a000fc8 <ActualizarDisplay+0x40>
	{
	decenasB = LETRA_P;
1a000fa0:	2216      	movs	r2, #22
1a000fa2:	4b4e      	ldr	r3, [pc, #312]	; (1a0010dc <ActualizarDisplay+0x154>)
1a000fa4:	701a      	strb	r2, [r3, #0]
	unidadesB = LETRA_b;
1a000fa6:	220b      	movs	r2, #11
1a000fa8:	4b4d      	ldr	r3, [pc, #308]	; (1a0010e0 <ActualizarDisplay+0x158>)
1a000faa:	701a      	strb	r2, [r3, #0]
	centenasB = DIGITOAPAGADO;
1a000fac:	231a      	movs	r3, #26
1a000fae:	4a4d      	ldr	r2, [pc, #308]	; (1a0010e4 <ActualizarDisplay+0x15c>)
1a000fb0:	7013      	strb	r3, [r2, #0]
	unidadesmilB = DIGITOAPAGADO;
1a000fb2:	4a4d      	ldr	r2, [pc, #308]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a000fb4:	7013      	strb	r3, [r2, #0]
		unidadesmilB = LETRA_b;
}
	
	

switch (secuenciaB)
1a000fb6:	4b4d      	ldr	r3, [pc, #308]	; (1a0010ec <ActualizarDisplay+0x164>)
1a000fb8:	781b      	ldrb	r3, [r3, #0]
1a000fba:	2b03      	cmp	r3, #3
1a000fbc:	f200 8084 	bhi.w	1a0010c8 <ActualizarDisplay+0x140>
1a000fc0:	e8df f003 	tbb	[pc, r3]
1a000fc4:	7d73695f 	.word	0x7d73695f
	ConvierteByte(abs(pisoActual), valores);
1a000fc8:	2800      	cmp	r0, #0
1a000fca:	bfb8      	it	lt
1a000fcc:	4240      	neglt	r0, r0
1a000fce:	a901      	add	r1, sp, #4
1a000fd0:	b2c0      	uxtb	r0, r0
1a000fd2:	f7ff ffb9 	bl	1a000f48 <ConvierteByte>
	if (pisoActual == 0)
1a000fd6:	4b3f      	ldr	r3, [pc, #252]	; (1a0010d4 <ActualizarDisplay+0x14c>)
1a000fd8:	f993 3000 	ldrsb.w	r3, [r3]
1a000fdc:	b9c3      	cbnz	r3, 1a001010 <ActualizarDisplay+0x88>
		decenasB = LETRA_P;
1a000fde:	2216      	movs	r2, #22
1a000fe0:	4b3e      	ldr	r3, [pc, #248]	; (1a0010dc <ActualizarDisplay+0x154>)
1a000fe2:	701a      	strb	r2, [r3, #0]
		unidadesB = LETRA_b;
1a000fe4:	220b      	movs	r2, #11
1a000fe6:	4b3e      	ldr	r3, [pc, #248]	; (1a0010e0 <ActualizarDisplay+0x158>)
1a000fe8:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a000fea:	231a      	movs	r3, #26
1a000fec:	4a3d      	ldr	r2, [pc, #244]	; (1a0010e4 <ActualizarDisplay+0x15c>)
1a000fee:	7013      	strb	r3, [r2, #0]
		unidadesmilB = DIGITOAPAGADO;
1a000ff0:	4a3d      	ldr	r2, [pc, #244]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a000ff2:	7013      	strb	r3, [r2, #0]
	if (estadoActualAsc == YENDO_A_PLANTA_BAJA)
1a000ff4:	4b38      	ldr	r3, [pc, #224]	; (1a0010d8 <ActualizarDisplay+0x150>)
1a000ff6:	781b      	ldrb	r3, [r3, #0]
1a000ff8:	2b04      	cmp	r3, #4
1a000ffa:	d027      	beq.n	1a00104c <ActualizarDisplay+0xc4>
	else if (estadoActualAsc == PARADO)
1a000ffc:	2b03      	cmp	r3, #3
1a000ffe:	d038      	beq.n	1a001072 <ActualizarDisplay+0xea>
	else if (estadoActualAsc == SUBIENDO)
1a001000:	2b01      	cmp	r3, #1
1a001002:	d03a      	beq.n	1a00107a <ActualizarDisplay+0xf2>
	else if (estadoActualAsc == BAJANDO)
1a001004:	2b02      	cmp	r3, #2
1a001006:	d1d6      	bne.n	1a000fb6 <ActualizarDisplay+0x2e>
		unidadesmilB = LETRA_b;
1a001008:	220b      	movs	r2, #11
1a00100a:	4b37      	ldr	r3, [pc, #220]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a00100c:	701a      	strb	r2, [r3, #0]
1a00100e:	e7d2      	b.n	1a000fb6 <ActualizarDisplay+0x2e>
	else if (pisoActual > 0)
1a001010:	2b00      	cmp	r3, #0
1a001012:	dd10      	ble.n	1a001036 <ActualizarDisplay+0xae>
		if (!valores[1])
1a001014:	f89d 3005 	ldrb.w	r3, [sp, #5]
1a001018:	b953      	cbnz	r3, 1a001030 <ActualizarDisplay+0xa8>
			decenasB = DIGITOAPAGADO;
1a00101a:	221a      	movs	r2, #26
1a00101c:	4b2f      	ldr	r3, [pc, #188]	; (1a0010dc <ActualizarDisplay+0x154>)
1a00101e:	701a      	strb	r2, [r3, #0]
		unidadesB = valores[0];
1a001020:	f89d 2004 	ldrb.w	r2, [sp, #4]
1a001024:	4b2e      	ldr	r3, [pc, #184]	; (1a0010e0 <ActualizarDisplay+0x158>)
1a001026:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a001028:	221a      	movs	r2, #26
1a00102a:	4b2e      	ldr	r3, [pc, #184]	; (1a0010e4 <ActualizarDisplay+0x15c>)
1a00102c:	701a      	strb	r2, [r3, #0]
1a00102e:	e7e1      	b.n	1a000ff4 <ActualizarDisplay+0x6c>
		else	decenasB = valores[1];
1a001030:	4a2a      	ldr	r2, [pc, #168]	; (1a0010dc <ActualizarDisplay+0x154>)
1a001032:	7013      	strb	r3, [r2, #0]
1a001034:	e7f4      	b.n	1a001020 <ActualizarDisplay+0x98>
		decenasB = SIGNONEG;
1a001036:	2219      	movs	r2, #25
1a001038:	4b28      	ldr	r3, [pc, #160]	; (1a0010dc <ActualizarDisplay+0x154>)
1a00103a:	701a      	strb	r2, [r3, #0]
		unidadesB = valores[0];
1a00103c:	f89d 2004 	ldrb.w	r2, [sp, #4]
1a001040:	4b27      	ldr	r3, [pc, #156]	; (1a0010e0 <ActualizarDisplay+0x158>)
1a001042:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a001044:	221a      	movs	r2, #26
1a001046:	4b27      	ldr	r3, [pc, #156]	; (1a0010e4 <ActualizarDisplay+0x15c>)
1a001048:	701a      	strb	r2, [r3, #0]
1a00104a:	e7d3      	b.n	1a000ff4 <ActualizarDisplay+0x6c>
		if (pisoActual > 0)
1a00104c:	4b21      	ldr	r3, [pc, #132]	; (1a0010d4 <ActualizarDisplay+0x14c>)
1a00104e:	f993 3000 	ldrsb.w	r3, [r3]
1a001052:	2b00      	cmp	r3, #0
1a001054:	dd03      	ble.n	1a00105e <ActualizarDisplay+0xd6>
			unidadesmilB = LETRA_b;
1a001056:	220b      	movs	r2, #11
1a001058:	4b23      	ldr	r3, [pc, #140]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a00105a:	701a      	strb	r2, [r3, #0]
1a00105c:	e7ab      	b.n	1a000fb6 <ActualizarDisplay+0x2e>
		else if (pisoActual < 0) 
1a00105e:	2b00      	cmp	r3, #0
1a001060:	db03      	blt.n	1a00106a <ActualizarDisplay+0xe2>
		else	unidadesmilB = DIGITOAPAGADO;
1a001062:	221a      	movs	r2, #26
1a001064:	4b20      	ldr	r3, [pc, #128]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a001066:	701a      	strb	r2, [r3, #0]
1a001068:	e7a5      	b.n	1a000fb6 <ActualizarDisplay+0x2e>
			unidadesmilB = LETRA_S;
1a00106a:	2205      	movs	r2, #5
1a00106c:	4b1e      	ldr	r3, [pc, #120]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a00106e:	701a      	strb	r2, [r3, #0]
1a001070:	e7a1      	b.n	1a000fb6 <ActualizarDisplay+0x2e>
		unidadesmilB = DIGITOAPAGADO;
1a001072:	221a      	movs	r2, #26
1a001074:	4b1c      	ldr	r3, [pc, #112]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a001076:	701a      	strb	r2, [r3, #0]
1a001078:	e79d      	b.n	1a000fb6 <ActualizarDisplay+0x2e>
		unidadesmilB = LETRA_S;
1a00107a:	2205      	movs	r2, #5
1a00107c:	4b1a      	ldr	r3, [pc, #104]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a00107e:	701a      	strb	r2, [r3, #0]
1a001080:	e799      	b.n	1a000fb6 <ActualizarDisplay+0x2e>
	{
	case 0:
		SacaDigito (unidadesB, LCD1);
1a001082:	2110      	movs	r1, #16
1a001084:	4b16      	ldr	r3, [pc, #88]	; (1a0010e0 <ActualizarDisplay+0x158>)
1a001086:	7818      	ldrb	r0, [r3, #0]
1a001088:	f7ff ff30 	bl	1a000eec <SacaDigito>
		secuenciaB++;
1a00108c:	4a17      	ldr	r2, [pc, #92]	; (1a0010ec <ActualizarDisplay+0x164>)
1a00108e:	7813      	ldrb	r3, [r2, #0]
1a001090:	3301      	adds	r3, #1
1a001092:	7013      	strb	r3, [r2, #0]
		break;
1a001094:	e01b      	b.n	1a0010ce <ActualizarDisplay+0x146>
	case 1:
		SacaDigito (decenasB, LCD2);
1a001096:	2111      	movs	r1, #17
1a001098:	4b10      	ldr	r3, [pc, #64]	; (1a0010dc <ActualizarDisplay+0x154>)
1a00109a:	7818      	ldrb	r0, [r3, #0]
1a00109c:	f7ff ff26 	bl	1a000eec <SacaDigito>
		secuenciaB++;
1a0010a0:	4a12      	ldr	r2, [pc, #72]	; (1a0010ec <ActualizarDisplay+0x164>)
1a0010a2:	7813      	ldrb	r3, [r2, #0]
1a0010a4:	3301      	adds	r3, #1
1a0010a6:	7013      	strb	r3, [r2, #0]
		break;
1a0010a8:	e011      	b.n	1a0010ce <ActualizarDisplay+0x146>
	case 2:
		SacaDigito (centenasB, LCD3);
1a0010aa:	2112      	movs	r1, #18
1a0010ac:	4b0d      	ldr	r3, [pc, #52]	; (1a0010e4 <ActualizarDisplay+0x15c>)
1a0010ae:	7818      	ldrb	r0, [r3, #0]
1a0010b0:	f7ff ff1c 	bl	1a000eec <SacaDigito>
		secuenciaB++;
1a0010b4:	4a0d      	ldr	r2, [pc, #52]	; (1a0010ec <ActualizarDisplay+0x164>)
1a0010b6:	7813      	ldrb	r3, [r2, #0]
1a0010b8:	3301      	adds	r3, #1
1a0010ba:	7013      	strb	r3, [r2, #0]
		break;
1a0010bc:	e007      	b.n	1a0010ce <ActualizarDisplay+0x146>
	case 3:
		SacaDigito (unidadesmilB, LCD4);
1a0010be:	2114      	movs	r1, #20
1a0010c0:	4b09      	ldr	r3, [pc, #36]	; (1a0010e8 <ActualizarDisplay+0x160>)
1a0010c2:	7818      	ldrb	r0, [r3, #0]
1a0010c4:	f7ff ff12 	bl	1a000eec <SacaDigito>
	
	default:
		secuenciaB = 0;
1a0010c8:	2200      	movs	r2, #0
1a0010ca:	4b08      	ldr	r3, [pc, #32]	; (1a0010ec <ActualizarDisplay+0x164>)
1a0010cc:	701a      	strb	r2, [r3, #0]
		break;
	}
}
1a0010ce:	b003      	add	sp, #12
1a0010d0:	f85d fb04 	ldr.w	pc, [sp], #4
1a0010d4:	1000004d 	.word	0x1000004d
1a0010d8:	10000120 	.word	0x10000120
1a0010dc:	100000fb 	.word	0x100000fb
1a0010e0:	100000fd 	.word	0x100000fd
1a0010e4:	100000fa 	.word	0x100000fa
1a0010e8:	100000fe 	.word	0x100000fe
1a0010ec:	100000fc 	.word	0x100000fc

1a0010f0 <SystemCoreClockUpdate>:


/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
1a0010f0:	b508      	push	{r3, lr}
   /* CPU core speed */
   SystemCoreClock = Chip_Clock_GetRate(CLK_MX_MXCORE);
1a0010f2:	2069      	movs	r0, #105	; 0x69
1a0010f4:	f000 fa86 	bl	1a001604 <Chip_Clock_GetRate>
1a0010f8:	4b01      	ldr	r3, [pc, #4]	; (1a001100 <SystemCoreClockUpdate+0x10>)
1a0010fa:	6018      	str	r0, [r3, #0]
1a0010fc:	bd08      	pop	{r3, pc}
1a0010fe:	bf00      	nop
1a001100:	10000158 	.word	0x10000158

1a001104 <pll_calc_divs>:
       return -val;
   return val;
}

static void pll_calc_divs(uint32_t freq, PLL_PARAM_T *ppll)
{
1a001104:	b5f0      	push	{r4, r5, r6, r7, lr}

   uint32_t prev = freq;
   int n, m, p;

   /* When direct mode is set FBSEL should be a don't care */
   if (ppll->ctrl & (1 << 7)) {
1a001106:	680b      	ldr	r3, [r1, #0]
1a001108:	f013 0f80 	tst.w	r3, #128	; 0x80
1a00110c:	d002      	beq.n	1a001114 <pll_calc_divs+0x10>
       ppll->ctrl &= ~(1 << 6);
1a00110e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
1a001112:	600b      	str	r3, [r1, #0]
1a001114:	4607      	mov	r7, r0
1a001116:	2501      	movs	r5, #1
1a001118:	e03b      	b.n	1a001192 <pll_calc_divs+0x8e>
           for (m = 1; m <= 256; m++) {
               uint32_t fcco, fout;
               if (ppll->ctrl & (1 << 6)) {
                   fcco = ((m << (p + 1)) * ppll->fin) / n;
               } else {
                   fcco = (m * ppll->fin) / n;
1a00111a:	694b      	ldr	r3, [r1, #20]
1a00111c:	fb03 f302 	mul.w	r3, r3, r2
1a001120:	fbb3 f3f5 	udiv	r3, r3, r5
1a001124:	e014      	b.n	1a001150 <pll_calc_divs+0x4c>
               }
               if (fcco < PLL_MIN_CCO_FREQ) continue;
               if (fcco > PLL_MAX_CCO_FREQ) break;
               if (ppll->ctrl & (1 << 7)) {
                   fout = fcco;
1a001126:	461c      	mov	r4, r3
1a001128:	e020      	b.n	1a00116c <pll_calc_divs+0x68>
       return -val;
1a00112a:	f1ce 0e00 	rsb	lr, lr, #0
1a00112e:	e020      	b.n	1a001172 <pll_calc_divs+0x6e>
           for (m = 1; m <= 256; m++) {
1a001130:	3201      	adds	r2, #1
1a001132:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
1a001136:	dc26      	bgt.n	1a001186 <pll_calc_divs+0x82>
               if (ppll->ctrl & (1 << 6)) {
1a001138:	680c      	ldr	r4, [r1, #0]
1a00113a:	f014 0f40 	tst.w	r4, #64	; 0x40
1a00113e:	d0ec      	beq.n	1a00111a <pll_calc_divs+0x16>
                   fcco = ((m << (p + 1)) * ppll->fin) / n;
1a001140:	1c73      	adds	r3, r6, #1
1a001142:	fa02 fe03 	lsl.w	lr, r2, r3
1a001146:	694b      	ldr	r3, [r1, #20]
1a001148:	fb03 f30e 	mul.w	r3, r3, lr
1a00114c:	fbb3 f3f5 	udiv	r3, r3, r5
               if (fcco < PLL_MIN_CCO_FREQ) continue;
1a001150:	f8df e048 	ldr.w	lr, [pc, #72]	; 1a00119c <pll_calc_divs+0x98>
1a001154:	4573      	cmp	r3, lr
1a001156:	d9eb      	bls.n	1a001130 <pll_calc_divs+0x2c>
               if (fcco > PLL_MAX_CCO_FREQ) break;
1a001158:	f8df e044 	ldr.w	lr, [pc, #68]	; 1a0011a0 <pll_calc_divs+0x9c>
1a00115c:	4573      	cmp	r3, lr
1a00115e:	d812      	bhi.n	1a001186 <pll_calc_divs+0x82>
               if (ppll->ctrl & (1 << 7)) {
1a001160:	f014 0f80 	tst.w	r4, #128	; 0x80
1a001164:	d1df      	bne.n	1a001126 <pll_calc_divs+0x22>
               } else {
                   fout = fcco >> (p + 1);
1a001166:	1c74      	adds	r4, r6, #1
1a001168:	fa23 f404 	lsr.w	r4, r3, r4
   if (val < 0)
1a00116c:	ebb0 0e04 	subs.w	lr, r0, r4
1a001170:	d4db      	bmi.n	1a00112a <pll_calc_divs+0x26>
               }

               if (ABS(freq - fout) < prev) {
1a001172:	4577      	cmp	r7, lr
1a001174:	d9dc      	bls.n	1a001130 <pll_calc_divs+0x2c>
                   ppll->nsel = n;
1a001176:	608d      	str	r5, [r1, #8]
                   ppll->psel = p + 1;
1a001178:	1c77      	adds	r7, r6, #1
1a00117a:	60cf      	str	r7, [r1, #12]
                   ppll->msel = m;
1a00117c:	610a      	str	r2, [r1, #16]
                   ppll->fout = fout;
1a00117e:	618c      	str	r4, [r1, #24]
                   ppll->fcco = fcco;
1a001180:	61cb      	str	r3, [r1, #28]
                   prev = ABS(freq - fout);
1a001182:	4677      	mov	r7, lr
1a001184:	e7d4      	b.n	1a001130 <pll_calc_divs+0x2c>
       for (p = 0; p < 4; p ++) {
1a001186:	3601      	adds	r6, #1
1a001188:	2e03      	cmp	r6, #3
1a00118a:	dc01      	bgt.n	1a001190 <pll_calc_divs+0x8c>
1a00118c:	2201      	movs	r2, #1
1a00118e:	e7d0      	b.n	1a001132 <pll_calc_divs+0x2e>
   for (n = 1; n <= 4; n++) {
1a001190:	3501      	adds	r5, #1
1a001192:	2d04      	cmp	r5, #4
1a001194:	dc01      	bgt.n	1a00119a <pll_calc_divs+0x96>
1a001196:	2600      	movs	r6, #0
1a001198:	e7f6      	b.n	1a001188 <pll_calc_divs+0x84>
               }
           }
       }
   }
}
1a00119a:	bdf0      	pop	{r4, r5, r6, r7, pc}
1a00119c:	094c5eff 	.word	0x094c5eff
1a0011a0:	1312d000 	.word	0x1312d000

1a0011a4 <pll_get_frac>:

static void pll_get_frac(uint32_t freq, PLL_PARAM_T *ppll)
{
1a0011a4:	b5f0      	push	{r4, r5, r6, r7, lr}
1a0011a6:	b099      	sub	sp, #100	; 0x64
1a0011a8:	4605      	mov	r5, r0
1a0011aa:	460c      	mov	r4, r1
   int diff[3];
   PLL_PARAM_T pll[3] = {{0},{0},{0}};
1a0011ac:	2260      	movs	r2, #96	; 0x60
1a0011ae:	2100      	movs	r1, #0
1a0011b0:	4668      	mov	r0, sp
1a0011b2:	f001 f993 	bl	1a0024dc <memset>

   /* Try direct mode */
   pll[0].ctrl |= (1 << 7);
1a0011b6:	2380      	movs	r3, #128	; 0x80
1a0011b8:	9300      	str	r3, [sp, #0]
   pll[0].fin = ppll->fin;
1a0011ba:	6963      	ldr	r3, [r4, #20]
1a0011bc:	9305      	str	r3, [sp, #20]
   pll[0].srcin = ppll->srcin;
1a0011be:	7923      	ldrb	r3, [r4, #4]
1a0011c0:	f88d 3004 	strb.w	r3, [sp, #4]
   pll_calc_divs(freq, &pll[0]);
1a0011c4:	4669      	mov	r1, sp
1a0011c6:	4628      	mov	r0, r5
1a0011c8:	f7ff ff9c 	bl	1a001104 <pll_calc_divs>
   if (pll[0].fout == freq) {
1a0011cc:	9b06      	ldr	r3, [sp, #24]
1a0011ce:	429d      	cmp	r5, r3
1a0011d0:	d02f      	beq.n	1a001232 <pll_get_frac+0x8e>
   if (val < 0)
1a0011d2:	1aeb      	subs	r3, r5, r3
1a0011d4:	d436      	bmi.n	1a001244 <pll_get_frac+0xa0>
       *ppll = pll[0];
       return ;
   }
   diff[0] = ABS(freq - pll[0].fout);
1a0011d6:	461e      	mov	r6, r3

   /* Try non-Integer mode */
   pll[2].ctrl = (1 << 6);
1a0011d8:	2340      	movs	r3, #64	; 0x40
1a0011da:	9310      	str	r3, [sp, #64]	; 0x40
   pll[2].fin = ppll->fin;
1a0011dc:	6963      	ldr	r3, [r4, #20]
1a0011de:	9315      	str	r3, [sp, #84]	; 0x54
   pll[2].srcin = ppll->srcin;
1a0011e0:	7923      	ldrb	r3, [r4, #4]
1a0011e2:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
   pll_calc_divs(freq, &pll[2]);
1a0011e6:	a910      	add	r1, sp, #64	; 0x40
1a0011e8:	4628      	mov	r0, r5
1a0011ea:	f7ff ff8b 	bl	1a001104 <pll_calc_divs>
   if (pll[2].fout == freq) {
1a0011ee:	9b16      	ldr	r3, [sp, #88]	; 0x58
1a0011f0:	429d      	cmp	r5, r3
1a0011f2:	d029      	beq.n	1a001248 <pll_get_frac+0xa4>
   if (val < 0)
1a0011f4:	1aeb      	subs	r3, r5, r3
1a0011f6:	d42f      	bmi.n	1a001258 <pll_get_frac+0xb4>
       *ppll = pll[2];
       return ;
   }

   diff[2] = ABS(freq - pll[2].fout);
1a0011f8:	461f      	mov	r7, r3
   /* Try integer mode */
   pll[1].ctrl = (1 << 6);
1a0011fa:	2340      	movs	r3, #64	; 0x40
1a0011fc:	9308      	str	r3, [sp, #32]
   pll[1].fin = ppll->fin;
1a0011fe:	6963      	ldr	r3, [r4, #20]
1a001200:	930d      	str	r3, [sp, #52]	; 0x34
   pll[1].srcin = ppll->srcin;
1a001202:	7923      	ldrb	r3, [r4, #4]
1a001204:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   pll_calc_divs(freq, &pll[1]);
1a001208:	a908      	add	r1, sp, #32
1a00120a:	4628      	mov	r0, r5
1a00120c:	f7ff ff7a 	bl	1a001104 <pll_calc_divs>
   if (pll[1].fout == freq) {
1a001210:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1a001212:	429d      	cmp	r5, r3
1a001214:	d022      	beq.n	1a00125c <pll_get_frac+0xb8>
   if (val < 0)
1a001216:	1aed      	subs	r5, r5, r3
1a001218:	d428      	bmi.n	1a00126c <pll_get_frac+0xc8>
       return ;
   }
   diff[1] = ABS(freq - pll[1].fout);

   /* Find the min of 3 and return */
   if (diff[0] <= diff[1]) {
1a00121a:	42ae      	cmp	r6, r5
1a00121c:	dc30      	bgt.n	1a001280 <pll_get_frac+0xdc>
       if (diff[0] <= diff[2]) {
1a00121e:	42be      	cmp	r6, r7
1a001220:	dc26      	bgt.n	1a001270 <pll_get_frac+0xcc>
           *ppll = pll[0];
1a001222:	466d      	mov	r5, sp
1a001224:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001226:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a001228:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a00122c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a001230:	e006      	b.n	1a001240 <pll_get_frac+0x9c>
       *ppll = pll[0];
1a001232:	466d      	mov	r5, sp
1a001234:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001236:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a001238:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a00123c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
           *ppll = pll[1];
       } else {
           *ppll = pll[2];
       }
   }
}
1a001240:	b019      	add	sp, #100	; 0x64
1a001242:	bdf0      	pop	{r4, r5, r6, r7, pc}
       return -val;
1a001244:	425b      	negs	r3, r3
1a001246:	e7c6      	b.n	1a0011d6 <pll_get_frac+0x32>
       *ppll = pll[2];
1a001248:	ad10      	add	r5, sp, #64	; 0x40
1a00124a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a00124c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a00124e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a001252:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
       return ;
1a001256:	e7f3      	b.n	1a001240 <pll_get_frac+0x9c>
       return -val;
1a001258:	425b      	negs	r3, r3
1a00125a:	e7cd      	b.n	1a0011f8 <pll_get_frac+0x54>
       *ppll = pll[1];
1a00125c:	ad08      	add	r5, sp, #32
1a00125e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001260:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a001262:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a001266:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
       return ;
1a00126a:	e7e9      	b.n	1a001240 <pll_get_frac+0x9c>
       return -val;
1a00126c:	426d      	negs	r5, r5
1a00126e:	e7d4      	b.n	1a00121a <pll_get_frac+0x76>
           *ppll = pll[2];
1a001270:	ad10      	add	r5, sp, #64	; 0x40
1a001272:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001274:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a001276:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a00127a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a00127e:	e7df      	b.n	1a001240 <pll_get_frac+0x9c>
       if (diff[1] <= diff[2]) {
1a001280:	42af      	cmp	r7, r5
1a001282:	db07      	blt.n	1a001294 <pll_get_frac+0xf0>
           *ppll = pll[1];
1a001284:	ad08      	add	r5, sp, #32
1a001286:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001288:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a00128a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a00128e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a001292:	e7d5      	b.n	1a001240 <pll_get_frac+0x9c>
           *ppll = pll[2];
1a001294:	ad10      	add	r5, sp, #64	; 0x40
1a001296:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001298:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a00129a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a00129e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a0012a2:	e7cd      	b.n	1a001240 <pll_get_frac+0x9c>

1a0012a4 <Chip_Clock_FindBaseClock>:
   return Chip_Clock_GetClockInputHz(input) / (div + 1);
}

/* Finds the base clock for the peripheral clock */
static CHIP_CGU_BASE_CLK_T Chip_Clock_FindBaseClock(CHIP_CCU_CLK_T clk)
{
1a0012a4:	b430      	push	{r4, r5}
1a0012a6:	4605      	mov	r5, r0
   CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
   int i = 0;
1a0012a8:	2300      	movs	r3, #0
   CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
1a0012aa:	201c      	movs	r0, #28

   while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
1a0012ac:	e000      	b.n	1a0012b0 <Chip_Clock_FindBaseClock+0xc>
       if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
           baseclk = periph_to_base[i].clkbase;
       }
       else {
           i++;
1a0012ae:	3301      	adds	r3, #1
   while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
1a0012b0:	281c      	cmp	r0, #28
1a0012b2:	d118      	bne.n	1a0012e6 <Chip_Clock_FindBaseClock+0x42>
1a0012b4:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a0012b8:	0051      	lsls	r1, r2, #1
1a0012ba:	4a0c      	ldr	r2, [pc, #48]	; (1a0012ec <Chip_Clock_FindBaseClock+0x48>)
1a0012bc:	440a      	add	r2, r1
1a0012be:	7914      	ldrb	r4, [r2, #4]
1a0012c0:	42a0      	cmp	r0, r4
1a0012c2:	d010      	beq.n	1a0012e6 <Chip_Clock_FindBaseClock+0x42>
       if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
1a0012c4:	eb03 0143 	add.w	r1, r3, r3, lsl #1
1a0012c8:	004a      	lsls	r2, r1, #1
1a0012ca:	4908      	ldr	r1, [pc, #32]	; (1a0012ec <Chip_Clock_FindBaseClock+0x48>)
1a0012cc:	5a8a      	ldrh	r2, [r1, r2]
1a0012ce:	42aa      	cmp	r2, r5
1a0012d0:	d8ed      	bhi.n	1a0012ae <Chip_Clock_FindBaseClock+0xa>
1a0012d2:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a0012d6:	0051      	lsls	r1, r2, #1
1a0012d8:	4a04      	ldr	r2, [pc, #16]	; (1a0012ec <Chip_Clock_FindBaseClock+0x48>)
1a0012da:	440a      	add	r2, r1
1a0012dc:	8852      	ldrh	r2, [r2, #2]
1a0012de:	4295      	cmp	r5, r2
1a0012e0:	d8e5      	bhi.n	1a0012ae <Chip_Clock_FindBaseClock+0xa>
           baseclk = periph_to_base[i].clkbase;
1a0012e2:	4620      	mov	r0, r4
1a0012e4:	e7e4      	b.n	1a0012b0 <Chip_Clock_FindBaseClock+0xc>
       }
   }

   return baseclk;
}
1a0012e6:	bc30      	pop	{r4, r5}
1a0012e8:	4770      	bx	lr
1a0012ea:	bf00      	nop
1a0012ec:	1a002768 	.word	0x1a002768

1a0012f0 <Chip_Clock_EnableCrystal>:
 * Public functions
 ****************************************************************************/

/* Enables the crystal oscillator */
void Chip_Clock_EnableCrystal(void)
{
1a0012f0:	b082      	sub	sp, #8
   volatile uint32_t delay = 1000;
1a0012f2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
1a0012f6:	9301      	str	r3, [sp, #4]

   uint32_t OldCrystalConfig = LPC_CGU->XTAL_OSC_CTRL;
1a0012f8:	4a0d      	ldr	r2, [pc, #52]	; (1a001330 <Chip_Clock_EnableCrystal+0x40>)
1a0012fa:	6993      	ldr	r3, [r2, #24]

   /* Clear bypass mode */
   OldCrystalConfig &= (~2);
1a0012fc:	f023 0102 	bic.w	r1, r3, #2
   if (OldCrystalConfig != LPC_CGU->XTAL_OSC_CTRL) {
1a001300:	6992      	ldr	r2, [r2, #24]
1a001302:	4291      	cmp	r1, r2
1a001304:	d001      	beq.n	1a00130a <Chip_Clock_EnableCrystal+0x1a>
       LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
1a001306:	4a0a      	ldr	r2, [pc, #40]	; (1a001330 <Chip_Clock_EnableCrystal+0x40>)
1a001308:	6191      	str	r1, [r2, #24]
   }

   /* Enable crystal oscillator */
   OldCrystalConfig &= (~1);
1a00130a:	f023 0303 	bic.w	r3, r3, #3
   if (OscRateIn >= 20000000) {
1a00130e:	4a09      	ldr	r2, [pc, #36]	; (1a001334 <Chip_Clock_EnableCrystal+0x44>)
1a001310:	6811      	ldr	r1, [r2, #0]
1a001312:	4a09      	ldr	r2, [pc, #36]	; (1a001338 <Chip_Clock_EnableCrystal+0x48>)
1a001314:	4291      	cmp	r1, r2
1a001316:	d901      	bls.n	1a00131c <Chip_Clock_EnableCrystal+0x2c>
       OldCrystalConfig |= 4;  /* Set high frequency mode */
1a001318:	f043 0304 	orr.w	r3, r3, #4

   }
   LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
1a00131c:	4a04      	ldr	r2, [pc, #16]	; (1a001330 <Chip_Clock_EnableCrystal+0x40>)
1a00131e:	6193      	str	r3, [r2, #24]

   /* Delay for 250uSec */
   while(delay--) {}
1a001320:	9b01      	ldr	r3, [sp, #4]
1a001322:	1e5a      	subs	r2, r3, #1
1a001324:	9201      	str	r2, [sp, #4]
1a001326:	2b00      	cmp	r3, #0
1a001328:	d1fa      	bne.n	1a001320 <Chip_Clock_EnableCrystal+0x30>
}
1a00132a:	b002      	add	sp, #8
1a00132c:	4770      	bx	lr
1a00132e:	bf00      	nop
1a001330:	40050000 	.word	0x40050000
1a001334:	1a002830 	.word	0x1a002830
1a001338:	01312cff 	.word	0x01312cff

1a00133c <Chip_Clock_GetDividerSource>:
}

/* Gets a CGU clock divider source */
CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider)
{
   uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];
1a00133c:	3012      	adds	r0, #18
1a00133e:	4b05      	ldr	r3, [pc, #20]	; (1a001354 <Chip_Clock_GetDividerSource+0x18>)
1a001340:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

   if (reg & 1) {  /* divider is powered down */
1a001344:	f010 0f01 	tst.w	r0, #1
1a001348:	d001      	beq.n	1a00134e <Chip_Clock_GetDividerSource+0x12>
       return CLKINPUT_PD;
1a00134a:	2011      	movs	r0, #17
   }

   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
}
1a00134c:	4770      	bx	lr
   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
1a00134e:	f3c0 6004 	ubfx	r0, r0, #24, #5
1a001352:	4770      	bx	lr
1a001354:	40050000 	.word	0x40050000

1a001358 <Chip_Clock_GetDividerDivisor>:

/* Gets a CGU clock divider divisor */
uint32_t Chip_Clock_GetDividerDivisor(CHIP_CGU_IDIV_T Divider)
{
   return (CHIP_CGU_CLKIN_T) ((LPC_CGU->IDIV_CTRL[Divider] >> 2) & CHIP_CGU_IDIV_MASK(Divider));
1a001358:	f100 0212 	add.w	r2, r0, #18
1a00135c:	4b03      	ldr	r3, [pc, #12]	; (1a00136c <Chip_Clock_GetDividerDivisor+0x14>)
1a00135e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
1a001362:	4b03      	ldr	r3, [pc, #12]	; (1a001370 <Chip_Clock_GetDividerDivisor+0x18>)
1a001364:	5c18      	ldrb	r0, [r3, r0]
}
1a001366:	ea00 0092 	and.w	r0, r0, r2, lsr #2
1a00136a:	4770      	bx	lr
1a00136c:	40050000 	.word	0x40050000
1a001370:	1a002760 	.word	0x1a002760

1a001374 <Chip_Clock_GetClockInputHz>:

/* Returns the frequency of the specified input clock source */
uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input)
{
1a001374:	b508      	push	{r3, lr}
   uint32_t rate = 0;

   switch (input) {
1a001376:	2810      	cmp	r0, #16
1a001378:	d80a      	bhi.n	1a001390 <Chip_Clock_GetClockInputHz+0x1c>
1a00137a:	e8df f000 	tbb	[pc, r0]
1a00137e:	0b44      	.short	0x0b44
1a001380:	0921180d 	.word	0x0921180d
1a001384:	2d2a2724 	.word	0x2d2a2724
1a001388:	34300909 	.word	0x34300909
1a00138c:	3c38      	.short	0x3c38
1a00138e:	40          	.byte	0x40
1a00138f:	00          	.byte	0x00
   uint32_t rate = 0;
1a001390:	2000      	movs	r0, #0
1a001392:	bd08      	pop	{r3, pc}
   case CLKIN_32K:
       rate = CRYSTAL_32K_FREQ_IN;
       break;

   case CLKIN_IRC:
       rate = CGU_IRC_FREQ;
1a001394:	481e      	ldr	r0, [pc, #120]	; (1a001410 <Chip_Clock_GetClockInputHz+0x9c>)
       break;
1a001396:	bd08      	pop	{r3, pc}

   case CLKIN_ENET_RX:
       if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
1a001398:	4b1e      	ldr	r3, [pc, #120]	; (1a001414 <Chip_Clock_GetClockInputHz+0xa0>)
1a00139a:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
1a00139e:	f003 0307 	and.w	r3, r3, #7
1a0013a2:	2b04      	cmp	r3, #4
1a0013a4:	d001      	beq.n	1a0013aa <Chip_Clock_GetClockInputHz+0x36>
           /* MII mode requires 25MHz clock */
           rate = 25000000;
1a0013a6:	481c      	ldr	r0, [pc, #112]	; (1a001418 <Chip_Clock_GetClockInputHz+0xa4>)
1a0013a8:	bd08      	pop	{r3, pc}
   uint32_t rate = 0;
1a0013aa:	2000      	movs	r0, #0
1a0013ac:	bd08      	pop	{r3, pc}
       }
       break;

   case CLKIN_ENET_TX:
       if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
1a0013ae:	4b19      	ldr	r3, [pc, #100]	; (1a001414 <Chip_Clock_GetClockInputHz+0xa0>)
1a0013b0:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
1a0013b4:	f003 0307 	and.w	r3, r3, #7
1a0013b8:	2b04      	cmp	r3, #4
1a0013ba:	d027      	beq.n	1a00140c <Chip_Clock_GetClockInputHz+0x98>
           rate = 25000000; /* MII uses 25 MHz */
1a0013bc:	4816      	ldr	r0, [pc, #88]	; (1a001418 <Chip_Clock_GetClockInputHz+0xa4>)
1a0013be:	bd08      	pop	{r3, pc}
           rate = 50000000; /* RMII uses 50 MHz */
       }
       break;

   case CLKIN_CLKIN:
       rate = ExtRateIn;
1a0013c0:	4b16      	ldr	r3, [pc, #88]	; (1a00141c <Chip_Clock_GetClockInputHz+0xa8>)
1a0013c2:	6818      	ldr	r0, [r3, #0]
       break;
1a0013c4:	bd08      	pop	{r3, pc}

   case CLKIN_CRYSTAL:
       rate = OscRateIn;
1a0013c6:	4b16      	ldr	r3, [pc, #88]	; (1a001420 <Chip_Clock_GetClockInputHz+0xac>)
1a0013c8:	6818      	ldr	r0, [r3, #0]
       break;
1a0013ca:	bd08      	pop	{r3, pc}

   case CLKIN_USBPLL:
       rate = audio_usb_pll_freq[CGU_USB_PLL];
1a0013cc:	4b15      	ldr	r3, [pc, #84]	; (1a001424 <Chip_Clock_GetClockInputHz+0xb0>)
1a0013ce:	6818      	ldr	r0, [r3, #0]
       break;
1a0013d0:	bd08      	pop	{r3, pc}

   case CLKIN_AUDIOPLL:
       rate = audio_usb_pll_freq[CGU_AUDIO_PLL];
1a0013d2:	4b14      	ldr	r3, [pc, #80]	; (1a001424 <Chip_Clock_GetClockInputHz+0xb0>)
1a0013d4:	6858      	ldr	r0, [r3, #4]
       break;
1a0013d6:	bd08      	pop	{r3, pc}

   case CLKIN_MAINPLL:
       rate = Chip_Clock_GetMainPLLHz();
1a0013d8:	f000 f868 	bl	1a0014ac <Chip_Clock_GetMainPLLHz>
       break;
1a0013dc:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVA:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_A);
1a0013de:	2100      	movs	r1, #0
1a0013e0:	f000 f89a 	bl	1a001518 <Chip_Clock_GetDivRate>
       break;
1a0013e4:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVB:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_B);
1a0013e6:	2101      	movs	r1, #1
1a0013e8:	f000 f896 	bl	1a001518 <Chip_Clock_GetDivRate>
       break;
1a0013ec:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVC:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_C);
1a0013ee:	2102      	movs	r1, #2
1a0013f0:	f000 f892 	bl	1a001518 <Chip_Clock_GetDivRate>
       break;
1a0013f4:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVD:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_D);
1a0013f6:	2103      	movs	r1, #3
1a0013f8:	f000 f88e 	bl	1a001518 <Chip_Clock_GetDivRate>
       break;
1a0013fc:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVE:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_E);
1a0013fe:	2104      	movs	r1, #4
1a001400:	f000 f88a 	bl	1a001518 <Chip_Clock_GetDivRate>
       break;
1a001404:	bd08      	pop	{r3, pc}
       rate = CRYSTAL_32K_FREQ_IN;
1a001406:	f44f 4000 	mov.w	r0, #32768	; 0x8000
1a00140a:	bd08      	pop	{r3, pc}
           rate = 50000000; /* RMII uses 50 MHz */
1a00140c:	4806      	ldr	r0, [pc, #24]	; (1a001428 <Chip_Clock_GetClockInputHz+0xb4>)
   default:
       break;
   }

   return rate;
}
1a00140e:	bd08      	pop	{r3, pc}
1a001410:	00b71b00 	.word	0x00b71b00
1a001414:	40043000 	.word	0x40043000
1a001418:	017d7840 	.word	0x017d7840
1a00141c:	1a00282c 	.word	0x1a00282c
1a001420:	1a002830 	.word	0x1a002830
1a001424:	10000100 	.word	0x10000100
1a001428:	02faf080 	.word	0x02faf080

1a00142c <Chip_Clock_CalcMainPLLValue>:
{
1a00142c:	b538      	push	{r3, r4, r5, lr}
1a00142e:	4605      	mov	r5, r0
1a001430:	460c      	mov	r4, r1
   ppll->fin = Chip_Clock_GetClockInputHz(ppll->srcin);
1a001432:	7908      	ldrb	r0, [r1, #4]
1a001434:	f7ff ff9e 	bl	1a001374 <Chip_Clock_GetClockInputHz>
1a001438:	6160      	str	r0, [r4, #20]
   if (freq > MAX_CLOCK_FREQ || freq < (PLL_MIN_CCO_FREQ / 16) || !ppll->fin) {
1a00143a:	4b19      	ldr	r3, [pc, #100]	; (1a0014a0 <Chip_Clock_CalcMainPLLValue+0x74>)
1a00143c:	442b      	add	r3, r5
1a00143e:	4a19      	ldr	r2, [pc, #100]	; (1a0014a4 <Chip_Clock_CalcMainPLLValue+0x78>)
1a001440:	4293      	cmp	r3, r2
1a001442:	d821      	bhi.n	1a001488 <Chip_Clock_CalcMainPLLValue+0x5c>
1a001444:	b318      	cbz	r0, 1a00148e <Chip_Clock_CalcMainPLLValue+0x62>
   ppll->ctrl = 1 << 7; /* Enable direct mode [If possible] */
1a001446:	2380      	movs	r3, #128	; 0x80
1a001448:	6023      	str	r3, [r4, #0]
   ppll->nsel = 0;
1a00144a:	2300      	movs	r3, #0
1a00144c:	60a3      	str	r3, [r4, #8]
   ppll->psel = 0;
1a00144e:	60e3      	str	r3, [r4, #12]
   ppll->msel = freq / ppll->fin;
1a001450:	fbb5 f3f0 	udiv	r3, r5, r0
1a001454:	6123      	str	r3, [r4, #16]
   if (freq < PLL_MIN_CCO_FREQ || ppll->msel * ppll->fin != freq) {
1a001456:	4a14      	ldr	r2, [pc, #80]	; (1a0014a8 <Chip_Clock_CalcMainPLLValue+0x7c>)
1a001458:	4295      	cmp	r5, r2
1a00145a:	d903      	bls.n	1a001464 <Chip_Clock_CalcMainPLLValue+0x38>
1a00145c:	fb03 f000 	mul.w	r0, r3, r0
1a001460:	4285      	cmp	r5, r0
1a001462:	d007      	beq.n	1a001474 <Chip_Clock_CalcMainPLLValue+0x48>
       pll_get_frac(freq, ppll);
1a001464:	4621      	mov	r1, r4
1a001466:	4628      	mov	r0, r5
1a001468:	f7ff fe9c 	bl	1a0011a4 <pll_get_frac>
       if (!ppll->nsel) {
1a00146c:	68a3      	ldr	r3, [r4, #8]
1a00146e:	b18b      	cbz	r3, 1a001494 <Chip_Clock_CalcMainPLLValue+0x68>
       ppll->nsel --;
1a001470:	3b01      	subs	r3, #1
1a001472:	60a3      	str	r3, [r4, #8]
   if (ppll->msel == 0) {
1a001474:	6923      	ldr	r3, [r4, #16]
1a001476:	b183      	cbz	r3, 1a00149a <Chip_Clock_CalcMainPLLValue+0x6e>
   if (ppll->psel) {
1a001478:	68e2      	ldr	r2, [r4, #12]
1a00147a:	b10a      	cbz	r2, 1a001480 <Chip_Clock_CalcMainPLLValue+0x54>
       ppll->psel --;
1a00147c:	3a01      	subs	r2, #1
1a00147e:	60e2      	str	r2, [r4, #12]
   ppll->msel --;
1a001480:	3b01      	subs	r3, #1
1a001482:	6123      	str	r3, [r4, #16]
   return 0;
1a001484:	2000      	movs	r0, #0
1a001486:	bd38      	pop	{r3, r4, r5, pc}
       return -1;
1a001488:	f04f 30ff 	mov.w	r0, #4294967295
1a00148c:	bd38      	pop	{r3, r4, r5, pc}
1a00148e:	f04f 30ff 	mov.w	r0, #4294967295
1a001492:	bd38      	pop	{r3, r4, r5, pc}
           return -1;
1a001494:	f04f 30ff 	mov.w	r0, #4294967295
1a001498:	bd38      	pop	{r3, r4, r5, pc}
       return - 1;
1a00149a:	f04f 30ff 	mov.w	r0, #4294967295
}
1a00149e:	bd38      	pop	{r3, r4, r5, pc}
1a0014a0:	ff6b3a10 	.word	0xff6b3a10
1a0014a4:	0b940510 	.word	0x0b940510
1a0014a8:	094c5eff 	.word	0x094c5eff

1a0014ac <Chip_Clock_GetMainPLLHz>:
{
1a0014ac:	b530      	push	{r4, r5, lr}
1a0014ae:	b083      	sub	sp, #12
   uint32_t PLLReg = LPC_CGU->PLL1_CTRL;
1a0014b0:	4d17      	ldr	r5, [pc, #92]	; (1a001510 <Chip_Clock_GetMainPLLHz+0x64>)
1a0014b2:	6c6c      	ldr	r4, [r5, #68]	; 0x44
   uint32_t freq = Chip_Clock_GetClockInputHz((CHIP_CGU_CLKIN_T) ((PLLReg >> 24) & 0xF));
1a0014b4:	f3c4 6003 	ubfx	r0, r4, #24, #4
1a0014b8:	f7ff ff5c 	bl	1a001374 <Chip_Clock_GetClockInputHz>
   const uint8_t ptab[] = {1, 2, 4, 8};
1a0014bc:	4b15      	ldr	r3, [pc, #84]	; (1a001514 <Chip_Clock_GetMainPLLHz+0x68>)
1a0014be:	681b      	ldr	r3, [r3, #0]
1a0014c0:	9301      	str	r3, [sp, #4]
   if (!(LPC_CGU->PLL1_STAT & 1)) {
1a0014c2:	6c2b      	ldr	r3, [r5, #64]	; 0x40
1a0014c4:	f013 0f01 	tst.w	r3, #1
1a0014c8:	d01f      	beq.n	1a00150a <Chip_Clock_GetMainPLLHz+0x5e>
   msel = (PLLReg >> 16) & 0xFF;
1a0014ca:	f3c4 4207 	ubfx	r2, r4, #16, #8
   nsel = (PLLReg >> 12) & 0x3;
1a0014ce:	f3c4 3301 	ubfx	r3, r4, #12, #2
   psel = (PLLReg >> 8) & 0x3;
1a0014d2:	f3c4 2101 	ubfx	r1, r4, #8, #2
   fbsel = (PLLReg >> 6) & 0x1;
1a0014d6:	f3c4 1580 	ubfx	r5, r4, #6, #1
   m = msel + 1;
1a0014da:	3201      	adds	r2, #1
   n = nsel + 1;
1a0014dc:	3301      	adds	r3, #1
   p = ptab[psel];
1a0014de:	f10d 0e08 	add.w	lr, sp, #8
1a0014e2:	4471      	add	r1, lr
1a0014e4:	f811 1c04 	ldrb.w	r1, [r1, #-4]
   if (direct || fbsel) {
1a0014e8:	f014 0f80 	tst.w	r4, #128	; 0x80
1a0014ec:	d108      	bne.n	1a001500 <Chip_Clock_GetMainPLLHz+0x54>
1a0014ee:	b93d      	cbnz	r5, 1a001500 <Chip_Clock_GetMainPLLHz+0x54>
   return (m / (2 * p)) * (freq / n);
1a0014f0:	0049      	lsls	r1, r1, #1
1a0014f2:	fbb2 f2f1 	udiv	r2, r2, r1
1a0014f6:	fbb0 f0f3 	udiv	r0, r0, r3
1a0014fa:	fb00 f002 	mul.w	r0, r0, r2
1a0014fe:	e005      	b.n	1a00150c <Chip_Clock_GetMainPLLHz+0x60>
       return m * (freq / n);
1a001500:	fbb0 f0f3 	udiv	r0, r0, r3
1a001504:	fb00 f002 	mul.w	r0, r0, r2
1a001508:	e000      	b.n	1a00150c <Chip_Clock_GetMainPLLHz+0x60>
       return 0;
1a00150a:	2000      	movs	r0, #0
}
1a00150c:	b003      	add	sp, #12
1a00150e:	bd30      	pop	{r4, r5, pc}
1a001510:	40050000 	.word	0x40050000
1a001514:	1a00275c 	.word	0x1a00275c

1a001518 <Chip_Clock_GetDivRate>:
{
1a001518:	b538      	push	{r3, r4, r5, lr}
1a00151a:	460c      	mov	r4, r1
   input = Chip_Clock_GetDividerSource(divider);
1a00151c:	4608      	mov	r0, r1
1a00151e:	f7ff ff0d 	bl	1a00133c <Chip_Clock_GetDividerSource>
1a001522:	4605      	mov	r5, r0
   div = Chip_Clock_GetDividerDivisor(divider);
1a001524:	4620      	mov	r0, r4
1a001526:	f7ff ff17 	bl	1a001358 <Chip_Clock_GetDividerDivisor>
1a00152a:	4604      	mov	r4, r0
   return Chip_Clock_GetClockInputHz(input) / (div + 1);
1a00152c:	4628      	mov	r0, r5
1a00152e:	f7ff ff21 	bl	1a001374 <Chip_Clock_GetClockInputHz>
1a001532:	3401      	adds	r4, #1
}
1a001534:	fbb0 f0f4 	udiv	r0, r0, r4
1a001538:	bd38      	pop	{r3, r4, r5, pc}
1a00153a:	Address 0x1a00153a is out of bounds.


1a00153c <Chip_Clock_SetBaseClock>:
   return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
}

/* Sets a CGU Base Clock clock source */
void Chip_Clock_SetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T Input, bool autoblocken, bool powerdn)
{
1a00153c:	b430      	push	{r4, r5}
   uint32_t reg = LPC_CGU->BASE_CLK[BaseClock];
1a00153e:	f100 0416 	add.w	r4, r0, #22
1a001542:	00a4      	lsls	r4, r4, #2
1a001544:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
1a001548:	f504 24a0 	add.w	r4, r4, #327680	; 0x50000
1a00154c:	6865      	ldr	r5, [r4, #4]

   if (BaseClock < CLK_BASE_NONE) {
1a00154e:	281b      	cmp	r0, #27
1a001550:	d813      	bhi.n	1a00157a <Chip_Clock_SetBaseClock+0x3e>
       if (Input != CLKINPUT_PD) {
1a001552:	2911      	cmp	r1, #17
1a001554:	d01a      	beq.n	1a00158c <Chip_Clock_SetBaseClock+0x50>
           /* Mask off fields we plan to update */
           reg &= ~((0x1F << 24) | 1 | (1 << 11));
1a001556:	4c0e      	ldr	r4, [pc, #56]	; (1a001590 <Chip_Clock_SetBaseClock+0x54>)
1a001558:	402c      	ands	r4, r5

           if (autoblocken) {
1a00155a:	b10a      	cbz	r2, 1a001560 <Chip_Clock_SetBaseClock+0x24>
               reg |= (1 << 11);
1a00155c:	f444 6400 	orr.w	r4, r4, #2048	; 0x800
           }
           if (powerdn) {
1a001560:	b10b      	cbz	r3, 1a001566 <Chip_Clock_SetBaseClock+0x2a>
               reg |= (1 << 0);
1a001562:	f044 0401 	orr.w	r4, r4, #1
           }

           /* Set clock source */
           reg |= (Input << 24);
1a001566:	ea44 6401 	orr.w	r4, r4, r1, lsl #24

           LPC_CGU->BASE_CLK[BaseClock] = reg;
1a00156a:	3016      	adds	r0, #22
1a00156c:	0080      	lsls	r0, r0, #2
1a00156e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a001572:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a001576:	6044      	str	r4, [r0, #4]
1a001578:	e008      	b.n	1a00158c <Chip_Clock_SetBaseClock+0x50>
       }
   }
   else {
       LPC_CGU->BASE_CLK[BaseClock] = reg | 1; /* Power down this base clock */
1a00157a:	f045 0501 	orr.w	r5, r5, #1
1a00157e:	3016      	adds	r0, #22
1a001580:	0080      	lsls	r0, r0, #2
1a001582:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a001586:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a00158a:	6045      	str	r5, [r0, #4]
   }
}
1a00158c:	bc30      	pop	{r4, r5}
1a00158e:	4770      	bx	lr
1a001590:	e0fff7fe 	.word	0xe0fff7fe

1a001594 <Chip_Clock_GetBaseClock>:
/* Gets a CGU Base Clock clock source */
CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
{
   uint32_t reg;

   if (BaseClock >= CLK_BASE_NONE) {
1a001594:	281b      	cmp	r0, #27
1a001596:	d901      	bls.n	1a00159c <Chip_Clock_GetBaseClock+0x8>
       return CLKINPUT_PD;
1a001598:	2011      	movs	r0, #17
1a00159a:	4770      	bx	lr
   }

   reg = LPC_CGU->BASE_CLK[BaseClock];
1a00159c:	3016      	adds	r0, #22
1a00159e:	0080      	lsls	r0, r0, #2
1a0015a0:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a0015a4:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a0015a8:	6840      	ldr	r0, [r0, #4]

   /* base clock is powered down? */
   if (reg & 1) {
1a0015aa:	f010 0f01 	tst.w	r0, #1
1a0015ae:	d001      	beq.n	1a0015b4 <Chip_Clock_GetBaseClock+0x20>
       return CLKINPUT_PD;
1a0015b0:	2011      	movs	r0, #17
   }

   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
}
1a0015b2:	4770      	bx	lr
   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
1a0015b4:	f3c0 6004 	ubfx	r0, r0, #24, #5
1a0015b8:	4770      	bx	lr

1a0015ba <Chip_Clock_GetBaseClocktHz>:
{
1a0015ba:	b508      	push	{r3, lr}
   return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
1a0015bc:	f7ff ffea 	bl	1a001594 <Chip_Clock_GetBaseClock>
1a0015c0:	f7ff fed8 	bl	1a001374 <Chip_Clock_GetClockInputHz>
}
1a0015c4:	bd08      	pop	{r3, pc}
1a0015c6:	Address 0x1a0015c6 is out of bounds.


1a0015c8 <Chip_Clock_EnableOpts>:
/* Enables a peripheral clock and sets clock states */
void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div)
{
   uint32_t reg = 1;

   if (autoen) {
1a0015c8:	b969      	cbnz	r1, 1a0015e6 <Chip_Clock_EnableOpts+0x1e>
   uint32_t reg = 1;
1a0015ca:	2101      	movs	r1, #1
       reg |= (1 << 1);
   }
   if (wakeupen) {
1a0015cc:	b10a      	cbz	r2, 1a0015d2 <Chip_Clock_EnableOpts+0xa>
       reg |= (1 << 2);
1a0015ce:	f041 0104 	orr.w	r1, r1, #4
   }

   /* Not all clocks support a divider, but we won't check that here. Only
      dividers of 1 and 2 are allowed. Assume 1 if not 2 */
   if (div == 2) {
1a0015d2:	2b02      	cmp	r3, #2
1a0015d4:	d009      	beq.n	1a0015ea <Chip_Clock_EnableOpts+0x22>
       reg |= (1 << 5);
   }

   /* Setup peripheral clock and start running */
   if (clk >= CLK_CCU2_START) {
1a0015d6:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a0015da:	d209      	bcs.n	1a0015f0 <Chip_Clock_EnableOpts+0x28>
       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
   }
   else {
       LPC_CCU1->CLKCCU[clk].CFG = reg;
1a0015dc:	3020      	adds	r0, #32
1a0015de:	4b07      	ldr	r3, [pc, #28]	; (1a0015fc <Chip_Clock_EnableOpts+0x34>)
1a0015e0:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
1a0015e4:	4770      	bx	lr
       reg |= (1 << 1);
1a0015e6:	2103      	movs	r1, #3
1a0015e8:	e7f0      	b.n	1a0015cc <Chip_Clock_EnableOpts+0x4>
       reg |= (1 << 5);
1a0015ea:	f041 0120 	orr.w	r1, r1, #32
1a0015ee:	e7f2      	b.n	1a0015d6 <Chip_Clock_EnableOpts+0xe>
       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
1a0015f0:	f5a0 7091 	sub.w	r0, r0, #290	; 0x122
1a0015f4:	4b02      	ldr	r3, [pc, #8]	; (1a001600 <Chip_Clock_EnableOpts+0x38>)
1a0015f6:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
1a0015fa:	4770      	bx	lr
1a0015fc:	40051000 	.word	0x40051000
1a001600:	40052000 	.word	0x40052000

1a001604 <Chip_Clock_GetRate>:
   LPC_CCU2->PM = 0;
}

/* Returns a peripheral clock rate */
uint32_t Chip_Clock_GetRate(CHIP_CCU_CLK_T clk)
{
1a001604:	b510      	push	{r4, lr}
   CHIP_CGU_BASE_CLK_T baseclk;
   uint32_t reg, div, rate;

   /* Get CCU config register for clock */
   if (clk >= CLK_CCU2_START) {
1a001606:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a00160a:	d309      	bcc.n	1a001620 <Chip_Clock_GetRate+0x1c>
       reg = LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG;
1a00160c:	f5a0 7391 	sub.w	r3, r0, #290	; 0x122
1a001610:	4a0d      	ldr	r2, [pc, #52]	; (1a001648 <Chip_Clock_GetRate+0x44>)
1a001612:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
   else {
       reg = LPC_CCU1->CLKCCU[clk].CFG;
   }

   /* Is the clock enabled? */
   if (reg & 1) {
1a001616:	f014 0f01 	tst.w	r4, #1
1a00161a:	d107      	bne.n	1a00162c <Chip_Clock_GetRate+0x28>

       }
       rate = rate / div;
   }
   else {
       rate = 0;
1a00161c:	2000      	movs	r0, #0
   }

   return rate;
}
1a00161e:	bd10      	pop	{r4, pc}
       reg = LPC_CCU1->CLKCCU[clk].CFG;
1a001620:	f100 0320 	add.w	r3, r0, #32
1a001624:	4a09      	ldr	r2, [pc, #36]	; (1a00164c <Chip_Clock_GetRate+0x48>)
1a001626:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
1a00162a:	e7f4      	b.n	1a001616 <Chip_Clock_GetRate+0x12>
       baseclk = Chip_Clock_FindBaseClock(clk);
1a00162c:	f7ff fe3a 	bl	1a0012a4 <Chip_Clock_FindBaseClock>
       rate = Chip_Clock_GetBaseClocktHz(baseclk);
1a001630:	f7ff ffc3 	bl	1a0015ba <Chip_Clock_GetBaseClocktHz>
       if (((reg >> 5) & 0x7) == 0) {
1a001634:	f014 0fe0 	tst.w	r4, #224	; 0xe0
1a001638:	d103      	bne.n	1a001642 <Chip_Clock_GetRate+0x3e>
           div = 1;
1a00163a:	2301      	movs	r3, #1
       rate = rate / div;
1a00163c:	fbb0 f0f3 	udiv	r0, r0, r3
1a001640:	bd10      	pop	{r4, pc}
           div = 2;/* No other dividers supported */
1a001642:	2302      	movs	r3, #2
1a001644:	e7fa      	b.n	1a00163c <Chip_Clock_GetRate+0x38>
1a001646:	bf00      	nop
1a001648:	40052000 	.word	0x40052000
1a00164c:	40051000 	.word	0x40051000

1a001650 <fpuInit>:
 * Public functions
 ****************************************************************************/

/* Early initialization of the FPU */
void fpuInit(void)
{
1a001650:	b084      	sub	sp, #16
   volatile uint32_t Cpacr;
   volatile uint32_t Mvfr0;
   volatile uint32_t Mvfr1;
   char vfpPresent = 0;

   Mvfr0 = *regMvfr0;
1a001652:	4b0f      	ldr	r3, [pc, #60]	; (1a001690 <fpuInit+0x40>)
1a001654:	681b      	ldr	r3, [r3, #0]
1a001656:	9302      	str	r3, [sp, #8]
   Mvfr1 = *regMvfr1;
1a001658:	4b0e      	ldr	r3, [pc, #56]	; (1a001694 <fpuInit+0x44>)
1a00165a:	681b      	ldr	r3, [r3, #0]
1a00165c:	9301      	str	r3, [sp, #4]

   vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
1a00165e:	9a02      	ldr	r2, [sp, #8]
1a001660:	4b0d      	ldr	r3, [pc, #52]	; (1a001698 <fpuInit+0x48>)
1a001662:	429a      	cmp	r2, r3
1a001664:	d00c      	beq.n	1a001680 <fpuInit+0x30>
1a001666:	2300      	movs	r3, #0

   if (vfpPresent) {
1a001668:	b143      	cbz	r3, 1a00167c <fpuInit+0x2c>
       Cpacr = *regCpacr;
1a00166a:	4a0c      	ldr	r2, [pc, #48]	; (1a00169c <fpuInit+0x4c>)
1a00166c:	6813      	ldr	r3, [r2, #0]
1a00166e:	9303      	str	r3, [sp, #12]
       Cpacr |= (0xF << 20);
1a001670:	9b03      	ldr	r3, [sp, #12]
1a001672:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
1a001676:	9303      	str	r3, [sp, #12]
       *regCpacr = Cpacr;  // enable CP10 and CP11 for full access
1a001678:	9b03      	ldr	r3, [sp, #12]
1a00167a:	6013      	str	r3, [r2, #0]
   }
#endif /* __FPU_PRESENT != 0 */
}
1a00167c:	b004      	add	sp, #16
1a00167e:	4770      	bx	lr
   vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
1a001680:	9a01      	ldr	r2, [sp, #4]
1a001682:	4b07      	ldr	r3, [pc, #28]	; (1a0016a0 <fpuInit+0x50>)
1a001684:	429a      	cmp	r2, r3
1a001686:	d001      	beq.n	1a00168c <fpuInit+0x3c>
1a001688:	2300      	movs	r3, #0
1a00168a:	e7ed      	b.n	1a001668 <fpuInit+0x18>
1a00168c:	2301      	movs	r3, #1
1a00168e:	e7eb      	b.n	1a001668 <fpuInit+0x18>
1a001690:	e000ef40 	.word	0xe000ef40
1a001694:	e000ef44 	.word	0xe000ef44
1a001698:	10110021 	.word	0x10110021
1a00169c:	e000ed88 	.word	0xe000ed88
1a0016a0:	11000011 	.word	0x11000011

1a0016a4 <Chip_GPIO_Init>:
 * Public functions
 ****************************************************************************/

/* Initialize GPIO block */
void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
{
1a0016a4:	4770      	bx	lr

1a0016a6 <Chip_GPIO_SetDir>:
}

/* Set Direction for a GPIO port */
void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
{
   if (out) {
1a0016a6:	b943      	cbnz	r3, 1a0016ba <Chip_GPIO_SetDir+0x14>
       pGPIO->DIR[portNum] |= bitValue;
   }
   else {
       pGPIO->DIR[portNum] &= ~bitValue;
1a0016a8:	f501 6100 	add.w	r1, r1, #2048	; 0x800
1a0016ac:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
1a0016b0:	ea23 0202 	bic.w	r2, r3, r2
1a0016b4:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
1a0016b8:	4770      	bx	lr
       pGPIO->DIR[portNum] |= bitValue;
1a0016ba:	f501 6100 	add.w	r1, r1, #2048	; 0x800
1a0016be:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
1a0016c2:	431a      	orrs	r2, r3
1a0016c4:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
1a0016c8:	4770      	bx	lr
1a0016ca:	Address 0x1a0016ca is out of bounds.


1a0016cc <Chip_SetupCoreClock>:
/*****************************************************************************
 * Public functions
 ****************************************************************************/
/* Setup Chip Core clock */
void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase)
{
1a0016cc:	b570      	push	{r4, r5, r6, lr}
1a0016ce:	b092      	sub	sp, #72	; 0x48
1a0016d0:	4605      	mov	r5, r0
1a0016d2:	460e      	mov	r6, r1
1a0016d4:	4614      	mov	r4, r2
   int i;
   volatile uint32_t delay = 5500;
1a0016d6:	f241 537c 	movw	r3, #5500	; 0x157c
1a0016da:	9311      	str	r3, [sp, #68]	; 0x44
   uint32_t direct = 0;
   PLL_PARAM_T ppll;

   if (clkin == CLKIN_CRYSTAL) {
1a0016dc:	2806      	cmp	r0, #6
1a0016de:	d044      	beq.n	1a00176a <Chip_SetupCoreClock+0x9e>
       /* Switch main system clocking to crystal */
       Chip_Clock_EnableCrystal();
   }
   Chip_Clock_SetBaseClock(CLK_BASE_MX, clkin, true, false);
1a0016e0:	2300      	movs	r3, #0
1a0016e2:	2201      	movs	r2, #1
1a0016e4:	4629      	mov	r1, r5
1a0016e6:	2004      	movs	r0, #4
1a0016e8:	f7ff ff28 	bl	1a00153c <Chip_Clock_SetBaseClock>
 * Saves power if the main PLL is not needed.
 */
__STATIC_INLINE void Chip_Clock_DisableMainPLL(void)
{
   /* power down main PLL */
   LPC_CGU->PLL1_CTRL |= 1;
1a0016ec:	4a4a      	ldr	r2, [pc, #296]	; (1a001818 <Chip_SetupCoreClock+0x14c>)
1a0016ee:	6c53      	ldr	r3, [r2, #68]	; 0x44
1a0016f0:	f043 0301 	orr.w	r3, r3, #1
1a0016f4:	6453      	str	r3, [r2, #68]	; 0x44
   Chip_Clock_DisableMainPLL(); /* Disable PLL */

   /* Calculate the PLL Parameters */
   ppll.srcin = clkin;
1a0016f6:	f88d 5028 	strb.w	r5, [sp, #40]	; 0x28
   Chip_Clock_CalcMainPLLValue(core_freq, &ppll);
1a0016fa:	a909      	add	r1, sp, #36	; 0x24
1a0016fc:	4630      	mov	r0, r6
1a0016fe:	f7ff fe95 	bl	1a00142c <Chip_Clock_CalcMainPLLValue>

   if (core_freq > 110000000UL) {
1a001702:	4b46      	ldr	r3, [pc, #280]	; (1a00181c <Chip_SetupCoreClock+0x150>)
1a001704:	429e      	cmp	r6, r3
1a001706:	d938      	bls.n	1a00177a <Chip_SetupCoreClock+0xae>
       if (!(ppll.ctrl & (1 << 7)) || ppll.psel) {
1a001708:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a00170a:	f013 0f80 	tst.w	r3, #128	; 0x80
1a00170e:	d001      	beq.n	1a001714 <Chip_SetupCoreClock+0x48>
1a001710:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a001712:	b36a      	cbz	r2, 1a001770 <Chip_SetupCoreClock+0xa4>
           PLL_PARAM_T lpll;
           /* Calculate the PLL Parameters */
           lpll.srcin = clkin;
1a001714:	f88d 5008 	strb.w	r5, [sp, #8]
           Chip_Clock_CalcMainPLLValue(110000000UL, &lpll);
1a001718:	a901      	add	r1, sp, #4
1a00171a:	4840      	ldr	r0, [pc, #256]	; (1a00181c <Chip_SetupCoreClock+0x150>)
1a00171c:	f7ff fe86 	bl	1a00142c <Chip_Clock_CalcMainPLLValue>
 * Make sure the main PLL is enabled.
 */
__STATIC_INLINE void Chip_Clock_SetupMainPLL(const PLL_PARAM_T *ppll)
{
   /* power up main PLL */
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a001720:	f89d 2008 	ldrb.w	r2, [sp, #8]
1a001724:	9b01      	ldr	r3, [sp, #4]
1a001726:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a00172a:	9a05      	ldr	r2, [sp, #20]
1a00172c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a001730:	9a03      	ldr	r2, [sp, #12]
1a001732:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a001736:	9a04      	ldr	r2, [sp, #16]
1a001738:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a00173c:	4a36      	ldr	r2, [pc, #216]	; (1a001818 <Chip_SetupCoreClock+0x14c>)
1a00173e:	6453      	str	r3, [r2, #68]	; 0x44
 * @note   The main PLL should be locked prior to using it as a clock input for a base clock.
 */
__STATIC_INLINE int Chip_Clock_MainPLLLocked(void)
{
   /* Return true if locked */
   return (LPC_CGU->PLL1_STAT & 1) != 0;
1a001740:	4b35      	ldr	r3, [pc, #212]	; (1a001818 <Chip_SetupCoreClock+0x14c>)
1a001742:	6c1b      	ldr	r3, [r3, #64]	; 0x40
           Chip_Clock_SetupMainPLL(&lpll);
           /* Wait for the PLL to lock */
           while(!Chip_Clock_MainPLLLocked()) {}
1a001744:	f013 0f01 	tst.w	r3, #1
1a001748:	d0fa      	beq.n	1a001740 <Chip_SetupCoreClock+0x74>
           Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
1a00174a:	2300      	movs	r3, #0
1a00174c:	2201      	movs	r2, #1
1a00174e:	2109      	movs	r1, #9
1a001750:	2004      	movs	r0, #4
1a001752:	f7ff fef3 	bl	1a00153c <Chip_Clock_SetBaseClock>
           while(delay --){}
1a001756:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a001758:	1e5a      	subs	r2, r3, #1
1a00175a:	9211      	str	r2, [sp, #68]	; 0x44
1a00175c:	2b00      	cmp	r3, #0
1a00175e:	d1fa      	bne.n	1a001756 <Chip_SetupCoreClock+0x8a>
           delay = 5500;
1a001760:	f241 537c 	movw	r3, #5500	; 0x157c
1a001764:	9311      	str	r3, [sp, #68]	; 0x44
   uint32_t direct = 0;
1a001766:	2500      	movs	r5, #0
       if (!(ppll.ctrl & (1 << 7)) || ppll.psel) {
1a001768:	e008      	b.n	1a00177c <Chip_SetupCoreClock+0xb0>
       Chip_Clock_EnableCrystal();
1a00176a:	f7ff fdc1 	bl	1a0012f0 <Chip_Clock_EnableCrystal>
1a00176e:	e7b7      	b.n	1a0016e0 <Chip_SetupCoreClock+0x14>
       } else {
           direct = 1;
           ppll.ctrl &= ~(1 << 7);
1a001770:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1a001774:	9309      	str	r3, [sp, #36]	; 0x24
           direct = 1;
1a001776:	2501      	movs	r5, #1
1a001778:	e000      	b.n	1a00177c <Chip_SetupCoreClock+0xb0>
   uint32_t direct = 0;
1a00177a:	2500      	movs	r5, #0
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a00177c:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
1a001780:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a001782:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a001786:	9a0d      	ldr	r2, [sp, #52]	; 0x34
1a001788:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a00178c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
1a00178e:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a001792:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a001794:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a001798:	4a1f      	ldr	r2, [pc, #124]	; (1a001818 <Chip_SetupCoreClock+0x14c>)
1a00179a:	6453      	str	r3, [r2, #68]	; 0x44
   return (LPC_CGU->PLL1_STAT & 1) != 0;
1a00179c:	4b1e      	ldr	r3, [pc, #120]	; (1a001818 <Chip_SetupCoreClock+0x14c>)
1a00179e:	6c1b      	ldr	r3, [r3, #64]	; 0x40

   /* Setup and start the PLL */
   Chip_Clock_SetupMainPLL(&ppll);

   /* Wait for the PLL to lock */
   while(!Chip_Clock_MainPLLLocked()) {}
1a0017a0:	f013 0f01 	tst.w	r3, #1
1a0017a4:	d0fa      	beq.n	1a00179c <Chip_SetupCoreClock+0xd0>

   /* Set core clock base as PLL1 */
   Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
1a0017a6:	2300      	movs	r3, #0
1a0017a8:	2201      	movs	r2, #1
1a0017aa:	2109      	movs	r1, #9
1a0017ac:	2004      	movs	r0, #4
1a0017ae:	f7ff fec5 	bl	1a00153c <Chip_Clock_SetBaseClock>

   while(delay --){} /* Wait for approx 50 uSec */
1a0017b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a0017b4:	1e5a      	subs	r2, r3, #1
1a0017b6:	9211      	str	r2, [sp, #68]	; 0x44
1a0017b8:	2b00      	cmp	r3, #0
1a0017ba:	d1fa      	bne.n	1a0017b2 <Chip_SetupCoreClock+0xe6>
   if (direct) {
1a0017bc:	b1d5      	cbz	r5, 1a0017f4 <Chip_SetupCoreClock+0x128>
       delay = 5500;
1a0017be:	f241 537c 	movw	r3, #5500	; 0x157c
1a0017c2:	9311      	str	r3, [sp, #68]	; 0x44
       ppll.ctrl |= 1 << 7;
1a0017c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a0017c6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1a0017ca:	9309      	str	r3, [sp, #36]	; 0x24
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a0017cc:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
1a0017d0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a0017d4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
1a0017d6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a0017da:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
1a0017dc:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a0017e0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a0017e2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a0017e6:	4a0c      	ldr	r2, [pc, #48]	; (1a001818 <Chip_SetupCoreClock+0x14c>)
1a0017e8:	6453      	str	r3, [r2, #68]	; 0x44
       Chip_Clock_SetupMainPLL(&ppll); /* Set DIRECT to operate at full frequency */
       while(delay --){} /* Wait for approx 50 uSec */
1a0017ea:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a0017ec:	1e5a      	subs	r2, r3, #1
1a0017ee:	9211      	str	r2, [sp, #68]	; 0x44
1a0017f0:	2b00      	cmp	r3, #0
1a0017f2:	d1fa      	bne.n	1a0017ea <Chip_SetupCoreClock+0x11e>
   }

   if (setbase) {
1a0017f4:	b174      	cbz	r4, 1a001814 <Chip_SetupCoreClock+0x148>
1a0017f6:	2400      	movs	r4, #0
1a0017f8:	e00a      	b.n	1a001810 <Chip_SetupCoreClock+0x144>
       /* Setup system base clocks and initial states. This won't enable and
          disable individual clocks, but sets up the base clock sources for
          each individual peripheral clock. */
       for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
           Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
1a0017fa:	4809      	ldr	r0, [pc, #36]	; (1a001820 <Chip_SetupCoreClock+0x154>)
1a0017fc:	eb00 0184 	add.w	r1, r0, r4, lsl #2
1a001800:	78cb      	ldrb	r3, [r1, #3]
1a001802:	788a      	ldrb	r2, [r1, #2]
1a001804:	7849      	ldrb	r1, [r1, #1]
1a001806:	f810 0024 	ldrb.w	r0, [r0, r4, lsl #2]
1a00180a:	f7ff fe97 	bl	1a00153c <Chip_Clock_SetBaseClock>
       for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a00180e:	3401      	adds	r4, #1
1a001810:	2c11      	cmp	r4, #17
1a001812:	d9f2      	bls.n	1a0017fa <Chip_SetupCoreClock+0x12e>
                                   InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
       }
   }
}
1a001814:	b012      	add	sp, #72	; 0x48
1a001816:	bd70      	pop	{r4, r5, r6, pc}
1a001818:	40050000 	.word	0x40050000
1a00181c:	068e7780 	.word	0x068e7780
1a001820:	1a0027d4 	.word	0x1a0027d4

1a001824 <Chip_UART_GetIndex>:

/* Returns clock index for the peripheral block */
static int Chip_UART_GetIndex(LPC_USART_T *pUART)
{
   uint32_t base = (uint32_t) pUART;
   switch(base) {
1a001824:	4b09      	ldr	r3, [pc, #36]	; (1a00184c <Chip_UART_GetIndex+0x28>)
1a001826:	4298      	cmp	r0, r3
1a001828:	d009      	beq.n	1a00183e <Chip_UART_GetIndex+0x1a>
1a00182a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
1a00182e:	4298      	cmp	r0, r3
1a001830:	d007      	beq.n	1a001842 <Chip_UART_GetIndex+0x1e>
1a001832:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
1a001836:	4298      	cmp	r0, r3
1a001838:	d005      	beq.n	1a001846 <Chip_UART_GetIndex+0x22>
       case LPC_USART0_BASE:
           return 0;
1a00183a:	2000      	movs	r0, #0
1a00183c:	4770      	bx	lr
       case LPC_UART1_BASE:
           return 1;
       case LPC_USART2_BASE:
           return 2;
1a00183e:	2002      	movs	r0, #2
1a001840:	4770      	bx	lr
       case LPC_USART3_BASE:
           return 3;
1a001842:	2003      	movs	r0, #3
1a001844:	4770      	bx	lr
           return 1;
1a001846:	2001      	movs	r0, #1
       default:
           return 0; /* Should never come here */
   }
}
1a001848:	4770      	bx	lr
1a00184a:	bf00      	nop
1a00184c:	400c1000 	.word	0x400c1000

1a001850 <Chip_UART_Init>:
 * Public functions
 ****************************************************************************/

/* Initializes the pUART peripheral */
void Chip_UART_Init(LPC_USART_T *pUART)
{
1a001850:	b530      	push	{r4, r5, lr}
1a001852:	b083      	sub	sp, #12
1a001854:	4604      	mov	r4, r0
    volatile uint32_t tmp;

   /* Enable UART clocking. UART base clock(s) must already be enabled */
   Chip_Clock_EnableOpts(UART_PClock[Chip_UART_GetIndex(pUART)], true, true, 1);
1a001856:	f7ff ffe5 	bl	1a001824 <Chip_UART_GetIndex>
1a00185a:	2301      	movs	r3, #1
1a00185c:	461a      	mov	r2, r3
1a00185e:	4619      	mov	r1, r3
1a001860:	4d0e      	ldr	r5, [pc, #56]	; (1a00189c <Chip_UART_Init+0x4c>)
1a001862:	f835 0010 	ldrh.w	r0, [r5, r0, lsl #1]
1a001866:	f7ff feaf 	bl	1a0015c8 <Chip_Clock_EnableOpts>
 *         with a RX trip level of 8 characters, use something like
 *         (UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2)
 */
STATIC INLINE void Chip_UART_SetupFIFOS(LPC_USART_T *pUART, uint32_t fcr)
{
   pUART->FCR = fcr;
1a00186a:	2307      	movs	r3, #7
1a00186c:	60a3      	str	r3, [r4, #8]
    pUART->TER2 = 0;
1a00186e:	2300      	movs	r3, #0
1a001870:	65e3      	str	r3, [r4, #92]	; 0x5c

    /* Disable Tx */
    Chip_UART_TXDisable(pUART);

    /* Disable interrupts */
   pUART->IER = 0;
1a001872:	6063      	str	r3, [r4, #4]
   /* Set LCR to default state */
   pUART->LCR = 0;
1a001874:	60e3      	str	r3, [r4, #12]
   /* Set ACR to default state */
   pUART->ACR = 0;
1a001876:	6223      	str	r3, [r4, #32]
    /* Set RS485 control to default state */
   pUART->RS485CTRL = 0;
1a001878:	64e3      	str	r3, [r4, #76]	; 0x4c
   /* Set RS485 delay timer to default state */
   pUART->RS485DLY = 0;
1a00187a:	6563      	str	r3, [r4, #84]	; 0x54
   /* Set RS485 addr match to default state */
   pUART->RS485ADRMATCH = 0;
1a00187c:	6523      	str	r3, [r4, #80]	; 0x50

    /* Clear MCR */
    if (pUART == LPC_UART1) {
1a00187e:	4b08      	ldr	r3, [pc, #32]	; (1a0018a0 <Chip_UART_Init+0x50>)
1a001880:	429c      	cmp	r4, r3
1a001882:	d005      	beq.n	1a001890 <Chip_UART_Init+0x40>
 *         stop bit, and even (enabled) parity would be
 *         (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
   pUART->LCR = config;
1a001884:	2303      	movs	r3, #3
1a001886:	60e3      	str	r3, [r4, #12]

   /* Default 8N1, with DLAB disabled */
   Chip_UART_ConfigData(pUART, (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS));

   /* Disable fractional divider */
   pUART->FDR = 0x10;
1a001888:	2310      	movs	r3, #16
1a00188a:	62a3      	str	r3, [r4, #40]	; 0x28
}
1a00188c:	b003      	add	sp, #12
1a00188e:	bd30      	pop	{r4, r5, pc}
       pUART->MCR = 0;
1a001890:	2300      	movs	r3, #0
1a001892:	6123      	str	r3, [r4, #16]
       tmp = pUART->MSR;
1a001894:	69a3      	ldr	r3, [r4, #24]
1a001896:	9301      	str	r3, [sp, #4]
1a001898:	e7f4      	b.n	1a001884 <Chip_UART_Init+0x34>
1a00189a:	bf00      	nop
1a00189c:	1a002824 	.word	0x1a002824
1a0018a0:	40082000 	.word	0x40082000

1a0018a4 <Chip_UART_SetBaud>:
   return readBytes;
}

/* Determines and sets best dividers to get a target bit rate */
uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
{
1a0018a4:	b538      	push	{r3, r4, r5, lr}
1a0018a6:	4605      	mov	r5, r0
1a0018a8:	460c      	mov	r4, r1
   uint32_t div, divh, divl, clkin;

   /* Determine UART clock in rate without FDR */
   clkin = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
1a0018aa:	f7ff ffbb 	bl	1a001824 <Chip_UART_GetIndex>
1a0018ae:	4b0c      	ldr	r3, [pc, #48]	; (1a0018e0 <Chip_UART_SetBaud+0x3c>)
1a0018b0:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1a0018b4:	f7ff fea6 	bl	1a001604 <Chip_Clock_GetRate>
   div = clkin / (baudrate * 16);
1a0018b8:	0123      	lsls	r3, r4, #4
1a0018ba:	fbb0 f3f3 	udiv	r3, r0, r3
1a0018be:	b2d9      	uxtb	r1, r3
 * @param  pUART   : Pointer to selected UART peripheral
 * @return Nothing
 */
STATIC INLINE void Chip_UART_EnableDivisorAccess(LPC_USART_T *pUART)
{
   pUART->LCR |= UART_LCR_DLAB_EN;
1a0018c0:	68ea      	ldr	r2, [r5, #12]
1a0018c2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
1a0018c6:	60ea      	str	r2, [r5, #12]
 *         order to access the USART Divisor Latches. This function
 *         doesn't alter the DLAB state.
 */
STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
{
   pUART->DLL = (uint32_t) dll;
1a0018c8:	6029      	str	r1, [r5, #0]
1a0018ca:	f3c3 2207 	ubfx	r2, r3, #8, #8
   pUART->DLM = (uint32_t) dlm;
1a0018ce:	606a      	str	r2, [r5, #4]
   pUART->LCR &= ~UART_LCR_DLAB_EN;
1a0018d0:	68ea      	ldr	r2, [r5, #12]
1a0018d2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
1a0018d6:	60ea      	str	r2, [r5, #12]
   Chip_UART_DisableDivisorAccess(pUART);

   /* Fractional FDR alreadt setup for 1 in UART init */

   return clkin / div;
}
1a0018d8:	fbb0 f0f3 	udiv	r0, r0, r3
1a0018dc:	bd38      	pop	{r3, r4, r5, pc}
1a0018de:	bf00      	nop
1a0018e0:	1a00281c 	.word	0x1a00281c

1a0018e4 <Chip_UART_SetBaudFDR>:
    Chip_UART_ABIntHandler(pUART);
}

/* Determines and sets best dividers to get a target baud rate */
uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud)
{
1a0018e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1a0018e8:	b083      	sub	sp, #12
1a0018ea:	4683      	mov	fp, r0
1a0018ec:	4688      	mov	r8, r1
   uint32_t sdiv = 0, sm = 1, sd = 0;
   uint32_t pclk, m, d;
   uint32_t odiff = -1UL; /* old best diff */

   /* Get base clock for the corresponding UART */
   pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
1a0018ee:	f7ff ff99 	bl	1a001824 <Chip_UART_GetIndex>
1a0018f2:	4b35      	ldr	r3, [pc, #212]	; (1a0019c8 <Chip_UART_SetBaudFDR+0xe4>)
1a0018f4:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1a0018f8:	f7ff fe84 	bl	1a001604 <Chip_Clock_GetRate>
1a0018fc:	4606      	mov	r6, r0
   uint32_t odiff = -1UL; /* old best diff */
1a0018fe:	f04f 37ff 	mov.w	r7, #4294967295

   /* Loop through all possible fractional divider values */
   for (m = 1; odiff && m < 16; m++) {
1a001902:	2401      	movs	r4, #1
   uint32_t sdiv = 0, sm = 1, sd = 0;
1a001904:	2300      	movs	r3, #0
1a001906:	9301      	str	r3, [sp, #4]
1a001908:	46a2      	mov	sl, r4
1a00190a:	4699      	mov	r9, r3
   for (m = 1; odiff && m < 16; m++) {
1a00190c:	e02a      	b.n	1a001964 <Chip_UART_SetBaudFDR+0x80>
           /* Upper 32-bit of dval has div */
           div = (uint32_t) (dval >> 32);

           /* Closer to next div */
           if ((int)diff < 0) {
               diff = -diff;
1a00190e:	4243      	negs	r3, r0
               div ++;
1a001910:	1c4a      	adds	r2, r1, #1
1a001912:	e017      	b.n	1a001944 <Chip_UART_SetBaudFDR+0x60>
           sd = d;
           sm = m;
           odiff = diff;

           /* On perfect match, break loop */
           if(!diff) {
1a001914:	b30b      	cbz	r3, 1a00195a <Chip_UART_SetBaudFDR+0x76>
           odiff = diff;
1a001916:	461f      	mov	r7, r3
           sd = d;
1a001918:	9501      	str	r5, [sp, #4]
           sm = m;
1a00191a:	46a2      	mov	sl, r4
           sdiv = div;
1a00191c:	4691      	mov	r9, r2
       for (d = 0; d < m; d++) {
1a00191e:	3501      	adds	r5, #1
1a001920:	42ac      	cmp	r4, r5
1a001922:	d91e      	bls.n	1a001962 <Chip_UART_SetBaudFDR+0x7e>
           uint64_t dval = (((uint64_t) pclk << 28) * m) / (baud * (m + d));
1a001924:	0933      	lsrs	r3, r6, #4
1a001926:	0730      	lsls	r0, r6, #28
1a001928:	fba4 0100 	umull	r0, r1, r4, r0
1a00192c:	fb04 1103 	mla	r1, r4, r3, r1
1a001930:	1962      	adds	r2, r4, r5
1a001932:	fb08 f202 	mul.w	r2, r8, r2
1a001936:	2300      	movs	r3, #0
1a001938:	f000 fc48 	bl	1a0021cc <__aeabi_uldivmod>
           diff = (uint32_t) dval;
1a00193c:	4603      	mov	r3, r0
           div = (uint32_t) (dval >> 32);
1a00193e:	460a      	mov	r2, r1
           if ((int)diff < 0) {
1a001940:	2800      	cmp	r0, #0
1a001942:	dbe4      	blt.n	1a00190e <Chip_UART_SetBaudFDR+0x2a>
           if (odiff < diff || !div || (div >> 16) || (div < 3 && d)) {
1a001944:	429f      	cmp	r7, r3
1a001946:	d3ea      	bcc.n	1a00191e <Chip_UART_SetBaudFDR+0x3a>
1a001948:	2a00      	cmp	r2, #0
1a00194a:	d0e8      	beq.n	1a00191e <Chip_UART_SetBaudFDR+0x3a>
1a00194c:	0c11      	lsrs	r1, r2, #16
1a00194e:	d1e6      	bne.n	1a00191e <Chip_UART_SetBaudFDR+0x3a>
1a001950:	2a02      	cmp	r2, #2
1a001952:	d8df      	bhi.n	1a001914 <Chip_UART_SetBaudFDR+0x30>
1a001954:	2d00      	cmp	r5, #0
1a001956:	d1e2      	bne.n	1a00191e <Chip_UART_SetBaudFDR+0x3a>
1a001958:	e7dc      	b.n	1a001914 <Chip_UART_SetBaudFDR+0x30>
           odiff = diff;
1a00195a:	461f      	mov	r7, r3
           sd = d;
1a00195c:	9501      	str	r5, [sp, #4]
           sm = m;
1a00195e:	46a2      	mov	sl, r4
           sdiv = div;
1a001960:	4691      	mov	r9, r2
   for (m = 1; odiff && m < 16; m++) {
1a001962:	3401      	adds	r4, #1
1a001964:	b11f      	cbz	r7, 1a00196e <Chip_UART_SetBaudFDR+0x8a>
1a001966:	2c0f      	cmp	r4, #15
1a001968:	d801      	bhi.n	1a00196e <Chip_UART_SetBaudFDR+0x8a>
1a00196a:	2500      	movs	r5, #0
1a00196c:	e7d8      	b.n	1a001920 <Chip_UART_SetBaudFDR+0x3c>
           }
       }
   }

   /* Return 0 if a vaild divisor is not possible */
   if (!sdiv) {
1a00196e:	f1b9 0f00 	cmp.w	r9, #0
1a001972:	d024      	beq.n	1a0019be <Chip_UART_SetBaudFDR+0xda>
   pUART->LCR |= UART_LCR_DLAB_EN;
1a001974:	f8db 300c 	ldr.w	r3, [fp, #12]
1a001978:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1a00197c:	f8cb 300c 	str.w	r3, [fp, #12]
1a001980:	fa5f f389 	uxtb.w	r3, r9
   pUART->DLL = (uint32_t) dll;
1a001984:	f8cb 3000 	str.w	r3, [fp]
1a001988:	f3c9 2307 	ubfx	r3, r9, #8, #8
   pUART->DLM = (uint32_t) dlm;
1a00198c:	f8cb 3004 	str.w	r3, [fp, #4]
   pUART->LCR &= ~UART_LCR_DLAB_EN;
1a001990:	f8db 300c 	ldr.w	r3, [fp, #12]
1a001994:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1a001998:	f8cb 300c 	str.w	r3, [fp, #12]
   Chip_UART_EnableDivisorAccess(pUART);
   Chip_UART_SetDivisorLatches(pUART, UART_LOAD_DLL(sdiv), UART_LOAD_DLM(sdiv));
   Chip_UART_DisableDivisorAccess(pUART);

   /* Set best fractional divider */
   pUART->FDR = (UART_FDR_MULVAL(sm) | UART_FDR_DIVADDVAL(sd));
1a00199c:	ea4f 130a 	mov.w	r3, sl, lsl #4
1a0019a0:	b2db      	uxtb	r3, r3
1a0019a2:	9901      	ldr	r1, [sp, #4]
1a0019a4:	f001 020f 	and.w	r2, r1, #15
1a0019a8:	4313      	orrs	r3, r2
1a0019aa:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28

   /* Return actual baud rate */
   return (pclk >> 4) * sm / (sdiv * (sm + sd));
1a0019ae:	0933      	lsrs	r3, r6, #4
1a0019b0:	fb03 f30a 	mul.w	r3, r3, sl
1a0019b4:	448a      	add	sl, r1
1a0019b6:	fb0a f909 	mul.w	r9, sl, r9
1a0019ba:	fbb3 f9f9 	udiv	r9, r3, r9
}
1a0019be:	4648      	mov	r0, r9
1a0019c0:	b003      	add	sp, #12
1a0019c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1a0019c6:	bf00      	nop
1a0019c8:	1a00281c 	.word	0x1a00281c

1a0019cc <Board_LED_Init>:

static void Board_LED_Init()
{
   uint32_t idx;

   for (idx = 0; idx < (sizeof(gpioLEDBits) / sizeof(io_port_t)); ++idx) {
1a0019cc:	2200      	movs	r2, #0
1a0019ce:	2a05      	cmp	r2, #5
1a0019d0:	d819      	bhi.n	1a001a06 <Board_LED_Init+0x3a>
{
1a0019d2:	b470      	push	{r4, r5, r6}
       /* Set pin direction and init to off */
       Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, gpioLEDBits[idx].port, gpioLEDBits[idx].pin);
1a0019d4:	490c      	ldr	r1, [pc, #48]	; (1a001a08 <Board_LED_Init+0x3c>)
1a0019d6:	f811 5012 	ldrb.w	r5, [r1, r2, lsl #1]
1a0019da:	eb01 0142 	add.w	r1, r1, r2, lsl #1
1a0019de:	784c      	ldrb	r4, [r1, #1]
 * @param  pin     : GPIO pin to set direction on as output
 * @return Nothing
 */
STATIC INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
   pGPIO->DIR[port] |= 1UL << pin;
1a0019e0:	4b0a      	ldr	r3, [pc, #40]	; (1a001a0c <Board_LED_Init+0x40>)
1a0019e2:	f505 6600 	add.w	r6, r5, #2048	; 0x800
1a0019e6:	f853 1026 	ldr.w	r1, [r3, r6, lsl #2]
1a0019ea:	2001      	movs	r0, #1
1a0019ec:	40a0      	lsls	r0, r4
1a0019ee:	4301      	orrs	r1, r0
1a0019f0:	f843 1026 	str.w	r1, [r3, r6, lsl #2]
   pGPIO->B[port][pin] = setting;
1a0019f4:	eb03 1345 	add.w	r3, r3, r5, lsl #5
1a0019f8:	2100      	movs	r1, #0
1a0019fa:	5519      	strb	r1, [r3, r4]
   for (idx = 0; idx < (sizeof(gpioLEDBits) / sizeof(io_port_t)); ++idx) {
1a0019fc:	3201      	adds	r2, #1
1a0019fe:	2a05      	cmp	r2, #5
1a001a00:	d9e8      	bls.n	1a0019d4 <Board_LED_Init+0x8>
       Chip_GPIO_SetPinState(LPC_GPIO_PORT, gpioLEDBits[idx].port, gpioLEDBits[idx].pin, (bool) false);
   }
}
1a001a02:	bc70      	pop	{r4, r5, r6}
1a001a04:	4770      	bx	lr
1a001a06:	4770      	bx	lr
1a001a08:	1a002834 	.word	0x1a002834
1a001a0c:	400f4000 	.word	0x400f4000

1a001a10 <Board_UART_Init>:
 * @note   Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
 * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
 */
STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
{
   LPC_SCU->SFSP[port][pin] = modefunc;
1a001a10:	4b03      	ldr	r3, [pc, #12]	; (1a001a20 <Board_UART_Init+0x10>)
1a001a12:	2212      	movs	r2, #18
1a001a14:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
1a001a18:	22d1      	movs	r2, #209	; 0xd1
1a001a1a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
1a001a1e:	4770      	bx	lr
1a001a20:	40086000 	.word	0x40086000

1a001a24 <Board_Debug_Init>:
{
1a001a24:	b510      	push	{r4, lr}
   Board_UART_Init(DEBUG_UART);
1a001a26:	4c08      	ldr	r4, [pc, #32]	; (1a001a48 <Board_Debug_Init+0x24>)
1a001a28:	4620      	mov	r0, r4
1a001a2a:	f7ff fff1 	bl	1a001a10 <Board_UART_Init>
   Chip_UART_Init(DEBUG_UART);
1a001a2e:	4620      	mov	r0, r4
1a001a30:	f7ff ff0e 	bl	1a001850 <Chip_UART_Init>
   Chip_UART_SetBaudFDR(DEBUG_UART, 115200);
1a001a34:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
1a001a38:	4620      	mov	r0, r4
1a001a3a:	f7ff ff53 	bl	1a0018e4 <Chip_UART_SetBaudFDR>
   pUART->LCR = config;
1a001a3e:	2303      	movs	r3, #3
1a001a40:	60e3      	str	r3, [r4, #12]
    pUART->TER2 = UART_TER2_TXEN;
1a001a42:	2301      	movs	r3, #1
1a001a44:	65e3      	str	r3, [r4, #92]	; 0x5c
1a001a46:	bd10      	pop	{r4, pc}
1a001a48:	400c1000 	.word	0x400c1000

1a001a4c <Board_Init>:
}

/* Set up and initialize all required blocks and functions related to the
   board hardware */
void Board_Init(void)
{
1a001a4c:	b508      	push	{r3, lr}
   /* Sets up DEBUG UART */
   DEBUGINIT();
1a001a4e:	f7ff ffe9 	bl	1a001a24 <Board_Debug_Init>

   /* Initializes GPIO */
   Chip_GPIO_Init(LPC_GPIO_PORT);
1a001a52:	4806      	ldr	r0, [pc, #24]	; (1a001a6c <Board_Init+0x20>)
1a001a54:	f7ff fe26 	bl	1a0016a4 <Chip_GPIO_Init>

   /* Initialize LEDs */
   Board_LED_Init();
1a001a58:	f7ff ffb8 	bl	1a0019cc <Board_LED_Init>
 * RMII PHY, and must be called before calling any Ethernet
 * functions.
 */
STATIC INLINE void Chip_ENET_RMIIEnable(LPC_ENET_T *pENET)
{
   LPC_CREG->CREG6 |= 0x4;
1a001a5c:	4a04      	ldr	r2, [pc, #16]	; (1a001a70 <Board_Init+0x24>)
1a001a5e:	f8d2 312c 	ldr.w	r3, [r2, #300]	; 0x12c
1a001a62:	f043 0304 	orr.w	r3, r3, #4
1a001a66:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
1a001a6a:	bd08      	pop	{r3, pc}
1a001a6c:	400f4000 	.word	0x400f4000
1a001a70:	40043000 	.word	0x40043000

1a001a74 <Board_SetupMuxing>:
 * @return Nothing
 */
STATIC INLINE void Chip_SCU_SetPinMuxing(const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
{
   uint32_t ix;
   for (ix = 0; ix < arrayLength; ix++ ) {
1a001a74:	2300      	movs	r3, #0
1a001a76:	2b17      	cmp	r3, #23
1a001a78:	d812      	bhi.n	1a001aa0 <Board_SetupMuxing+0x2c>
 * Public functions
 ****************************************************************************/

/* Sets up system pin muxing */
void Board_SetupMuxing(void)
{
1a001a7a:	b410      	push	{r4}
       Chip_SCU_PinMuxSet(pinArray[ix].pingrp, pinArray[ix].pinnum, pinArray[ix].modefunc);
1a001a7c:	4a09      	ldr	r2, [pc, #36]	; (1a001aa4 <Board_SetupMuxing+0x30>)
1a001a7e:	eb02 0183 	add.w	r1, r2, r3, lsl #2
1a001a82:	f812 4023 	ldrb.w	r4, [r2, r3, lsl #2]
1a001a86:	784a      	ldrb	r2, [r1, #1]
1a001a88:	8848      	ldrh	r0, [r1, #2]
   LPC_SCU->SFSP[port][pin] = modefunc;
1a001a8a:	eb02 1244 	add.w	r2, r2, r4, lsl #5
1a001a8e:	4906      	ldr	r1, [pc, #24]	; (1a001aa8 <Board_SetupMuxing+0x34>)
1a001a90:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
   for (ix = 0; ix < arrayLength; ix++ ) {
1a001a94:	3301      	adds	r3, #1
1a001a96:	2b17      	cmp	r3, #23
1a001a98:	d9f0      	bls.n	1a001a7c <Board_SetupMuxing+0x8>
   /* Setup system level pin muxing */
   Chip_SCU_SetPinMuxing(pinmuxing, sizeof(pinmuxing) / sizeof(PINMUX_GRP_T));
}
1a001a9a:	f85d 4b04 	ldr.w	r4, [sp], #4
1a001a9e:	4770      	bx	lr
1a001aa0:	4770      	bx	lr
1a001aa2:	bf00      	nop
1a001aa4:	1a00284c 	.word	0x1a00284c
1a001aa8:	40086000 	.word	0x40086000

1a001aac <Board_SetupClocking>:

/* Set up and initialize clocking prior to call to main */
void Board_SetupClocking(void)
{
1a001aac:	b510      	push	{r4, lr}
 */
STATIC INLINE void Chip_CREG_SetFlashAcceleration(uint32_t Hz)
{
   uint32_t FAValue = Hz / 21510000;

   LPC_CREG->FLASHCFGA = (LPC_CREG->FLASHCFGA & (~(0xF << 12))) | (FAValue << 12);
1a001aae:	4a17      	ldr	r2, [pc, #92]	; (1a001b0c <Board_SetupClocking+0x60>)
1a001ab0:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
1a001ab4:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
1a001ab8:	f443 4310 	orr.w	r3, r3, #36864	; 0x9000
1a001abc:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
   LPC_CREG->FLASHCFGB = (LPC_CREG->FLASHCFGB & (~(0xF << 12))) | (FAValue << 12);
1a001ac0:	f8d2 3124 	ldr.w	r3, [r2, #292]	; 0x124
1a001ac4:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
1a001ac8:	f443 4310 	orr.w	r3, r3, #36864	; 0x9000
1a001acc:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124

   /* Enable Flash acceleration and setup wait states */
   Chip_CREG_SetFlashAcceleration(MAX_CLOCK_FREQ);

   /* Setup System core frequency to MAX_CLOCK_FREQ */
   Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);
1a001ad0:	2201      	movs	r2, #1
1a001ad2:	490f      	ldr	r1, [pc, #60]	; (1a001b10 <Board_SetupClocking+0x64>)
1a001ad4:	2006      	movs	r0, #6
1a001ad6:	f7ff fdf9 	bl	1a0016cc <Chip_SetupCoreClock>

   /* Setup system base clocks and initial states. This won't enable and
      disable individual clocks, but sets up the base clock sources for
      each individual peripheral clock. */
   for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a001ada:	2400      	movs	r4, #0
1a001adc:	e00a      	b.n	1a001af4 <Board_SetupClocking+0x48>
       Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
1a001ade:	480d      	ldr	r0, [pc, #52]	; (1a001b14 <Board_SetupClocking+0x68>)
1a001ae0:	eb00 0184 	add.w	r1, r0, r4, lsl #2
1a001ae4:	78cb      	ldrb	r3, [r1, #3]
1a001ae6:	788a      	ldrb	r2, [r1, #2]
1a001ae8:	7849      	ldrb	r1, [r1, #1]
1a001aea:	f810 0024 	ldrb.w	r0, [r0, r4, lsl #2]
1a001aee:	f7ff fd25 	bl	1a00153c <Chip_Clock_SetBaseClock>
   for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a001af2:	3401      	adds	r4, #1
1a001af4:	2c02      	cmp	r4, #2
1a001af6:	d9f2      	bls.n	1a001ade <Board_SetupClocking+0x32>
                               InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
   }

   /* Reset and enable 32Khz oscillator */
   LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));
1a001af8:	4b04      	ldr	r3, [pc, #16]	; (1a001b0c <Board_SetupClocking+0x60>)
1a001afa:	685a      	ldr	r2, [r3, #4]
1a001afc:	f022 020c 	bic.w	r2, r2, #12
1a001b00:	605a      	str	r2, [r3, #4]
   LPC_CREG->CREG0 |= (1 << 1) | (1 << 0);
1a001b02:	685a      	ldr	r2, [r3, #4]
1a001b04:	f042 0203 	orr.w	r2, r2, #3
1a001b08:	605a      	str	r2, [r3, #4]
1a001b0a:	bd10      	pop	{r4, pc}
1a001b0c:	40043000 	.word	0x40043000
1a001b10:	0c28cb00 	.word	0x0c28cb00
1a001b14:	1a002840 	.word	0x1a002840

1a001b18 <Board_SystemInit>:
}

/* Set up and initialize hardware prior to call to main */
void Board_SystemInit(void)
{
1a001b18:	b508      	push	{r3, lr}
   /* Setup system clocking and memory. This is done early to allow the
      application and tools to clear memory and use scatter loading to
      external memory. */
   Board_SetupMuxing();
1a001b1a:	f7ff ffab 	bl	1a001a74 <Board_SetupMuxing>
   Board_SetupClocking();
1a001b1e:	f7ff ffc5 	bl	1a001aac <Board_SetupClocking>
1a001b22:	bd08      	pop	{r3, pc}

1a001b24 <ResetISR>:
void ResetISR(void) {
1a001b24:	b510      	push	{r4, lr}
    __asm volatile ("cpsid i");
1a001b26:	b672      	cpsid	i
    *(RESET_CONTROL + 0) = 0x10DF1000;
1a001b28:	4a16      	ldr	r2, [pc, #88]	; (1a001b84 <ResetISR+0x60>)
1a001b2a:	4b17      	ldr	r3, [pc, #92]	; (1a001b88 <ResetISR+0x64>)
1a001b2c:	601a      	str	r2, [r3, #0]
    *(RESET_CONTROL + 1) = 0x01DFF7FF;
1a001b2e:	4a17      	ldr	r2, [pc, #92]	; (1a001b8c <ResetISR+0x68>)
1a001b30:	3304      	adds	r3, #4
1a001b32:	601a      	str	r2, [r3, #0]
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
1a001b34:	2300      	movs	r3, #0
1a001b36:	e005      	b.n	1a001b44 <ResetISR+0x20>
        *(NVIC_ICPR + irqpendloop) = 0xFFFFFFFF;
1a001b38:	f04f 31ff 	mov.w	r1, #4294967295
1a001b3c:	4a14      	ldr	r2, [pc, #80]	; (1a001b90 <ResetISR+0x6c>)
1a001b3e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
1a001b42:	3301      	adds	r3, #1
1a001b44:	2b07      	cmp	r3, #7
1a001b46:	d9f7      	bls.n	1a001b38 <ResetISR+0x14>
    __asm volatile ("cpsie i");
1a001b48:	b662      	cpsie	i
    SystemInit();
1a001b4a:	f000 f829 	bl	1a001ba0 <SystemInit>
    SectionTableAddr = &__data_section_table;
1a001b4e:	4b11      	ldr	r3, [pc, #68]	; (1a001b94 <ResetISR+0x70>)
    while (SectionTableAddr < &__data_section_table_end) {
1a001b50:	e007      	b.n	1a001b62 <ResetISR+0x3e>
        SectionLen = *SectionTableAddr++;
1a001b52:	f103 040c 	add.w	r4, r3, #12
        data_init(LoadAddr, ExeAddr, SectionLen);
1a001b56:	689a      	ldr	r2, [r3, #8]
1a001b58:	6859      	ldr	r1, [r3, #4]
1a001b5a:	6818      	ldr	r0, [r3, #0]
1a001b5c:	f7fe fb16 	bl	1a00018c <data_init>
        SectionLen = *SectionTableAddr++;
1a001b60:	4623      	mov	r3, r4
    while (SectionTableAddr < &__data_section_table_end) {
1a001b62:	4a0d      	ldr	r2, [pc, #52]	; (1a001b98 <ResetISR+0x74>)
1a001b64:	4293      	cmp	r3, r2
1a001b66:	d3f4      	bcc.n	1a001b52 <ResetISR+0x2e>
1a001b68:	e006      	b.n	1a001b78 <ResetISR+0x54>
        ExeAddr = *SectionTableAddr++;
1a001b6a:	461c      	mov	r4, r3
        bss_init(ExeAddr, SectionLen);
1a001b6c:	6859      	ldr	r1, [r3, #4]
1a001b6e:	f854 0b08 	ldr.w	r0, [r4], #8
1a001b72:	f7fe fb1a 	bl	1a0001aa <bss_init>
        SectionLen = *SectionTableAddr++;
1a001b76:	4623      	mov	r3, r4
    while (SectionTableAddr < &__bss_section_table_end) {
1a001b78:	4a08      	ldr	r2, [pc, #32]	; (1a001b9c <ResetISR+0x78>)
1a001b7a:	4293      	cmp	r3, r2
1a001b7c:	d3f5      	bcc.n	1a001b6a <ResetISR+0x46>
    main();
1a001b7e:	f7fe fbc5 	bl	1a00030c <main>
1a001b82:	e7fe      	b.n	1a001b82 <ResetISR+0x5e>
1a001b84:	10df1000 	.word	0x10df1000
1a001b88:	40053100 	.word	0x40053100
1a001b8c:	01dff7ff 	.word	0x01dff7ff
1a001b90:	e000e280 	.word	0xe000e280
1a001b94:	1a000114 	.word	0x1a000114
1a001b98:	1a000150 	.word	0x1a000150
1a001b9c:	1a000178 	.word	0x1a000178

1a001ba0 <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
1a001ba0:	b508      	push	{r3, lr}

   *pSCB_VTOR = (unsigned int) &__Vectors;
#endif

#if defined(__FPU_PRESENT) && __FPU_PRESENT == 1
   fpuInit();
1a001ba2:	f7ff fd55 	bl	1a001650 <fpuInit>
#if defined(NO_BOARD_LIB)
   /* Chip specific SystemInit */
   Chip_SystemInit();
#else
   /* Board specific SystemInit */
   Board_SystemInit();
1a001ba6:	f7ff ffb7 	bl	1a001b18 <Board_SystemInit>
1a001baa:	bd08      	pop	{r3, pc}

1a001bac <boardConfig>:
/*==================[internal functions definition]==========================*/

/*==================[external functions definition]==========================*/

/* Set up and initialize board hardware */
void boardConfig(void) {
1a001bac:	b508      	push	{r3, lr}

   /* Read clock settings and update SystemCoreClock variable */
   SystemCoreClockUpdate();
1a001bae:	f7ff fa9f 	bl	1a0010f0 <SystemCoreClockUpdate>

   Board_Init(); // From Board module (modules/lpc4337_m4/board)
1a001bb2:	f7ff ff4b 	bl	1a001a4c <Board_Init>

   /* Inicializar el conteo de Ticks con resoluci贸n de 1ms, sin tickHook */
   tickConfig( 1, 0 );
1a001bb6:	2200      	movs	r2, #0
1a001bb8:	2001      	movs	r0, #1
1a001bba:	2100      	movs	r1, #0
1a001bbc:	f000 f9d4 	bl	1a001f68 <tickConfig>

   /* Inicializar GPIOs */
   gpioConfig( 0, GPIO_ENABLE );
1a001bc0:	2105      	movs	r1, #5
1a001bc2:	2000      	movs	r0, #0
1a001bc4:	f000 f8b6 	bl	1a001d34 <gpioConfig>

   /* Configuraci贸n de pines de entrada para Teclas de la EDU-CIAA-NXP */
   gpioConfig( TEC1, GPIO_INPUT );
1a001bc8:	2100      	movs	r1, #0
1a001bca:	2024      	movs	r0, #36	; 0x24
1a001bcc:	f000 f8b2 	bl	1a001d34 <gpioConfig>
   gpioConfig( TEC2, GPIO_INPUT );
1a001bd0:	2100      	movs	r1, #0
1a001bd2:	2025      	movs	r0, #37	; 0x25
1a001bd4:	f000 f8ae 	bl	1a001d34 <gpioConfig>
   gpioConfig( TEC3, GPIO_INPUT );
1a001bd8:	2100      	movs	r1, #0
1a001bda:	2026      	movs	r0, #38	; 0x26
1a001bdc:	f000 f8aa 	bl	1a001d34 <gpioConfig>
   gpioConfig( TEC4, GPIO_INPUT );
1a001be0:	2100      	movs	r1, #0
1a001be2:	2027      	movs	r0, #39	; 0x27
1a001be4:	f000 f8a6 	bl	1a001d34 <gpioConfig>

   /* Configuraci贸n de pines de salida para Leds de la EDU-CIAA-NXP */
   gpioConfig( LEDR, GPIO_OUTPUT );
1a001be8:	2101      	movs	r1, #1
1a001bea:	2028      	movs	r0, #40	; 0x28
1a001bec:	f000 f8a2 	bl	1a001d34 <gpioConfig>
   gpioConfig( LEDG, GPIO_OUTPUT );
1a001bf0:	2101      	movs	r1, #1
1a001bf2:	2029      	movs	r0, #41	; 0x29
1a001bf4:	f000 f89e 	bl	1a001d34 <gpioConfig>
   gpioConfig( LEDB, GPIO_OUTPUT );
1a001bf8:	2101      	movs	r1, #1
1a001bfa:	202a      	movs	r0, #42	; 0x2a
1a001bfc:	f000 f89a 	bl	1a001d34 <gpioConfig>
   gpioConfig( LED1, GPIO_OUTPUT );
1a001c00:	2101      	movs	r1, #1
1a001c02:	202b      	movs	r0, #43	; 0x2b
1a001c04:	f000 f896 	bl	1a001d34 <gpioConfig>
   gpioConfig( LED2, GPIO_OUTPUT );
1a001c08:	2101      	movs	r1, #1
1a001c0a:	202c      	movs	r0, #44	; 0x2c
1a001c0c:	f000 f892 	bl	1a001d34 <gpioConfig>
   gpioConfig( LED3, GPIO_OUTPUT );
1a001c10:	2101      	movs	r1, #1
1a001c12:	202d      	movs	r0, #45	; 0x2d
1a001c14:	f000 f88e 	bl	1a001d34 <gpioConfig>


   /* Configuraci贸n de pines de entrada de la CIAA-NXP */
   gpioConfig( DI0, GPIO_INPUT );
1a001c18:	2100      	movs	r1, #0
1a001c1a:	202e      	movs	r0, #46	; 0x2e
1a001c1c:	f000 f88a 	bl	1a001d34 <gpioConfig>
   gpioConfig( DI1, GPIO_INPUT );
1a001c20:	2100      	movs	r1, #0
1a001c22:	202f      	movs	r0, #47	; 0x2f
1a001c24:	f000 f886 	bl	1a001d34 <gpioConfig>
   gpioConfig( DI2, GPIO_INPUT );
1a001c28:	2100      	movs	r1, #0
1a001c2a:	2030      	movs	r0, #48	; 0x30
1a001c2c:	f000 f882 	bl	1a001d34 <gpioConfig>
   gpioConfig( DI3, GPIO_INPUT );
1a001c30:	2100      	movs	r1, #0
1a001c32:	2031      	movs	r0, #49	; 0x31
1a001c34:	f000 f87e 	bl	1a001d34 <gpioConfig>
   gpioConfig( DI4, GPIO_INPUT );
1a001c38:	2100      	movs	r1, #0
1a001c3a:	2032      	movs	r0, #50	; 0x32
1a001c3c:	f000 f87a 	bl	1a001d34 <gpioConfig>
   gpioConfig( DI5, GPIO_INPUT );
1a001c40:	2100      	movs	r1, #0
1a001c42:	2033      	movs	r0, #51	; 0x33
1a001c44:	f000 f876 	bl	1a001d34 <gpioConfig>
   gpioConfig( DI6, GPIO_INPUT );
1a001c48:	2100      	movs	r1, #0
1a001c4a:	2034      	movs	r0, #52	; 0x34
1a001c4c:	f000 f872 	bl	1a001d34 <gpioConfig>
   gpioConfig( DI7, GPIO_INPUT );
1a001c50:	2100      	movs	r1, #0
1a001c52:	2035      	movs	r0, #53	; 0x35
1a001c54:	f000 f86e 	bl	1a001d34 <gpioConfig>

   /* Configuraci贸n de pines de salida de la CIAA-NXP */
   gpioConfig( DO0, GPIO_OUTPUT );
1a001c58:	2101      	movs	r1, #1
1a001c5a:	2036      	movs	r0, #54	; 0x36
1a001c5c:	f000 f86a 	bl	1a001d34 <gpioConfig>
   gpioConfig( DO1, GPIO_OUTPUT );
1a001c60:	2101      	movs	r1, #1
1a001c62:	2037      	movs	r0, #55	; 0x37
1a001c64:	f000 f866 	bl	1a001d34 <gpioConfig>
   gpioConfig( DO2, GPIO_OUTPUT );
1a001c68:	2101      	movs	r1, #1
1a001c6a:	2038      	movs	r0, #56	; 0x38
1a001c6c:	f000 f862 	bl	1a001d34 <gpioConfig>
   gpioConfig( DO3, GPIO_OUTPUT );
1a001c70:	2101      	movs	r1, #1
1a001c72:	2039      	movs	r0, #57	; 0x39
1a001c74:	f000 f85e 	bl	1a001d34 <gpioConfig>
   gpioConfig( DO4, GPIO_OUTPUT );
1a001c78:	2101      	movs	r1, #1
1a001c7a:	203a      	movs	r0, #58	; 0x3a
1a001c7c:	f000 f85a 	bl	1a001d34 <gpioConfig>
   gpioConfig( DO5, GPIO_OUTPUT );
1a001c80:	2101      	movs	r1, #1
1a001c82:	203b      	movs	r0, #59	; 0x3b
1a001c84:	f000 f856 	bl	1a001d34 <gpioConfig>
   gpioConfig( DO6, GPIO_OUTPUT );
1a001c88:	2101      	movs	r1, #1
1a001c8a:	203c      	movs	r0, #60	; 0x3c
1a001c8c:	f000 f852 	bl	1a001d34 <gpioConfig>
   gpioConfig( DO7, GPIO_OUTPUT );
1a001c90:	2101      	movs	r1, #1
1a001c92:	203d      	movs	r0, #61	; 0x3d
1a001c94:	f000 f84e 	bl	1a001d34 <gpioConfig>
1a001c98:	bd08      	pop	{r3, pc}

1a001c9a <sAPI_NullFuncPtr>:
 * param:  void * - Not used
 * return: bool_t - Return always true
 */
bool_t sAPI_NullFuncPtr(void *ptr){
   return 1;
}
1a001c9a:	2001      	movs	r0, #1
1a001c9c:	4770      	bx	lr
1a001c9e:	Address 0x1a001c9e is out of bounds.


1a001ca0 <delayConfig>:
 }


/* ---- Non Blocking Delay ---- */

void delayConfig( delay_t * delay, tick_t duration ){
1a001ca0:	b510      	push	{r4, lr}
1a001ca2:	4604      	mov	r4, r0
1a001ca4:	4610      	mov	r0, r2
1a001ca6:	4619      	mov	r1, r3
   delay->duration = duration/tickRateMS;
1a001ca8:	4b04      	ldr	r3, [pc, #16]	; (1a001cbc <delayConfig+0x1c>)
1a001caa:	e9d3 2300 	ldrd	r2, r3, [r3]
1a001cae:	f000 fa8d 	bl	1a0021cc <__aeabi_uldivmod>
1a001cb2:	e9c4 0102 	strd	r0, r1, [r4, #8]
   delay->running = 0;
1a001cb6:	2300      	movs	r3, #0
1a001cb8:	7423      	strb	r3, [r4, #16]
1a001cba:	bd10      	pop	{r4, pc}
1a001cbc:	10000168 	.word	0x10000168

1a001cc0 <delayRead>:
}

bool_t delayRead( delay_t * delay ){
1a001cc0:	b538      	push	{r3, r4, r5, lr}
1a001cc2:	4604      	mov	r4, r0

   bool_t timeArrived = 0;

   if( !delay->running ){
1a001cc4:	7c05      	ldrb	r5, [r0, #16]
1a001cc6:	b185      	cbz	r5, 1a001cea <delayRead+0x2a>
      delay->startTime = tickRead();
      delay->running = 1;
   }
   else{
      if ( (tickRead() - delay->startTime) >= delay->duration ){
1a001cc8:	f000 f98a 	bl	1a001fe0 <tickRead>
1a001ccc:	e9d4 2300 	ldrd	r2, r3, [r4]
1a001cd0:	1a80      	subs	r0, r0, r2
1a001cd2:	eb61 0103 	sbc.w	r1, r1, r3
1a001cd6:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
1a001cda:	4299      	cmp	r1, r3
1a001cdc:	bf08      	it	eq
1a001cde:	4290      	cmpeq	r0, r2
1a001ce0:	d30b      	bcc.n	1a001cfa <delayRead+0x3a>
         timeArrived = 1;
         delay->running = 0;
1a001ce2:	2300      	movs	r3, #0
1a001ce4:	7423      	strb	r3, [r4, #16]
         timeArrived = 1;
1a001ce6:	2501      	movs	r5, #1
1a001ce8:	e005      	b.n	1a001cf6 <delayRead+0x36>
      delay->startTime = tickRead();
1a001cea:	f000 f979 	bl	1a001fe0 <tickRead>
1a001cee:	e9c4 0100 	strd	r0, r1, [r4]
      delay->running = 1;
1a001cf2:	2301      	movs	r3, #1
1a001cf4:	7423      	strb	r3, [r4, #16]
      }
   }

   return timeArrived;
}
1a001cf6:	4628      	mov	r0, r5
1a001cf8:	bd38      	pop	{r3, r4, r5, pc}
   bool_t timeArrived = 0;
1a001cfa:	2500      	movs	r5, #0
1a001cfc:	e7fb      	b.n	1a001cf6 <delayRead+0x36>
1a001cfe:	Address 0x1a001cfe is out of bounds.


1a001d00 <gpioObtainPinConfig>:
/*==================[internal functions definition]==========================*/

static void gpioObtainPinConfig( gpioMap_t pin,
                                int8_t *pinNamePort, int8_t *pinNamePin,
																int8_t *func, int8_t *gpioPort,
																int8_t *gpioPin ){
1a001d00:	b430      	push	{r4, r5}

   *pinNamePort = gpioPinsConfig[pin].pinName.port;
1a001d02:	4d0b      	ldr	r5, [pc, #44]	; (1a001d30 <gpioObtainPinConfig+0x30>)
1a001d04:	eb00 0080 	add.w	r0, r0, r0, lsl #2
1a001d08:	182c      	adds	r4, r5, r0
1a001d0a:	5628      	ldrsb	r0, [r5, r0]
1a001d0c:	7008      	strb	r0, [r1, #0]
   *pinNamePin  = gpioPinsConfig[pin].pinName.pin;
1a001d0e:	f994 1001 	ldrsb.w	r1, [r4, #1]
1a001d12:	7011      	strb	r1, [r2, #0]
   *func        = gpioPinsConfig[pin].func;
1a001d14:	f994 2002 	ldrsb.w	r2, [r4, #2]
1a001d18:	701a      	strb	r2, [r3, #0]
   *gpioPort    = gpioPinsConfig[pin].gpio.port;
1a001d1a:	f994 2003 	ldrsb.w	r2, [r4, #3]
1a001d1e:	9b02      	ldr	r3, [sp, #8]
1a001d20:	701a      	strb	r2, [r3, #0]
   *gpioPin     = gpioPinsConfig[pin].gpio.pin;
1a001d22:	f994 2004 	ldrsb.w	r2, [r4, #4]
1a001d26:	9b03      	ldr	r3, [sp, #12]
1a001d28:	701a      	strb	r2, [r3, #0]
}
1a001d2a:	bc30      	pop	{r4, r5}
1a001d2c:	4770      	bx	lr
1a001d2e:	bf00      	nop
1a001d30:	1a0028ac 	.word	0x1a0028ac

1a001d34 <gpioConfig>:

/*==================[external functions definition]==========================*/

bool_t gpioConfig( gpioMap_t pin, gpioConfig_t config ){
1a001d34:	b530      	push	{r4, r5, lr}
1a001d36:	b085      	sub	sp, #20
1a001d38:	460c      	mov	r4, r1

   bool_t ret_val     = 1;

   int8_t pinNamePort = 0;
1a001d3a:	2300      	movs	r3, #0
1a001d3c:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a001d40:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a001d44:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a001d48:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a001d4c:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a001d50:	f10d 030b 	add.w	r3, sp, #11
1a001d54:	9301      	str	r3, [sp, #4]
1a001d56:	ab03      	add	r3, sp, #12
1a001d58:	9300      	str	r3, [sp, #0]
1a001d5a:	f10d 030d 	add.w	r3, sp, #13
1a001d5e:	f10d 020e 	add.w	r2, sp, #14
1a001d62:	f10d 010f 	add.w	r1, sp, #15
1a001d66:	f7ff ffcb 	bl	1a001d00 <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   switch(config){
1a001d6a:	2c05      	cmp	r4, #5
1a001d6c:	f200 8096 	bhi.w	1a001e9c <gpioConfig+0x168>
1a001d70:	e8df f004 	tbb	[pc, r4]
1a001d74:	3d237109 	.word	0x3d237109
1a001d78:	0357      	.short	0x0357

      case GPIO_ENABLE:
		   /* Initializes GPIO */
		   Chip_GPIO_Init(LPC_GPIO_PORT);
1a001d7a:	4849      	ldr	r0, [pc, #292]	; (1a001ea0 <gpioConfig+0x16c>)
1a001d7c:	f7ff fc92 	bl	1a0016a4 <Chip_GPIO_Init>
   bool_t ret_val     = 1;
1a001d80:	2001      	movs	r0, #1
      break;
   }

   return ret_val;

}
1a001d82:	b005      	add	sp, #20
1a001d84:	bd30      	pop	{r4, r5, pc}
         Chip_SCU_PinMux(
1a001d86:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001d8a:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001d8e:	f89d 200d 	ldrb.w	r2, [sp, #13]
   LPC_SCU->SFSP[port][pin] = modefunc;
1a001d92:	f042 02d0 	orr.w	r2, r2, #208	; 0xd0
1a001d96:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001d9a:	4942      	ldr	r1, [pc, #264]	; (1a001ea4 <gpioConfig+0x170>)
1a001d9c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a001da0:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001da4:	2401      	movs	r4, #1
1a001da6:	2300      	movs	r3, #0
1a001da8:	fa04 f202 	lsl.w	r2, r4, r2
1a001dac:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001db0:	483b      	ldr	r0, [pc, #236]	; (1a001ea0 <gpioConfig+0x16c>)
1a001db2:	f7ff fc78 	bl	1a0016a6 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a001db6:	4620      	mov	r0, r4
      break;
1a001db8:	e7e3      	b.n	1a001d82 <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a001dba:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001dbe:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001dc2:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a001dc6:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
1a001dca:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001dce:	4935      	ldr	r1, [pc, #212]	; (1a001ea4 <gpioConfig+0x170>)
1a001dd0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a001dd4:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001dd8:	2401      	movs	r4, #1
1a001dda:	2300      	movs	r3, #0
1a001ddc:	fa04 f202 	lsl.w	r2, r4, r2
1a001de0:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001de4:	482e      	ldr	r0, [pc, #184]	; (1a001ea0 <gpioConfig+0x16c>)
1a001de6:	f7ff fc5e 	bl	1a0016a6 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a001dea:	4620      	mov	r0, r4
      break;
1a001dec:	e7c9      	b.n	1a001d82 <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a001dee:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001df2:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001df6:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a001dfa:	f042 02d8 	orr.w	r2, r2, #216	; 0xd8
1a001dfe:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001e02:	4928      	ldr	r1, [pc, #160]	; (1a001ea4 <gpioConfig+0x170>)
1a001e04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a001e08:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001e0c:	2401      	movs	r4, #1
1a001e0e:	2300      	movs	r3, #0
1a001e10:	fa04 f202 	lsl.w	r2, r4, r2
1a001e14:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001e18:	4821      	ldr	r0, [pc, #132]	; (1a001ea0 <gpioConfig+0x16c>)
1a001e1a:	f7ff fc44 	bl	1a0016a6 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a001e1e:	4620      	mov	r0, r4
      break;
1a001e20:	e7af      	b.n	1a001d82 <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a001e22:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001e26:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001e2a:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a001e2e:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
1a001e32:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001e36:	491b      	ldr	r1, [pc, #108]	; (1a001ea4 <gpioConfig+0x170>)
1a001e38:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a001e3c:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001e40:	2401      	movs	r4, #1
1a001e42:	2300      	movs	r3, #0
1a001e44:	fa04 f202 	lsl.w	r2, r4, r2
1a001e48:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001e4c:	4814      	ldr	r0, [pc, #80]	; (1a001ea0 <gpioConfig+0x16c>)
1a001e4e:	f7ff fc2a 	bl	1a0016a6 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a001e52:	4620      	mov	r0, r4
      break;
1a001e54:	e795      	b.n	1a001d82 <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a001e56:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001e5a:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001e5e:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a001e62:	f042 02d0 	orr.w	r2, r2, #208	; 0xd0
1a001e66:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001e6a:	490e      	ldr	r1, [pc, #56]	; (1a001ea4 <gpioConfig+0x170>)
1a001e6c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_OUTPUT );
1a001e70:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001e74:	2401      	movs	r4, #1
1a001e76:	4d0a      	ldr	r5, [pc, #40]	; (1a001ea0 <gpioConfig+0x16c>)
1a001e78:	4623      	mov	r3, r4
1a001e7a:	fa04 f202 	lsl.w	r2, r4, r2
1a001e7e:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001e82:	4628      	mov	r0, r5
1a001e84:	f7ff fc0f 	bl	1a0016a6 <Chip_GPIO_SetDir>
         Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, 0);
1a001e88:	f89d 200c 	ldrb.w	r2, [sp, #12]
1a001e8c:	f89d 300b 	ldrb.w	r3, [sp, #11]
1a001e90:	eb05 1542 	add.w	r5, r5, r2, lsl #5
1a001e94:	2200      	movs	r2, #0
1a001e96:	54ea      	strb	r2, [r5, r3]
   bool_t ret_val     = 1;
1a001e98:	4620      	mov	r0, r4
1a001e9a:	e772      	b.n	1a001d82 <gpioConfig+0x4e>
         ret_val = 0;
1a001e9c:	2000      	movs	r0, #0
1a001e9e:	e770      	b.n	1a001d82 <gpioConfig+0x4e>
1a001ea0:	400f4000 	.word	0x400f4000
1a001ea4:	40086000 	.word	0x40086000

1a001ea8 <gpioWrite>:


bool_t gpioWrite( gpioMap_t pin, bool_t value ){
1a001ea8:	b510      	push	{r4, lr}
1a001eaa:	b084      	sub	sp, #16
1a001eac:	460c      	mov	r4, r1

   bool_t ret_val     = 1;

   int8_t pinNamePort = 0;
1a001eae:	2300      	movs	r3, #0
1a001eb0:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a001eb4:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a001eb8:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a001ebc:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a001ec0:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a001ec4:	f10d 030b 	add.w	r3, sp, #11
1a001ec8:	9301      	str	r3, [sp, #4]
1a001eca:	ab03      	add	r3, sp, #12
1a001ecc:	9300      	str	r3, [sp, #0]
1a001ece:	f10d 030d 	add.w	r3, sp, #13
1a001ed2:	f10d 020e 	add.w	r2, sp, #14
1a001ed6:	f10d 010f 	add.w	r1, sp, #15
1a001eda:	f7ff ff11 	bl	1a001d00 <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, value);
1a001ede:	f89d 300c 	ldrb.w	r3, [sp, #12]
1a001ee2:	f89d 200b 	ldrb.w	r2, [sp, #11]
1a001ee6:	3400      	adds	r4, #0
1a001ee8:	bf18      	it	ne
1a001eea:	2401      	movne	r4, #1
1a001eec:	015b      	lsls	r3, r3, #5
1a001eee:	f103 2340 	add.w	r3, r3, #1073758208	; 0x40004000
1a001ef2:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
1a001ef6:	549c      	strb	r4, [r3, r2]

   return ret_val;
}
1a001ef8:	2001      	movs	r0, #1
1a001efa:	b004      	add	sp, #16
1a001efc:	bd10      	pop	{r4, pc}

1a001efe <gpioRead>:

   return gpioWrite( pin, !gpioRead(pin) );
}


bool_t gpioRead( gpioMap_t pin ){
1a001efe:	b500      	push	{lr}
1a001f00:	b085      	sub	sp, #20

   bool_t ret_val     = OFF;

   int8_t pinNamePort = 0;
1a001f02:	2300      	movs	r3, #0
1a001f04:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a001f08:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a001f0c:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a001f10:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a001f14:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a001f18:	f10d 030b 	add.w	r3, sp, #11
1a001f1c:	9301      	str	r3, [sp, #4]
1a001f1e:	ab03      	add	r3, sp, #12
1a001f20:	9300      	str	r3, [sp, #0]
1a001f22:	f10d 030d 	add.w	r3, sp, #13
1a001f26:	f10d 020e 	add.w	r2, sp, #14
1a001f2a:	f10d 010f 	add.w	r1, sp, #15
1a001f2e:	f7ff fee7 	bl	1a001d00 <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   ret_val = (bool_t) Chip_GPIO_ReadPortBit( LPC_GPIO_PORT, gpioPort, gpioPin );
1a001f32:	f99d 300c 	ldrsb.w	r3, [sp, #12]
1a001f36:	f89d 200b 	ldrb.w	r2, [sp, #11]
   return (bool) pGPIO->B[port][pin];
1a001f3a:	015b      	lsls	r3, r3, #5
1a001f3c:	f103 2340 	add.w	r3, r3, #1073758208	; 0x40004000
1a001f40:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
1a001f44:	5c98      	ldrb	r0, [r3, r2]

   return ret_val;
}
1a001f46:	3000      	adds	r0, #0
1a001f48:	bf18      	it	ne
1a001f4a:	2001      	movne	r0, #1
1a001f4c:	b005      	add	sp, #20
1a001f4e:	f85d fb04 	ldr.w	pc, [sp], #4

1a001f52 <gpioToggle>:
bool_t gpioToggle( gpioMap_t pin ){
1a001f52:	b510      	push	{r4, lr}
1a001f54:	4604      	mov	r4, r0
   return gpioWrite( pin, !gpioRead(pin) );
1a001f56:	f7ff ffd2 	bl	1a001efe <gpioRead>
1a001f5a:	fab0 f180 	clz	r1, r0
1a001f5e:	0949      	lsrs	r1, r1, #5
1a001f60:	4620      	mov	r0, r4
1a001f62:	f7ff ffa1 	bl	1a001ea8 <gpioWrite>
}
1a001f66:	bd10      	pop	{r4, pc}

1a001f68 <tickConfig>:
/*==================[internal functions definition]==========================*/

/*==================[external functions definition]==========================*/

/* Tick rate configuration 1 to 50 ms */
bool_t tickConfig(tick_t tickRateMSvalue, sAPI_FuncPtr_t tickHook ) {
1a001f68:	b508      	push	{r3, lr}

   bool_t ret_val = 1;
   tick_t tickRateHz = 0;

   if( tickHook ){
1a001f6a:	b112      	cbz	r2, 1a001f72 <tickConfig+0xa>
1a001f6c:	4613      	mov	r3, r2
      tickHookFunction = tickHook;
1a001f6e:	4a17      	ldr	r2, [pc, #92]	; (1a001fcc <tickConfig+0x64>)
1a001f70:	6013      	str	r3, [r2, #0]
   }

   if( (tickRateMSvalue >= 1) && (tickRateMSvalue <= 50) ){
1a001f72:	f110 32ff 	adds.w	r2, r0, #4294967295
1a001f76:	f141 33ff 	adc.w	r3, r1, #4294967295
1a001f7a:	2b00      	cmp	r3, #0
1a001f7c:	bf08      	it	eq
1a001f7e:	2a32      	cmpeq	r2, #50	; 0x32
1a001f80:	d220      	bcs.n	1a001fc4 <tickConfig+0x5c>
1a001f82:	4602      	mov	r2, r0
1a001f84:	460b      	mov	r3, r1

		tickRateMS = tickRateMSvalue;
1a001f86:	4912      	ldr	r1, [pc, #72]	; (1a001fd0 <tickConfig+0x68>)
1a001f88:	e9c1 2300 	strd	r2, r3, [r1]
      tickRateHz = 1000 => 1000 ticks per second =>  1 ms tick
      tickRateHz =  200 =>  200 ticks per second =>  5 ms tick
      tickRateHz =  100 =>  100 ticks per second => 10 ms tick
      tickRateHz =   20 =>   20 ticks per second => 50 ms tick
      */
      tickRateHz = 1000 / tickRateMSvalue;
1a001f8c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
1a001f90:	2100      	movs	r1, #0
1a001f92:	f000 f91b 	bl	1a0021cc <__aeabi_uldivmod>

      /* Init SysTick interrupt, tickRateHz ticks per second */
      SysTick_Config( SystemCoreClock / tickRateHz);
1a001f96:	4602      	mov	r2, r0
1a001f98:	460b      	mov	r3, r1
1a001f9a:	490e      	ldr	r1, [pc, #56]	; (1a001fd4 <tickConfig+0x6c>)
1a001f9c:	6808      	ldr	r0, [r1, #0]
1a001f9e:	2100      	movs	r1, #0
1a001fa0:	f000 f914 	bl	1a0021cc <__aeabi_uldivmod>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
1a001fa4:	3801      	subs	r0, #1
1a001fa6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
1a001faa:	d20d      	bcs.n	1a001fc8 <tickConfig+0x60>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
1a001fac:	4b0a      	ldr	r3, [pc, #40]	; (1a001fd8 <tickConfig+0x70>)
1a001fae:	6058      	str	r0, [r3, #4]
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
1a001fb0:	21e0      	movs	r1, #224	; 0xe0
1a001fb2:	4a0a      	ldr	r2, [pc, #40]	; (1a001fdc <tickConfig+0x74>)
1a001fb4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
1a001fb8:	2200      	movs	r2, #0
1a001fba:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
1a001fbc:	2207      	movs	r2, #7
1a001fbe:	601a      	str	r2, [r3, #0]
   bool_t ret_val = 1;
1a001fc0:	2001      	movs	r0, #1
1a001fc2:	bd08      	pop	{r3, pc}
   }
   else{
      /* Error, tickRateMS variable not in range (1 <= tickRateMS <= 50) */
      ret_val = 0;
1a001fc4:	2000      	movs	r0, #0
1a001fc6:	bd08      	pop	{r3, pc}
   bool_t ret_val = 1;
1a001fc8:	2001      	movs	r0, #1
   }

   return ret_val;
}
1a001fca:	bd08      	pop	{r3, pc}
1a001fcc:	10000004 	.word	0x10000004
1a001fd0:	10000168 	.word	0x10000168
1a001fd4:	10000158 	.word	0x10000158
1a001fd8:	e000e010 	.word	0xe000e010
1a001fdc:	e000ed00 	.word	0xe000ed00

1a001fe0 <tickRead>:


/* Read Tick Counter */
tick_t tickRead( void ) {
   return tickCounter;
}
1a001fe0:	4b01      	ldr	r3, [pc, #4]	; (1a001fe8 <tickRead+0x8>)
1a001fe2:	e9d3 0100 	ldrd	r0, r1, [r3]
1a001fe6:	4770      	bx	lr
1a001fe8:	10000160 	.word	0x10000160

1a001fec <SysTick_Handler>:
/*==================[ISR external functions definition]======================*/

//__attribute__ ((section(".after_vectors")))

/* SysTick Timer ISR Handler */
void SysTick_Handler(void) {
1a001fec:	b508      	push	{r3, lr}
   tickCounter++;
1a001fee:	4906      	ldr	r1, [pc, #24]	; (1a002008 <SysTick_Handler+0x1c>)
1a001ff0:	e9d1 2300 	ldrd	r2, r3, [r1]
1a001ff4:	3201      	adds	r2, #1
1a001ff6:	f143 0300 	adc.w	r3, r3, #0
1a001ffa:	e9c1 2300 	strd	r2, r3, [r1]

	/* Execute Tick Hook function */
	(* tickHookFunction )( 0 );
1a001ffe:	4b03      	ldr	r3, [pc, #12]	; (1a00200c <SysTick_Handler+0x20>)
1a002000:	681b      	ldr	r3, [r3, #0]
1a002002:	2000      	movs	r0, #0
1a002004:	4798      	blx	r3
1a002006:	bd08      	pop	{r3, pc}
1a002008:	10000160 	.word	0x10000160
1a00200c:	10000004 	.word	0x10000004

1a002010 <errorOcurred>:
/*==================[internal functions definition]==========================*/

/* Causes:
 * User forgot to initialize the functions for the compare match interrupt on Timer_init call
 */
static void errorOcurred(void){
1a002010:	e7fe      	b.n	1a002010 <errorOcurred>

1a002012 <doNothing>:
   while(1);
}

static void doNothing(void){
1a002012:	4770      	bx	lr

1a002014 <TIMER0_IRQHandler>:
/*==================[ISR external functions definition]======================*/
/*
 * @Brief:   Executes the functions passed by parameter in the Timer_init,
 *   at the chosen frequencies
 */
void TIMER0_IRQHandler(void){
1a002014:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a002016:	2400      	movs	r4, #0
1a002018:	e001      	b.n	1a00201e <TIMER0_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a00201a:	3401      	adds	r4, #1
1a00201c:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a00201e:	2c03      	cmp	r4, #3
1a002020:	d812      	bhi.n	1a002048 <TIMER0_IRQHandler+0x34>
      if( Chip_TIMER_MatchPending(LPC_TIMER0, compareMatchNumber) ){
1a002022:	b265      	sxtb	r5, r4
 * @note   Determine if the match interrupt for the passed timer and match
 * counter is pending.
 */
STATIC INLINE bool Chip_TIMER_MatchPending(LPC_TIMER_T *pTMR, int8_t matchnum)
{
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a002024:	4b09      	ldr	r3, [pc, #36]	; (1a00204c <TIMER0_IRQHandler+0x38>)
1a002026:	681a      	ldr	r2, [r3, #0]
1a002028:	f004 010f 	and.w	r1, r4, #15
1a00202c:	2301      	movs	r3, #1
1a00202e:	408b      	lsls	r3, r1
1a002030:	421a      	tst	r2, r3
1a002032:	d0f2      	beq.n	1a00201a <TIMER0_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER0].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a002034:	4b06      	ldr	r3, [pc, #24]	; (1a002050 <TIMER0_IRQHandler+0x3c>)
1a002036:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
1a00203a:	4798      	blx	r3
 * @return Nothing
 * @note   Clears a pending timer match interrupt.
 */
STATIC INLINE void Chip_TIMER_ClearMatch(LPC_TIMER_T *pTMR, int8_t matchnum)
{
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a00203c:	2301      	movs	r3, #1
1a00203e:	fa03 f505 	lsl.w	r5, r3, r5
1a002042:	4b02      	ldr	r3, [pc, #8]	; (1a00204c <TIMER0_IRQHandler+0x38>)
1a002044:	601d      	str	r5, [r3, #0]
1a002046:	e7e8      	b.n	1a00201a <TIMER0_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER0, compareMatchNumber);
      }
   }
}
1a002048:	bd38      	pop	{r3, r4, r5, pc}
1a00204a:	bf00      	nop
1a00204c:	40084000 	.word	0x40084000
1a002050:	10000008 	.word	0x10000008

1a002054 <TIMER1_IRQHandler>:

void TIMER1_IRQHandler( void ){
1a002054:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a002056:	2400      	movs	r4, #0
1a002058:	e001      	b.n	1a00205e <TIMER1_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a00205a:	3401      	adds	r4, #1
1a00205c:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a00205e:	2c03      	cmp	r4, #3
1a002060:	d813      	bhi.n	1a00208a <TIMER1_IRQHandler+0x36>
      if( Chip_TIMER_MatchPending(LPC_TIMER1, compareMatchNumber) ){
1a002062:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a002064:	4b09      	ldr	r3, [pc, #36]	; (1a00208c <TIMER1_IRQHandler+0x38>)
1a002066:	681a      	ldr	r2, [r3, #0]
1a002068:	f004 010f 	and.w	r1, r4, #15
1a00206c:	2301      	movs	r3, #1
1a00206e:	408b      	lsls	r3, r1
1a002070:	421a      	tst	r2, r3
1a002072:	d0f2      	beq.n	1a00205a <TIMER1_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER1].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a002074:	1d23      	adds	r3, r4, #4
1a002076:	4a06      	ldr	r2, [pc, #24]	; (1a002090 <TIMER1_IRQHandler+0x3c>)
1a002078:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a00207c:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a00207e:	2301      	movs	r3, #1
1a002080:	fa03 f505 	lsl.w	r5, r3, r5
1a002084:	4b01      	ldr	r3, [pc, #4]	; (1a00208c <TIMER1_IRQHandler+0x38>)
1a002086:	601d      	str	r5, [r3, #0]
1a002088:	e7e7      	b.n	1a00205a <TIMER1_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER1, compareMatchNumber);
      }
   }
}
1a00208a:	bd38      	pop	{r3, r4, r5, pc}
1a00208c:	40085000 	.word	0x40085000
1a002090:	10000008 	.word	0x10000008

1a002094 <TIMER2_IRQHandler>:

void TIMER2_IRQHandler( void ){
1a002094:	b538      	push	{r3, r4, r5, lr}
   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a002096:	2400      	movs	r4, #0
1a002098:	e001      	b.n	1a00209e <TIMER2_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a00209a:	3401      	adds	r4, #1
1a00209c:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a00209e:	2c03      	cmp	r4, #3
1a0020a0:	d814      	bhi.n	1a0020cc <TIMER2_IRQHandler+0x38>
      if( Chip_TIMER_MatchPending(LPC_TIMER2, compareMatchNumber) ){
1a0020a2:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a0020a4:	4b0a      	ldr	r3, [pc, #40]	; (1a0020d0 <TIMER2_IRQHandler+0x3c>)
1a0020a6:	681a      	ldr	r2, [r3, #0]
1a0020a8:	f004 010f 	and.w	r1, r4, #15
1a0020ac:	2301      	movs	r3, #1
1a0020ae:	408b      	lsls	r3, r1
1a0020b0:	421a      	tst	r2, r3
1a0020b2:	d0f2      	beq.n	1a00209a <TIMER2_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER2].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a0020b4:	f104 0308 	add.w	r3, r4, #8
1a0020b8:	4a06      	ldr	r2, [pc, #24]	; (1a0020d4 <TIMER2_IRQHandler+0x40>)
1a0020ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a0020be:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a0020c0:	2301      	movs	r3, #1
1a0020c2:	fa03 f505 	lsl.w	r5, r3, r5
1a0020c6:	4b02      	ldr	r3, [pc, #8]	; (1a0020d0 <TIMER2_IRQHandler+0x3c>)
1a0020c8:	601d      	str	r5, [r3, #0]
1a0020ca:	e7e6      	b.n	1a00209a <TIMER2_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER2, compareMatchNumber);
      }
   }
}
1a0020cc:	bd38      	pop	{r3, r4, r5, pc}
1a0020ce:	bf00      	nop
1a0020d0:	400c3000 	.word	0x400c3000
1a0020d4:	10000008 	.word	0x10000008

1a0020d8 <TIMER3_IRQHandler>:

/*fixme __attribute__ ((section(".after_vectors")))*/
void TIMER3_IRQHandler( void ){
1a0020d8:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a0020da:	2400      	movs	r4, #0
1a0020dc:	e001      	b.n	1a0020e2 <TIMER3_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a0020de:	3401      	adds	r4, #1
1a0020e0:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a0020e2:	2c03      	cmp	r4, #3
1a0020e4:	d814      	bhi.n	1a002110 <TIMER3_IRQHandler+0x38>
      if (Chip_TIMER_MatchPending(LPC_TIMER3, compareMatchNumber)){
1a0020e6:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a0020e8:	4b0a      	ldr	r3, [pc, #40]	; (1a002114 <TIMER3_IRQHandler+0x3c>)
1a0020ea:	681a      	ldr	r2, [r3, #0]
1a0020ec:	f004 010f 	and.w	r1, r4, #15
1a0020f0:	2301      	movs	r3, #1
1a0020f2:	408b      	lsls	r3, r1
1a0020f4:	421a      	tst	r2, r3
1a0020f6:	d0f2      	beq.n	1a0020de <TIMER3_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER3].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a0020f8:	f104 030c 	add.w	r3, r4, #12
1a0020fc:	4a06      	ldr	r2, [pc, #24]	; (1a002118 <TIMER3_IRQHandler+0x40>)
1a0020fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a002102:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a002104:	2301      	movs	r3, #1
1a002106:	fa03 f505 	lsl.w	r5, r3, r5
1a00210a:	4b02      	ldr	r3, [pc, #8]	; (1a002114 <TIMER3_IRQHandler+0x3c>)
1a00210c:	601d      	str	r5, [r3, #0]
1a00210e:	e7e6      	b.n	1a0020de <TIMER3_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER3, compareMatchNumber);
      }
   }
}
1a002110:	bd38      	pop	{r3, r4, r5, pc}
1a002112:	bf00      	nop
1a002114:	400c4000 	.word	0x400c4000
1a002118:	10000008 	.word	0x10000008

1a00211c <uartConfig>:
void uartConfig( uartMap_t uart, uint32_t baudRate ){
1a00211c:	b538      	push	{r3, r4, r5, lr}
1a00211e:	460c      	mov	r4, r1
   switch(uart){
1a002120:	b110      	cbz	r0, 1a002128 <uartConfig+0xc>
1a002122:	2801      	cmp	r0, #1
1a002124:	d013      	beq.n	1a00214e <uartConfig+0x32>
1a002126:	bd38      	pop	{r3, r4, r5, pc}
      Chip_UART_Init(UART_USB_LPC);
1a002128:	4d12      	ldr	r5, [pc, #72]	; (1a002174 <uartConfig+0x58>)
1a00212a:	4628      	mov	r0, r5
1a00212c:	f7ff fb90 	bl	1a001850 <Chip_UART_Init>
      Chip_UART_SetBaud(UART_USB_LPC, baudRate);  /* Set Baud rate */
1a002130:	4621      	mov	r1, r4
1a002132:	4628      	mov	r0, r5
1a002134:	f7ff fbb6 	bl	1a0018a4 <Chip_UART_SetBaud>
   pUART->FCR = fcr;
1a002138:	2301      	movs	r3, #1
1a00213a:	60ab      	str	r3, [r5, #8]
    pUART->TER2 = UART_TER2_TXEN;
1a00213c:	65eb      	str	r3, [r5, #92]	; 0x5c
1a00213e:	4b0e      	ldr	r3, [pc, #56]	; (1a002178 <uartConfig+0x5c>)
1a002140:	221e      	movs	r2, #30
1a002142:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
1a002146:	22d6      	movs	r2, #214	; 0xd6
1a002148:	f8c3 2388 	str.w	r2, [r3, #904]	; 0x388
1a00214c:	bd38      	pop	{r3, r4, r5, pc}
      Chip_UART_Init(UART_232_LPC);
1a00214e:	4d0b      	ldr	r5, [pc, #44]	; (1a00217c <uartConfig+0x60>)
1a002150:	4628      	mov	r0, r5
1a002152:	f7ff fb7d 	bl	1a001850 <Chip_UART_Init>
      Chip_UART_SetBaud(UART_232_LPC, baudRate);  /* Set Baud rate */
1a002156:	4621      	mov	r1, r4
1a002158:	4628      	mov	r0, r5
1a00215a:	f7ff fba3 	bl	1a0018a4 <Chip_UART_SetBaud>
   pUART->FCR = fcr;
1a00215e:	2301      	movs	r3, #1
1a002160:	60ab      	str	r3, [r5, #8]
    pUART->TER2 = UART_TER2_TXEN;
1a002162:	65eb      	str	r3, [r5, #92]	; 0x5c
1a002164:	4b04      	ldr	r3, [pc, #16]	; (1a002178 <uartConfig+0x5c>)
1a002166:	221a      	movs	r2, #26
1a002168:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
1a00216c:	22d2      	movs	r2, #210	; 0xd2
1a00216e:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
1a002172:	bd38      	pop	{r3, r4, r5, pc}
1a002174:	400c1000 	.word	0x400c1000
1a002178:	40086000 	.word	0x40086000
1a00217c:	400c2000 	.word	0x400c2000

1a002180 <uartWriteByte>:
   switch(uart){
1a002180:	b110      	cbz	r0, 1a002188 <uartWriteByte+0x8>
1a002182:	2801      	cmp	r0, #1
1a002184:	d008      	beq.n	1a002198 <uartWriteByte+0x18>
1a002186:	4770      	bx	lr
 * @note   Mask bits of the returned status value with UART_LSR_*
 *         definitions for specific statuses.
 */
STATIC INLINE uint32_t Chip_UART_ReadLineStatus(LPC_USART_T *pUART)
{
   return pUART->LSR;
1a002188:	4b07      	ldr	r3, [pc, #28]	; (1a0021a8 <uartWriteByte+0x28>)
1a00218a:	695b      	ldr	r3, [r3, #20]
      while ((Chip_UART_ReadLineStatus(UART_USB_LPC) & UART_LSR_THRE) == 0) {}   // Wait for space in FIFO
1a00218c:	f013 0f20 	tst.w	r3, #32
1a002190:	d0fa      	beq.n	1a002188 <uartWriteByte+0x8>
   pUART->THR = (uint32_t) data;
1a002192:	4b05      	ldr	r3, [pc, #20]	; (1a0021a8 <uartWriteByte+0x28>)
1a002194:	6019      	str	r1, [r3, #0]
1a002196:	4770      	bx	lr
   return pUART->LSR;
1a002198:	4b04      	ldr	r3, [pc, #16]	; (1a0021ac <uartWriteByte+0x2c>)
1a00219a:	695b      	ldr	r3, [r3, #20]
      while ((Chip_UART_ReadLineStatus(UART_232_LPC) & UART_LSR_THRE) == 0) {}   // Wait for space in FIFO
1a00219c:	f013 0f20 	tst.w	r3, #32
1a0021a0:	d0fa      	beq.n	1a002198 <uartWriteByte+0x18>
   pUART->THR = (uint32_t) data;
1a0021a2:	4b02      	ldr	r3, [pc, #8]	; (1a0021ac <uartWriteByte+0x2c>)
1a0021a4:	6019      	str	r1, [r3, #0]
1a0021a6:	4770      	bx	lr
1a0021a8:	400c1000 	.word	0x400c1000
1a0021ac:	400c2000 	.word	0x400c2000

1a0021b0 <uartWriteString>:
void uartWriteString( uartMap_t uart, char* str ){
1a0021b0:	b538      	push	{r3, r4, r5, lr}
1a0021b2:	4605      	mov	r5, r0
1a0021b4:	460c      	mov	r4, r1
   while(*str != 0){
1a0021b6:	e003      	b.n	1a0021c0 <uartWriteString+0x10>
	  uartWriteByte( uart, (uint8_t)*str );
1a0021b8:	4628      	mov	r0, r5
1a0021ba:	f7ff ffe1 	bl	1a002180 <uartWriteByte>
	  str++;
1a0021be:	3401      	adds	r4, #1
   while(*str != 0){
1a0021c0:	7821      	ldrb	r1, [r4, #0]
1a0021c2:	2900      	cmp	r1, #0
1a0021c4:	d1f8      	bne.n	1a0021b8 <uartWriteString+0x8>
}
1a0021c6:	bd38      	pop	{r3, r4, r5, pc}

1a0021c8 <UART2_IRQHandler>:
}

/* 0x2a 0x000000A8 - Handler for ISR UART2 (IRQ 26) */
void UART2_IRQHandler(void){
1a0021c8:	4770      	bx	lr

1a0021ca <UART3_IRQHandler>:
}

/* 0x2b 0x000000AC - Handler for ISR UART3 (IRQ 27) */
void UART3_IRQHandler(void){
1a0021ca:	4770      	bx	lr

1a0021cc <__aeabi_uldivmod>:
1a0021cc:	b953      	cbnz	r3, 1a0021e4 <__aeabi_uldivmod+0x18>
1a0021ce:	b94a      	cbnz	r2, 1a0021e4 <__aeabi_uldivmod+0x18>
1a0021d0:	2900      	cmp	r1, #0
1a0021d2:	bf08      	it	eq
1a0021d4:	2800      	cmpeq	r0, #0
1a0021d6:	bf1c      	itt	ne
1a0021d8:	f04f 31ff 	movne.w	r1, #4294967295
1a0021dc:	f04f 30ff 	movne.w	r0, #4294967295
1a0021e0:	f000 b97a 	b.w	1a0024d8 <__aeabi_idiv0>
1a0021e4:	f1ad 0c08 	sub.w	ip, sp, #8
1a0021e8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
1a0021ec:	f000 f806 	bl	1a0021fc <__udivmoddi4>
1a0021f0:	f8dd e004 	ldr.w	lr, [sp, #4]
1a0021f4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
1a0021f8:	b004      	add	sp, #16
1a0021fa:	4770      	bx	lr

1a0021fc <__udivmoddi4>:
1a0021fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
1a002200:	468c      	mov	ip, r1
1a002202:	460d      	mov	r5, r1
1a002204:	4604      	mov	r4, r0
1a002206:	9e08      	ldr	r6, [sp, #32]
1a002208:	2b00      	cmp	r3, #0
1a00220a:	d151      	bne.n	1a0022b0 <__udivmoddi4+0xb4>
1a00220c:	428a      	cmp	r2, r1
1a00220e:	4617      	mov	r7, r2
1a002210:	d96d      	bls.n	1a0022ee <__udivmoddi4+0xf2>
1a002212:	fab2 fe82 	clz	lr, r2
1a002216:	f1be 0f00 	cmp.w	lr, #0
1a00221a:	d00b      	beq.n	1a002234 <__udivmoddi4+0x38>
1a00221c:	f1ce 0c20 	rsb	ip, lr, #32
1a002220:	fa01 f50e 	lsl.w	r5, r1, lr
1a002224:	fa20 fc0c 	lsr.w	ip, r0, ip
1a002228:	fa02 f70e 	lsl.w	r7, r2, lr
1a00222c:	ea4c 0c05 	orr.w	ip, ip, r5
1a002230:	fa00 f40e 	lsl.w	r4, r0, lr
1a002234:	ea4f 4a17 	mov.w	sl, r7, lsr #16
1a002238:	0c25      	lsrs	r5, r4, #16
1a00223a:	fbbc f8fa 	udiv	r8, ip, sl
1a00223e:	fa1f f987 	uxth.w	r9, r7
1a002242:	fb0a cc18 	mls	ip, sl, r8, ip
1a002246:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
1a00224a:	fb08 f309 	mul.w	r3, r8, r9
1a00224e:	42ab      	cmp	r3, r5
1a002250:	d90a      	bls.n	1a002268 <__udivmoddi4+0x6c>
1a002252:	19ed      	adds	r5, r5, r7
1a002254:	f108 32ff 	add.w	r2, r8, #4294967295
1a002258:	f080 8123 	bcs.w	1a0024a2 <__udivmoddi4+0x2a6>
1a00225c:	42ab      	cmp	r3, r5
1a00225e:	f240 8120 	bls.w	1a0024a2 <__udivmoddi4+0x2a6>
1a002262:	f1a8 0802 	sub.w	r8, r8, #2
1a002266:	443d      	add	r5, r7
1a002268:	1aed      	subs	r5, r5, r3
1a00226a:	b2a4      	uxth	r4, r4
1a00226c:	fbb5 f0fa 	udiv	r0, r5, sl
1a002270:	fb0a 5510 	mls	r5, sl, r0, r5
1a002274:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
1a002278:	fb00 f909 	mul.w	r9, r0, r9
1a00227c:	45a1      	cmp	r9, r4
1a00227e:	d909      	bls.n	1a002294 <__udivmoddi4+0x98>
1a002280:	19e4      	adds	r4, r4, r7
1a002282:	f100 33ff 	add.w	r3, r0, #4294967295
1a002286:	f080 810a 	bcs.w	1a00249e <__udivmoddi4+0x2a2>
1a00228a:	45a1      	cmp	r9, r4
1a00228c:	f240 8107 	bls.w	1a00249e <__udivmoddi4+0x2a2>
1a002290:	3802      	subs	r0, #2
1a002292:	443c      	add	r4, r7
1a002294:	eba4 0409 	sub.w	r4, r4, r9
1a002298:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
1a00229c:	2100      	movs	r1, #0
1a00229e:	2e00      	cmp	r6, #0
1a0022a0:	d061      	beq.n	1a002366 <__udivmoddi4+0x16a>
1a0022a2:	fa24 f40e 	lsr.w	r4, r4, lr
1a0022a6:	2300      	movs	r3, #0
1a0022a8:	6034      	str	r4, [r6, #0]
1a0022aa:	6073      	str	r3, [r6, #4]
1a0022ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a0022b0:	428b      	cmp	r3, r1
1a0022b2:	d907      	bls.n	1a0022c4 <__udivmoddi4+0xc8>
1a0022b4:	2e00      	cmp	r6, #0
1a0022b6:	d054      	beq.n	1a002362 <__udivmoddi4+0x166>
1a0022b8:	2100      	movs	r1, #0
1a0022ba:	e886 0021 	stmia.w	r6, {r0, r5}
1a0022be:	4608      	mov	r0, r1
1a0022c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a0022c4:	fab3 f183 	clz	r1, r3
1a0022c8:	2900      	cmp	r1, #0
1a0022ca:	f040 808e 	bne.w	1a0023ea <__udivmoddi4+0x1ee>
1a0022ce:	42ab      	cmp	r3, r5
1a0022d0:	d302      	bcc.n	1a0022d8 <__udivmoddi4+0xdc>
1a0022d2:	4282      	cmp	r2, r0
1a0022d4:	f200 80fa 	bhi.w	1a0024cc <__udivmoddi4+0x2d0>
1a0022d8:	1a84      	subs	r4, r0, r2
1a0022da:	eb65 0503 	sbc.w	r5, r5, r3
1a0022de:	2001      	movs	r0, #1
1a0022e0:	46ac      	mov	ip, r5
1a0022e2:	2e00      	cmp	r6, #0
1a0022e4:	d03f      	beq.n	1a002366 <__udivmoddi4+0x16a>
1a0022e6:	e886 1010 	stmia.w	r6, {r4, ip}
1a0022ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a0022ee:	b912      	cbnz	r2, 1a0022f6 <__udivmoddi4+0xfa>
1a0022f0:	2701      	movs	r7, #1
1a0022f2:	fbb7 f7f2 	udiv	r7, r7, r2
1a0022f6:	fab7 fe87 	clz	lr, r7
1a0022fa:	f1be 0f00 	cmp.w	lr, #0
1a0022fe:	d134      	bne.n	1a00236a <__udivmoddi4+0x16e>
1a002300:	1beb      	subs	r3, r5, r7
1a002302:	0c3a      	lsrs	r2, r7, #16
1a002304:	fa1f fc87 	uxth.w	ip, r7
1a002308:	2101      	movs	r1, #1
1a00230a:	fbb3 f8f2 	udiv	r8, r3, r2
1a00230e:	0c25      	lsrs	r5, r4, #16
1a002310:	fb02 3318 	mls	r3, r2, r8, r3
1a002314:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
1a002318:	fb0c f308 	mul.w	r3, ip, r8
1a00231c:	42ab      	cmp	r3, r5
1a00231e:	d907      	bls.n	1a002330 <__udivmoddi4+0x134>
1a002320:	19ed      	adds	r5, r5, r7
1a002322:	f108 30ff 	add.w	r0, r8, #4294967295
1a002326:	d202      	bcs.n	1a00232e <__udivmoddi4+0x132>
1a002328:	42ab      	cmp	r3, r5
1a00232a:	f200 80d1 	bhi.w	1a0024d0 <__udivmoddi4+0x2d4>
1a00232e:	4680      	mov	r8, r0
1a002330:	1aed      	subs	r5, r5, r3
1a002332:	b2a3      	uxth	r3, r4
1a002334:	fbb5 f0f2 	udiv	r0, r5, r2
1a002338:	fb02 5510 	mls	r5, r2, r0, r5
1a00233c:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
1a002340:	fb0c fc00 	mul.w	ip, ip, r0
1a002344:	45a4      	cmp	ip, r4
1a002346:	d907      	bls.n	1a002358 <__udivmoddi4+0x15c>
1a002348:	19e4      	adds	r4, r4, r7
1a00234a:	f100 33ff 	add.w	r3, r0, #4294967295
1a00234e:	d202      	bcs.n	1a002356 <__udivmoddi4+0x15a>
1a002350:	45a4      	cmp	ip, r4
1a002352:	f200 80b8 	bhi.w	1a0024c6 <__udivmoddi4+0x2ca>
1a002356:	4618      	mov	r0, r3
1a002358:	eba4 040c 	sub.w	r4, r4, ip
1a00235c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
1a002360:	e79d      	b.n	1a00229e <__udivmoddi4+0xa2>
1a002362:	4631      	mov	r1, r6
1a002364:	4630      	mov	r0, r6
1a002366:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a00236a:	f1ce 0420 	rsb	r4, lr, #32
1a00236e:	fa05 f30e 	lsl.w	r3, r5, lr
1a002372:	fa07 f70e 	lsl.w	r7, r7, lr
1a002376:	fa20 f804 	lsr.w	r8, r0, r4
1a00237a:	0c3a      	lsrs	r2, r7, #16
1a00237c:	fa25 f404 	lsr.w	r4, r5, r4
1a002380:	ea48 0803 	orr.w	r8, r8, r3
1a002384:	fbb4 f1f2 	udiv	r1, r4, r2
1a002388:	ea4f 4518 	mov.w	r5, r8, lsr #16
1a00238c:	fb02 4411 	mls	r4, r2, r1, r4
1a002390:	fa1f fc87 	uxth.w	ip, r7
1a002394:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
1a002398:	fb01 f30c 	mul.w	r3, r1, ip
1a00239c:	42ab      	cmp	r3, r5
1a00239e:	fa00 f40e 	lsl.w	r4, r0, lr
1a0023a2:	d909      	bls.n	1a0023b8 <__udivmoddi4+0x1bc>
1a0023a4:	19ed      	adds	r5, r5, r7
1a0023a6:	f101 30ff 	add.w	r0, r1, #4294967295
1a0023aa:	f080 808a 	bcs.w	1a0024c2 <__udivmoddi4+0x2c6>
1a0023ae:	42ab      	cmp	r3, r5
1a0023b0:	f240 8087 	bls.w	1a0024c2 <__udivmoddi4+0x2c6>
1a0023b4:	3902      	subs	r1, #2
1a0023b6:	443d      	add	r5, r7
1a0023b8:	1aeb      	subs	r3, r5, r3
1a0023ba:	fa1f f588 	uxth.w	r5, r8
1a0023be:	fbb3 f0f2 	udiv	r0, r3, r2
1a0023c2:	fb02 3310 	mls	r3, r2, r0, r3
1a0023c6:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
1a0023ca:	fb00 f30c 	mul.w	r3, r0, ip
1a0023ce:	42ab      	cmp	r3, r5
1a0023d0:	d907      	bls.n	1a0023e2 <__udivmoddi4+0x1e6>
1a0023d2:	19ed      	adds	r5, r5, r7
1a0023d4:	f100 38ff 	add.w	r8, r0, #4294967295
1a0023d8:	d26f      	bcs.n	1a0024ba <__udivmoddi4+0x2be>
1a0023da:	42ab      	cmp	r3, r5
1a0023dc:	d96d      	bls.n	1a0024ba <__udivmoddi4+0x2be>
1a0023de:	3802      	subs	r0, #2
1a0023e0:	443d      	add	r5, r7
1a0023e2:	1aeb      	subs	r3, r5, r3
1a0023e4:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
1a0023e8:	e78f      	b.n	1a00230a <__udivmoddi4+0x10e>
1a0023ea:	f1c1 0720 	rsb	r7, r1, #32
1a0023ee:	fa22 f807 	lsr.w	r8, r2, r7
1a0023f2:	408b      	lsls	r3, r1
1a0023f4:	fa05 f401 	lsl.w	r4, r5, r1
1a0023f8:	ea48 0303 	orr.w	r3, r8, r3
1a0023fc:	fa20 fe07 	lsr.w	lr, r0, r7
1a002400:	ea4f 4c13 	mov.w	ip, r3, lsr #16
1a002404:	40fd      	lsrs	r5, r7
1a002406:	ea4e 0e04 	orr.w	lr, lr, r4
1a00240a:	fbb5 f9fc 	udiv	r9, r5, ip
1a00240e:	ea4f 441e 	mov.w	r4, lr, lsr #16
1a002412:	fb0c 5519 	mls	r5, ip, r9, r5
1a002416:	fa1f f883 	uxth.w	r8, r3
1a00241a:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
1a00241e:	fb09 f408 	mul.w	r4, r9, r8
1a002422:	42ac      	cmp	r4, r5
1a002424:	fa02 f201 	lsl.w	r2, r2, r1
1a002428:	fa00 fa01 	lsl.w	sl, r0, r1
1a00242c:	d908      	bls.n	1a002440 <__udivmoddi4+0x244>
1a00242e:	18ed      	adds	r5, r5, r3
1a002430:	f109 30ff 	add.w	r0, r9, #4294967295
1a002434:	d243      	bcs.n	1a0024be <__udivmoddi4+0x2c2>
1a002436:	42ac      	cmp	r4, r5
1a002438:	d941      	bls.n	1a0024be <__udivmoddi4+0x2c2>
1a00243a:	f1a9 0902 	sub.w	r9, r9, #2
1a00243e:	441d      	add	r5, r3
1a002440:	1b2d      	subs	r5, r5, r4
1a002442:	fa1f fe8e 	uxth.w	lr, lr
1a002446:	fbb5 f0fc 	udiv	r0, r5, ip
1a00244a:	fb0c 5510 	mls	r5, ip, r0, r5
1a00244e:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
1a002452:	fb00 f808 	mul.w	r8, r0, r8
1a002456:	45a0      	cmp	r8, r4
1a002458:	d907      	bls.n	1a00246a <__udivmoddi4+0x26e>
1a00245a:	18e4      	adds	r4, r4, r3
1a00245c:	f100 35ff 	add.w	r5, r0, #4294967295
1a002460:	d229      	bcs.n	1a0024b6 <__udivmoddi4+0x2ba>
1a002462:	45a0      	cmp	r8, r4
1a002464:	d927      	bls.n	1a0024b6 <__udivmoddi4+0x2ba>
1a002466:	3802      	subs	r0, #2
1a002468:	441c      	add	r4, r3
1a00246a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
1a00246e:	eba4 0408 	sub.w	r4, r4, r8
1a002472:	fba0 8902 	umull	r8, r9, r0, r2
1a002476:	454c      	cmp	r4, r9
1a002478:	46c6      	mov	lr, r8
1a00247a:	464d      	mov	r5, r9
1a00247c:	d315      	bcc.n	1a0024aa <__udivmoddi4+0x2ae>
1a00247e:	d012      	beq.n	1a0024a6 <__udivmoddi4+0x2aa>
1a002480:	b156      	cbz	r6, 1a002498 <__udivmoddi4+0x29c>
1a002482:	ebba 030e 	subs.w	r3, sl, lr
1a002486:	eb64 0405 	sbc.w	r4, r4, r5
1a00248a:	fa04 f707 	lsl.w	r7, r4, r7
1a00248e:	40cb      	lsrs	r3, r1
1a002490:	431f      	orrs	r7, r3
1a002492:	40cc      	lsrs	r4, r1
1a002494:	6037      	str	r7, [r6, #0]
1a002496:	6074      	str	r4, [r6, #4]
1a002498:	2100      	movs	r1, #0
1a00249a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a00249e:	4618      	mov	r0, r3
1a0024a0:	e6f8      	b.n	1a002294 <__udivmoddi4+0x98>
1a0024a2:	4690      	mov	r8, r2
1a0024a4:	e6e0      	b.n	1a002268 <__udivmoddi4+0x6c>
1a0024a6:	45c2      	cmp	sl, r8
1a0024a8:	d2ea      	bcs.n	1a002480 <__udivmoddi4+0x284>
1a0024aa:	ebb8 0e02 	subs.w	lr, r8, r2
1a0024ae:	eb69 0503 	sbc.w	r5, r9, r3
1a0024b2:	3801      	subs	r0, #1
1a0024b4:	e7e4      	b.n	1a002480 <__udivmoddi4+0x284>
1a0024b6:	4628      	mov	r0, r5
1a0024b8:	e7d7      	b.n	1a00246a <__udivmoddi4+0x26e>
1a0024ba:	4640      	mov	r0, r8
1a0024bc:	e791      	b.n	1a0023e2 <__udivmoddi4+0x1e6>
1a0024be:	4681      	mov	r9, r0
1a0024c0:	e7be      	b.n	1a002440 <__udivmoddi4+0x244>
1a0024c2:	4601      	mov	r1, r0
1a0024c4:	e778      	b.n	1a0023b8 <__udivmoddi4+0x1bc>
1a0024c6:	3802      	subs	r0, #2
1a0024c8:	443c      	add	r4, r7
1a0024ca:	e745      	b.n	1a002358 <__udivmoddi4+0x15c>
1a0024cc:	4608      	mov	r0, r1
1a0024ce:	e708      	b.n	1a0022e2 <__udivmoddi4+0xe6>
1a0024d0:	f1a8 0802 	sub.w	r8, r8, #2
1a0024d4:	443d      	add	r5, r7
1a0024d6:	e72b      	b.n	1a002330 <__udivmoddi4+0x134>

1a0024d8 <__aeabi_idiv0>:
1a0024d8:	4770      	bx	lr
1a0024da:	bf00      	nop

1a0024dc <memset>:
1a0024dc:	4402      	add	r2, r0
1a0024de:	4603      	mov	r3, r0
1a0024e0:	4293      	cmp	r3, r2
1a0024e2:	d100      	bne.n	1a0024e6 <memset+0xa>
1a0024e4:	4770      	bx	lr
1a0024e6:	f803 1b01 	strb.w	r1, [r3], #1
1a0024ea:	e7f9      	b.n	1a0024e0 <memset+0x4>

1a0024ec <pinesColumna>:
1a0024ec:	0405 0203                                   ....

1a0024f0 <pinesFila>:
1a0024f0:	0809 0607                                   ....

1a0024f4 <pinesTeclado>:
1a0024f4:	0001 0002 0003 0041 0004 0005 0006 0042     ......A.......B.
1a002504:	0007 0008 0009 0043 002a 0000 0023 0044     ......C.*...#.D.
1a002514:	5b1b 4a32 5b1b 0048 7542 5b66 5d30 203d     .[2J.[H.Buf[0]= 
1a002524:	0000 0000 7542 5b66 5d31 203d 0000 0000     ....Buf[1]= ....
1a002534:	7542 5b66 5d32 203d 0000 0000 7542 5b66     Buf[2]= ....Buf[
1a002544:	5d33 203d 0000 0000 7542 5b66 5d34 203d     3]= ....Buf[4]= 
1a002554:	0000 0000 7542 5b66 5d35 203d 0000 0000     ....Buf[5]= ....
1a002564:	7542 5b66 5d36 203d 0000 0000 7542 5b66     Buf[6]= ....Buf[
1a002574:	5d37 203d 0000 0000 7542 5b66 5d38 203d     7]= ....Buf[8]= 
1a002584:	0000 0000 7542 5b66 5d39 203d 0000 0000     ....Buf[9]= ....
1a002594:	7345 6174 6f64 6420 6c65 4120 6373 6e65     Estado del Ascen
1a0025a4:	6f73 3a72 0020 0000 6e45 5020 616c 746e     sor: ...En Plant
1a0025b4:	2061 6142 616a 7920 0020 0000 7553 6962     a Baja y ...Subi
1a0025c4:	6e65 6f64 7920 0020 6142 616a 646e 206f     endo y .Bajando 
1a0025d4:	2079 0000 6150 6172 6f64 7920 0020 0000     y ..Parado y ...
1a0025e4:	6559 646e 206f 2061 6c50 6e61 6174 4220     Yendo a Planta B
1a0025f4:	6a61 2061 2079 0000 6f4d 6f64 4320 6e6f     aja y ..Modo Con
1a002604:	6966 7567 6172 6963 6e6f 7920 0020 0000     figuracion y ...
1a002614:	7550 7265 6174 2073 6543 7272 6461 7361     Puertas Cerradas
1a002624:	0a0d 0000 6241 6972 6e65 6f64 5020 6575     ....Abriendo Pue
1a002634:	7472 7361 0a0d 0000 7550 7265 6174 2073     rtas....Puertas 
1a002644:	6241 6569 7472 7361 0a0d 0000 6e49 6574     Abiertas....Inte
1a002654:	746e 6461 206f 6543 7272 7261 5020 6575     ntado Cerrar Pue
1a002664:	7472 7361 0a0d 0000 6543 7272 6e61 6f64     rtas....Cerrando
1a002674:	5020 6575 7472 7361 0a0d 0000 6c41 7261      Puertas....Alar
1a002684:	616d 5020 6575 7472 7361 4120 6962 7265     ma Puertas Abier
1a002694:	6174 0d73 000a 0000 6950 6564 6e20 6575     tas.....Pide nue
1a0026a4:	6f76 7020 7369 206f 203d 4953 0a0d 0000     vo piso = SI....
1a0026b4:	6950 6564 6e20 6575 6f76 7020 7369 206f     Pide nuevo piso 
1a0026c4:	203d 4f4e 0a0d 0000 6950 6f73 4420 7365     = NO....Piso Des
1a0026d4:	6974 6f6e 3d20 0020 6950 6f73 4120 7463     tino = .Piso Act
1a0026e4:	6175 206c 203d ff00 797a 7778 7576 7374     ual = ..zyxwvuts
1a0026f4:	7172 6f70 6d6e 6b6c 696a 6768 6566 6364     rqponmlkjihgfedc
1a002704:	6162 3839 3637 3435 3233 3031 3231 3433     ba98765432101234
1a002714:	3635 3837 6139 6362 6564 6766 6968 6b6a     56789abcdefghijk
1a002724:	6d6c 6f6e 7170 7372 7574 7776 7978 007a     lmnopqrstuvwxyz.

1a002734 <numeroadisplayB>:
1a002734:	063f 4f5b 6d66 077d 6f7f 7c5f 5e58 717b     ?.[Ofm}..o_|X^{q
1a002744:	3977 7679 381e 3e73 4080 ff00               w9yv.8s>.@..

1a002750 <quedisplayB>:
1a002750:	1110 1412                                   ....

1a002754 <segmentosdisplayB>:
1a002754:	0f20 0e1f 0d1e 0c1d 0201 0804 0f03 0f0f      ...............
1a002764:	00ff 0000                                   ....

1a002768 <periph_to_base>:
1a002768:	0000 0005 000a 0020 0024 0009 0040 0040     ...... .$...@.@.
1a002778:	0005 0060 00a6 0004 00c0 00c3 0002 00e0     ..`.............
1a002788:	00e0 0001 0100 0100 0003 0120 0120 0006     .......... . ...
1a002798:	0140 0140 000c 0142 0142 0019 0162 0162     @.@...B.B...b.b.
1a0027a8:	0013 0182 0182 0012 01a2 01a2 0011 01c2     ................
1a0027b8:	01c2 0010 01e2 01e2 000f 0202 0202 000e     ................
1a0027c8:	0222 0222 000d 0223 0223 001c               "."...#.#...

1a0027d4 <InitClkStates>:
1a0027d4:	0100 0001 0909 0001 090a 0001 0701 0101     ................
1a0027e4:	0902 0001 0906 0001 090c 0101 090d 0001     ................
1a0027f4:	090e 0001 090f 0001 0910 0001 0911 0001     ................
1a002804:	0912 0001 0913 0001 1114 0001 1119 0001     ................
1a002814:	111a 0001 111b 0001                         ........

1a00281c <UART_BClock>:
1a00281c:	01c2 01a2 0182 0162                         ......b.

1a002824 <UART_PClock>:
1a002824:	0081 0082 00a1 00a2                         ........

1a00282c <ExtRateIn>:
1a00282c:	0000 0000                                   ....

1a002830 <OscRateIn>:
1a002830:	1b00 00b7                                   ....

1a002834 <gpioLEDBits>:
1a002834:	0e00 0b01 0c01 0005 0105 0205               ............

1a002840 <InitClkStates>:
1a002840:	0308 0001 0307 0001 0f01 0101               ............

1a00284c <pinmuxing>:
1a00284c:	0a02 0040 0b02 0040 0c02 0040 0002 0044     ..@...@...@...D.
1a00285c:	0102 0044 0202 0044 0302 0052 0402 0052     ..D...D...R...R.
1a00286c:	0509 0052 0609 0057 0206 0057 0001 0050     ..R...W...W...P.
1a00287c:	0101 0050 0201 0050 0601 0050 0f01 00f3     ..P...P...P.....
1a00288c:	1001 00f7 1101 00f3 1201 00b3 1301 00f0     ................
1a00289c:	1401 00b3 0707 00b6 0000 00f2 0100 00b6     ................

1a0028ac <gpioPinsConfig>:
1a0028ac:	0104 0200 0701 0005 0d03 0501 0100 0408     ................
1a0028bc:	0002 0202 0304 0200 0403 0000 0002 0407     ................
1a0028cc:	0300 030c 0402 0905 0103 0504 0208 0403     ................
1a0028dc:	0305 0402 0504 0604 000c 0802 0b06 0300     ................
1a0028ec:	0607 0009 0503 0706 0504 060f 0004 0303     ................
1a0028fc:	0404 0200 0404 0005 0502 0604 0200 0406     ................
1a00290c:	0408 0c05 0a04 0504 010e 0003 0a00 1401     ................
1a00291c:	0000 010f 0012 0d00 1101 0000 010c 0010     ................
1a00292c:	0300 0707 0300 000f 0001 0100 0000 0000     ................
1a00293c:	0600 000a 0603 0806 0504 0610 0005 0403     ................
1a00294c:	0106 0300 0400 0409 0d05 0401 0000 010b     ................
1a00295c:	000f 0200 0001 0000 0104 0001 0800 0201     ................
1a00296c:	0000 0109 0006 0901 0002 0504 0200 0401     ................
1a00297c:	0105 0202 0504 0202 000a 0e00 0b02 0100     ................
1a00298c:	020b 000c 0c01 0004 0200 0400 0001 0102     ................
1a00299c:	0204 0200 0402 0003 0302 0307 0300 070b     ................
1a0029ac:	0004 0c03 0507 0300 070d 0006 0e03 0102     ................
1a0029bc:	0504 0401 0006 0602 0504 0200 0405 0004     ................
1a0029cc:	0402 0804 0504 040c 0409 0d05 0a04 0504     ................
1a0029dc:	010e 0005 0801 ffff                         ........
