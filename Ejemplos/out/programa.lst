
out/programa.elf:     file format elf32-littlearm
out/programa.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x1a001ea5

Program Header:
0x70000001 off    0x00012fc0 vaddr 0x1a002fc0 paddr 0x1a002fc0 align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010058 vaddr 0x10000058 paddr 0x10000058 align 2**16
         filesz 0x00000000 memsz 0x00000140 flags rw-
    LOAD off    0x00010000 vaddr 0x1a000000 paddr 0x1a000000 align 2**16
         filesz 0x00002fc8 memsz 0x00002fc8 flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x1a002fc8 align 2**16
         filesz 0x00000054 memsz 0x00000054 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002fc0  1a000000  1a000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000054  10000000  1a002fc8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2    00000000  10080000  10080000  00020054  2**2
                  CONTENTS
  3 .data_RAM3    00000000  20000000  20000000  00020054  2**2
                  CONTENTS
  4 .data_RAM4    00000000  20008000  20008000  00020054  2**2
                  CONTENTS
  5 .data_RAM5    00000000  2000c000  2000c000  00020054  2**2
                  CONTENTS
  6 .bss          00000140  10000058  10000058  00010058  2**3
                  ALLOC
  7 .bss_RAM2     00000000  10080000  10080000  00020054  2**2
                  CONTENTS
  8 .bss_RAM3     00000000  20000000  20000000  00020054  2**2
                  CONTENTS
  9 .bss_RAM4     00000000  20008000  20008000  00020054  2**2
                  CONTENTS
 10 .bss_RAM5     00000000  2000c000  2000c000  00020054  2**2
                  CONTENTS
 11 .ARM.exidx    00000008  1a002fc0  1a002fc0  00012fc0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .uninit_RESERVED 00000000  10000000  10000000  00020054  2**2
                  CONTENTS
 13 .noinit_RAM2  00000000  10080000  10080000  00020054  2**2
                  CONTENTS
 14 .noinit_RAM3  00000000  20000000  20000000  00020054  2**2
                  CONTENTS
 15 .noinit_RAM4  00000000  20008000  20008000  00020054  2**2
                  CONTENTS
 16 .noinit_RAM5  00000000  2000c000  2000c000  00020054  2**2
                  CONTENTS
 17 .noinit       00000000  10000198  10000198  00020054  2**2
                  CONTENTS
 18 .debug_info   0001874b  00000000  00000000  00020054  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 000039f8  00000000  00000000  0003879f  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_loc    00004a8d  00000000  00000000  0003c197  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_aranges 00000750  00000000  00000000  00040c24  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_ranges 00000688  00000000  00000000  00041374  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_macro  0000af66  00000000  00000000  000419fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_line   0000bed2  00000000  00000000  0004c962  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_str    0001c9f8  00000000  00000000  00058834  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .comment      0000007f  00000000  00000000  0007522c  2**0
                  CONTENTS, READONLY
 27 .ARM.attributes 00000039  00000000  00000000  000752ab  2**0
                  CONTENTS, READONLY
 28 .debug_frame  000010d4  00000000  00000000  000752e4  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
1a000000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
10080000 l    d  .data_RAM2	00000000 .data_RAM2
20000000 l    d  .data_RAM3	00000000 .data_RAM3
20008000 l    d  .data_RAM4	00000000 .data_RAM4
2000c000 l    d  .data_RAM5	00000000 .data_RAM5
10000058 l    d  .bss	00000000 .bss
10080000 l    d  .bss_RAM2	00000000 .bss_RAM2
20000000 l    d  .bss_RAM3	00000000 .bss_RAM3
20008000 l    d  .bss_RAM4	00000000 .bss_RAM4
2000c000 l    d  .bss_RAM5	00000000 .bss_RAM5
1a002fc0 l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
10080000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
20000000 l    d  .noinit_RAM3	00000000 .noinit_RAM3
20008000 l    d  .noinit_RAM4	00000000 .noinit_RAM4
2000c000 l    d  .noinit_RAM5	00000000 .noinit_RAM5
10000198 l    d  .noinit	00000000 .noinit
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 cr_startup_lpc43xx.c
00000000 l    df *ABS*	00000000 sapi_uart.c
00000000 l    df *ABS*	00000000 crp.c
00000000 l    df *ABS*	00000000 Ascensor.c
00000000 l    df *ABS*	00000000 MEFAscensorPuertas.c
10000060 l     O .bss	00000018 timAbreCierraPuerta
10000078 l     O .bss	00000018 timAlarPuerta
10000090 l     O .bss	00000018 timPisoPiso
100000a8 l     O .bss	00000018 timPuertaAbierta
100000c0 l     O .bss	00000018 timRetornoPB
00000000 l    df *ABS*	00000000 MEF_tecladoMatricial.c
100000d8 l     O .bss	00000002 confirmar
100000e0 l     O .bss	00000018 delayAntirebote
100000f8 l     O .bss	00000001 estadoMefScanTeclado
100000f9 l     O .bss	00000001 estadoMefTecladoMatricial
100000fa l     O .bss	00000001 flagEstadoApretandoTecla
100000fb l     O .bss	00000001 hayTeclaDisponible
10000100 l     O .bss	00000004 indiceTeclaPresionada
10000104 l     O .bss	00000002 key
10000106 l     O .bss	00000002 primerDigito
10000108 l     O .bss	00000002 segundoDigito
1000000c l     O .data	00000002 teclaPresionada
1a0028b0 l     O .text	00000004 pinesColumna
1a0028b4 l     O .text	00000004 pinesFila
1a0028b8 l     O .text	00000020 pinesTeclado
00000000 l    df *ABS*	00000000 Test.c
00000000 l    df *ABS*	00000000 driverDisplay.c
1000010a l     O .bss	00000001 centenasB
1000010b l     O .bss	00000001 decenasB
1000010c l     O .bss	00000001 secuenciaB
1000010d l     O .bss	00000001 unidadesB
1000010e l     O .bss	00000001 unidadesmilB
1a002af8 l     O .text	0000001b numeroadisplayB
1a002b14 l     O .text	00000004 quedisplayB
1a002b18 l     O .text	00000008 segmentosdisplayB
00000000 l    df *ABS*	00000000 modoConfiguracion.c
10000110 l     O .bss	00000004 datoRecibido.11864
10000114 l     O .bss	00000001 flagCase1.11855
10000115 l     O .bss	00000001 flagCase2.11856
10000116 l     O .bss	00000001 flagCase3.11857
10000117 l     O .bss	00000001 flagCase4.11858
10000118 l     O .bss	00000001 flagDatoMenu.11861
10000119 l     O .bss	00000001 flagMenu.11860
1000011c l     O .bss	0000000a numeroEnString
00000000 l    df *ABS*	00000000 chip_18xx_43xx.c
00000000 l    df *ABS*	00000000 clock_18xx_43xx.c
1a001484 l     F .text	000000a0 pll_calc_divs
1a001524 l     F .text	00000100 pll_get_frac
1a001624 l     F .text	0000004c Chip_Clock_FindBaseClock
1a001898 l     F .text	00000022 Chip_Clock_GetDivRate
10000128 l     O .bss	00000008 audio_usb_pll_freq
1a002d44 l     O .text	0000006c periph_to_base
00000000 l    df *ABS*	00000000 fpu_init.c
00000000 l    df *ABS*	00000000 gpio_18xx_43xx.c
00000000 l    df *ABS*	00000000 sysinit_18xx_43xx.c
1a002db0 l     O .text	00000048 InitClkStates
00000000 l    df *ABS*	00000000 uart_18xx_43xx.c
1a001ba4 l     F .text	0000002c Chip_UART_GetIndex
1a002df8 l     O .text	00000008 UART_BClock
1a002e00 l     O .text	00000008 UART_PClock
00000000 l    df *ABS*	00000000 board.c
1a001d4c l     F .text	00000044 Board_LED_Init
1a002e10 l     O .text	0000000c gpioLEDBits
00000000 l    df *ABS*	00000000 board_sysinit.c
1a002e1c l     O .text	0000000c InitClkStates
1a002e28 l     O .text	00000060 pinmuxing
00000000 l    df *ABS*	00000000 sysinit.c
00000000 l    df *ABS*	00000000 sapi_board.c
00000000 l    df *ABS*	00000000 sapi_datatypes.c
00000000 l    df *ABS*	00000000 sapi_delay.c
00000000 l    df *ABS*	00000000 sapi_gpio.c
1a002080 l     F .text	00000034 gpioObtainPinConfig
00000000 l    df *ABS*	00000000 sapi_tick.c
00000000 l    df *ABS*	00000000 sapi_timer.c
1a002390 l     F .text	00000002 errorOcurred
1a002392 l     F .text	00000002 doNothing
10000014 l     O .data	00000040 timer_dd
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 
1a000300 l       .text	00000000 __CRP_WORD_END__
1a0002fc l       .text	00000000 __CRP_WORD_START__
1a0016bc g     F .text	0000001c Chip_Clock_GetDividerSource
1a000a74 g     F .text	00000084 ingresarDigito
1a002414 g     F .text	00000044 TIMER2_IRQHandler
1a000184  w    F .text	00000002 DebugMon_Handler
1a00018a  w    F .text	00000002 RIT_IRQHandler
1a080000 g       *ABS*	00000000 __top_MFlashA512
1a00018a  w    F .text	00000002 ADCHS_IRQHandler
1a000114 g       .text	00000000 __section_table_start
1a00018a  w    F .text	00000002 FLASH_EEPROM_IRQHandler
1a00018a  w    F .text	00000002 I2C0_IRQHandler
1a002500 g     F .text	00000044 uartReadByte
1a001a26 g     F .text	00000024 Chip_GPIO_SetDir
1a0007c8 g     F .text	00000114 ActualizaMEFPuerta
10000000 g     O .data	00000001 maximoDePisos
10000001 g     O .data	00000001 maximoDeSubsuelos
1a002040 g     F .text	0000003e delayRead
1a00017a  w    F .text	00000002 HardFault_Handler
1a000000 g       *ABS*	00000000 __vectors_start__
1a00236c g     F .text	00000024 SysTick_Handler
1a001c24 g     F .text	00000040 Chip_UART_SetBaud
1a00018a  w    F .text	00000002 SDIO_IRQHandler
1a00018a  w    F .text	00000002 ATIMER_IRQHandler
10000174 g     O .bss	0000000a numeroEnString
1a000186  w    F .text	00000002 PendSV_Handler
1a000914 g     F .text	0000001c InicializarMEF_tecladoMatrical
1a000178  w    F .text	00000002 NMI_Handler
1a002fc8 g       .ARM.exidx	00000000 __exidx_end
1a000150 g       .text	00000000 __data_section_table_end
1a00018a  w    F .text	00000002 I2C1_IRQHandler
1a00018a  w    F .text	00000002 UART1_IRQHandler
1a00018a  w    F .text	00000002 GPIO5_IRQHandler
1a00018a  w    F .text	00000002 CAN1_IRQHandler
53ff59ea g       *ABS*	00000000 __valid_user_code_checksum
1a001120 g     F .text	00000068 itoa_2
1a002fc8 g       .ARM.exidx	00000000 _etext
1a00018a  w    F .text	00000002 USB1_IRQHandler
1000005e g     O .bss	00000001 pisoDestino
1a00018a  w    F .text	00000002 I2S0_IRQHandler
10000058 g     O .bss	00000004 flag1DW
1a002458 g     F .text	00000044 TIMER3_IRQHandler
1a00193a g     F .text	0000000c Chip_Clock_GetBaseClocktHz
1a0001bc g     F .text	00000002 UART0_IRQHandler
1a0001aa g     F .text	00000012 bss_init
1a00018a  w    F .text	00000002 SGPIO_IRQHandler
1000005c g     O .bss	00000001 flagConfiguracion
1a002590 g     F .text	00000000 .hidden __aeabi_uldivmod
10000198 g       .noinit	00000000 _noinit
1a002574 g     F .text	00000018 uartWriteString
10000180 g     O .bss	00000004 SystemCoreClock
1a001bd0 g     F .text	00000054 Chip_UART_Init
1a00018a  w    F .text	00000002 ADC0_IRQHandler
1a002020 g     F .text	00000020 delayConfig
1a000180  w    F .text	00000002 UsageFault_Handler
100000fc g     O .bss	00000004 indice
1a001984 g     F .text	0000004c Chip_Clock_GetRate
1a00018a  w    F .text	00000002 GPIO6_IRQHandler
10000188 g     O .bss	00000008 tickCounter
1a001e2c g     F .text	0000006c Board_SetupClocking
20008000 g       *ABS*	00000000 __top_RamAHB32
1a000c60 g     F .text	00000068 itoa
1a0025c0 g     F .text	000002dc .hidden __udivmoddi4
1a002e08 g     O .text	00000004 ExtRateIn
1a00018a  w    F .text	00000002 IntDefaultHandler
10000148 g     O .bss	00000001 estadoActualAsc
1a00018a  w    F .text	00000002 GPIO1_IRQHandler
1a0022e8 g     F .text	00000078 tickConfig
1a00018a  w    F .text	00000002 SSP0_IRQHandler
1a0020b4 g     F .text	00000174 gpioConfig
1a002fc0 g       .text	00000000 __exidx_start
1a0002fc g     O .text	00000004 CRP_WORD
1000005d g     O .bss	00000001 pisoActual
1a00018a  w    F .text	00000002 ADC1_IRQHandler
10000008 g     O .data	00000004 velPisoPiso
1a001dcc g     F .text	00000028 Board_Init
1a000114 g       .text	00000000 __data_section_table
1a00018a  w    F .text	00000002 RTC_IRQHandler
10000198 g       .bss	00000000 _ebss
1a002394 g     F .text	00000040 TIMER0_IRQHandler
20010000 g       *ABS*	00000000 __top_RamAHB_ETB16
1a00018a  w    F .text	00000002 SPI_IRQHandler
1a000af8 g     F .text	00000044 guardarPisoSimple
1a00018a  w    F .text	00000002 LCD_IRQHandler
1a001670 g     F .text	0000004c Chip_Clock_EnableCrystal
1a001f2c g     F .text	000000ee boardConfig
1a000b3c g     F .text	00000068 guardarPisoDoble
10008000 g       *ABS*	00000000 __top_RamLoc32
1a000f1c g     F .text	0000005c SacaDigito
1a00018c g     F .text	0000001e data_init
10000149 g     O .bss	00000001 estadoActualPuerta
1a0023d4 g     F .text	00000040 TIMER1_IRQHandler
1a00258c g     F .text	00000002 UART2_IRQHandler
1a00182c g     F .text	0000006c Chip_Clock_GetMainPLLHz
1a00201a g     F .text	00000004 sAPI_NullFuncPtr
1a002544 g     F .text	00000030 uartWriteByte
1a0022d2 g     F .text	00000016 gpioToggle
1a00018a  w    F .text	00000002 GPIO2_IRQHandler
1a001914 g     F .text	00000026 Chip_Clock_GetBaseClock
1a0003b8 g     F .text	00000038 InicializarMEFAsc
1a000fb8 g     F .text	00000168 ActualizarDisplay
10000058 g       .bss	00000000 _bss
1a00018a  w    F .text	00000002 I2S1_IRQHandler
1a000300 g     F .text	0000000a IntTimer
1a001a24 g     F .text	00000002 Chip_GPIO_Init
1a002e0c g     O .text	00000004 OscRateIn
10000198 g       .noinit	00000000 _end_noinit
10008000 g       *ABS*	00000000 _vStackTop
1a000cfc g     F .text	000001d4 EnviaEstadoInterno
1a00018a  w    F .text	00000002 SSP1_IRQHandler
1a000178 g       .text	00000000 __bss_section_table_end
1a0009c4 g     F .text	000000b0 ActualizaMEFScanTecla
1a00289c  w    F .text	00000002 .hidden __aeabi_ldiv0
1a00018a  w    F .text	00000002 USB0_IRQHandler
1a00018a  w    F .text	00000002 GPIO3_IRQHandler
1a00018a  w    F .text	00000002 SCT_IRQHandler
1a0016d8 g     F .text	0000001c Chip_Clock_GetDividerDivisor
1a0028a0 g     F .text	00000010 memset
1a00017c  w    F .text	00000002 MemManage_Handler
1a00030c g     F .text	000000ac main
1a00018a  w    F .text	00000002 WDT_IRQHandler
2000c000 g       *ABS*	00000000 __top_RamAHB16
1008a000 g       *ABS*	00000000 __top_RamLoc40
1a000182  w    F .text	00000002 SVC_Handler
1a000444 g     F .text	00000064 CargaNuevoPiso
1a0008dc g     F .text	00000038 configurarTecladoMatricial
1a00018a  w    F .text	00000002 GPIO7_IRQHandler
1a001948 g     F .text	0000003c Chip_Clock_EnableOpts
1a002e88 g     O .text	00000136 gpioPinsConfig
1a0004a8 g     F .text	00000320 ActualizarMEFAsc
1a0003f0 g     F .text	00000054 InicializarMEFPuerta
1a0016f4 g     F .text	000000b8 Chip_Clock_GetClockInputHz
1a0019d0 g     F .text	00000054 fpuInit
1a0017ac g     F .text	00000080 Chip_Clock_CalcMainPLLValue
1a001f20 g     F .text	0000000c SystemInit
1a00018a  w    F .text	00000002 SPIFI_IRQHandler
1a00018a  w    F .text	00000002 QEI_IRQHandler
1000014c g     O .bss	00000028 almacenarPisos
1a000150 g       .text	00000000 __bss_section_table
1a000ba4 g     F .text	000000bc ActualizarMEF_tecladoMatricial
1a002228 g     F .text	00000056 gpioWrite
1a001df4 g     F .text	00000038 Board_SetupMuxing
1a001c64 g     F .text	000000e8 Chip_UART_SetBaudFDR
1a002360 g     F .text	0000000c tickRead
10000190 g     O .bss	00000008 tickRateMS
1a00018a  w    F .text	00000002 ETH_IRQHandler
10000010 g     O .data	00000004 tickHookFunction
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
1a00018a  w    F .text	00000002 CAN0_IRQHandler
1a000930 g     F .text	00000094 ScanTeclas
10000000 g       .data	00000000 _data
1a000cc8 g     F .text	00000034 uartWriteMiDato
10000198 g       .bss	00000000 _pvHeapStart
1a000178 g       .text	00000000 __section_table_end
1a00249c g     F .text	00000064 uartConfig
1a00018a  w    F .text	00000002 GINT0_IRQHandler
1a00018a  w    F .text	00000002 DAC_IRQHandler
1a001da4 g     F .text	00000028 Board_Debug_Init
10000054 g       .data	00000000 _edata
1a00018a  w    F .text	00000002 M0SUB_IRQHandler
1a001a4c g     F .text	00000158 Chip_SetupCoreClock
1a00018a  w    F .text	00000002 GPIO0_IRQHandler
1a000000 g     O .text	00000114 g_pfnVectors
1a001ea4 g     F .text	0000007c ResetISR
1a001470 g     F .text	00000014 SystemCoreClockUpdate
1a001188 g     F .text	000002e8 modoConfiguracion
1a00018a  w    F .text	00000002 DMA_IRQHandler
1a00018a  w    F .text	00000002 EVRT_IRQHandler
1b080000 g       *ABS*	00000000 __top_MFlashB512
1a00289c  w    F .text	00000002 .hidden __aeabi_idiv0
1a00017e  w    F .text	00000002 BusFault_Handler
1a00258e g     F .text	00000002 UART3_IRQHandler
1a00018a  w    F .text	00000002 MCPWM_IRQHandler
1a00018a  w    F .text	00000002 M0APP_IRQHandler
1a00227e g     F .text	00000054 gpioRead
10000130 g     O .bss	00000018 timSerial
1a000f78 g     F .text	00000040 ConvierteByte
1a00018a  w    F .text	00000002 GINT1_IRQHandler
1a001d90 g     F .text	00000014 Board_UART_Init
1a000ed0 g     F .text	0000004c ConfigDisplay
1a0018bc g     F .text	00000058 Chip_Clock_SetBaseClock
1a00018a  w    F .text	00000002 GPIO4_IRQHandler
10000004 g     O .data	00000004 velAbreCierraPuerta
1a001e98 g     F .text	0000000c Board_SystemInit



Disassembly of section .text:

1a000000 <g_pfnVectors>:
1a000000:	00 80 00 10 a5 1e 00 1a 79 01 00 1a 7b 01 00 1a     ........y...{...
1a000010:	7d 01 00 1a 7f 01 00 1a 81 01 00 1a ea 59 ff 53     }............Y.S
	...
1a00002c:	83 01 00 1a 85 01 00 1a 00 00 00 00 87 01 00 1a     ................
1a00003c:	6d 23 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     m#..............
1a00004c:	00 00 00 00 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00005c:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00006c:	8b 01 00 1a 95 23 00 1a d5 23 00 1a 15 24 00 1a     .....#...#...$..
1a00007c:	59 24 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     Y$..............
1a00008c:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00009c:	8b 01 00 1a bd 01 00 1a 8b 01 00 1a 8d 25 00 1a     .............%..
1a0000ac:	8f 25 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     .%..............
1a0000bc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000cc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000dc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000ec:	8b 01 00 1a 00 00 00 00 8b 01 00 1a 8b 01 00 1a     ................
1a0000fc:	8b 01 00 1a 00 00 00 00 8b 01 00 1a 8b 01 00 1a     ................
1a00010c:	8b 01 00 1a 8b 01 00 1a                             ........

1a000114 <__data_section_table>:
1a000114:	1a002fc8 	.word	0x1a002fc8
1a000118:	10000000 	.word	0x10000000
1a00011c:	00000054 	.word	0x00000054
1a000120:	1a002fc8 	.word	0x1a002fc8
1a000124:	10080000 	.word	0x10080000
1a000128:	00000000 	.word	0x00000000
1a00012c:	1a002fc8 	.word	0x1a002fc8
1a000130:	20000000 	.word	0x20000000
1a000134:	00000000 	.word	0x00000000
1a000138:	1a002fc8 	.word	0x1a002fc8
1a00013c:	20008000 	.word	0x20008000
1a000140:	00000000 	.word	0x00000000
1a000144:	1a002fc8 	.word	0x1a002fc8
1a000148:	2000c000 	.word	0x2000c000
1a00014c:	00000000 	.word	0x00000000

1a000150 <__bss_section_table>:
1a000150:	10000058 	.word	0x10000058
1a000154:	00000140 	.word	0x00000140
1a000158:	10080000 	.word	0x10080000
1a00015c:	00000000 	.word	0x00000000
1a000160:	20000000 	.word	0x20000000
1a000164:	00000000 	.word	0x00000000
1a000168:	20008000 	.word	0x20008000
1a00016c:	00000000 	.word	0x00000000
1a000170:	2000c000 	.word	0x2000c000
1a000174:	00000000 	.word	0x00000000

1a000178 <NMI_Handler>:
//*****************************************************************************
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void) {
1a000178:	e7fe      	b.n	1a000178 <NMI_Handler>

1a00017a <HardFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void) {
1a00017a:	e7fe      	b.n	1a00017a <HardFault_Handler>

1a00017c <MemManage_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void MemManage_Handler(void) {
1a00017c:	e7fe      	b.n	1a00017c <MemManage_Handler>

1a00017e <BusFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void BusFault_Handler(void) {
1a00017e:	e7fe      	b.n	1a00017e <BusFault_Handler>

1a000180 <UsageFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void UsageFault_Handler(void) {
1a000180:	e7fe      	b.n	1a000180 <UsageFault_Handler>

1a000182 <SVC_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void) {
1a000182:	e7fe      	b.n	1a000182 <SVC_Handler>

1a000184 <DebugMon_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void DebugMon_Handler(void) {
1a000184:	e7fe      	b.n	1a000184 <DebugMon_Handler>

1a000186 <PendSV_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void) {
1a000186:	e7fe      	b.n	1a000186 <PendSV_Handler>
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void) {
1a000188:	e7fe      	b.n	1a000188 <PendSV_Handler+0x2>

1a00018a <ADC0_IRQHandler>:
// Processor ends up here if an unexpected interrupt occurs or a specific
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void) {
1a00018a:	e7fe      	b.n	1a00018a <ADC0_IRQHandler>

1a00018c <data_init>:
    for (loop = 0; loop < len; loop = loop + 4)
1a00018c:	2300      	movs	r3, #0
1a00018e:	4293      	cmp	r3, r2
1a000190:	d20a      	bcs.n	1a0001a8 <data_init+0x1c>
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
1a000192:	b410      	push	{r4}
        *pulDest++ = *pulSrc++;
1a000194:	6804      	ldr	r4, [r0, #0]
1a000196:	600c      	str	r4, [r1, #0]
    for (loop = 0; loop < len; loop = loop + 4)
1a000198:	3304      	adds	r3, #4
        *pulDest++ = *pulSrc++;
1a00019a:	3004      	adds	r0, #4
1a00019c:	3104      	adds	r1, #4
    for (loop = 0; loop < len; loop = loop + 4)
1a00019e:	4293      	cmp	r3, r2
1a0001a0:	d3f8      	bcc.n	1a000194 <data_init+0x8>
}
1a0001a2:	f85d 4b04 	ldr.w	r4, [sp], #4
1a0001a6:	4770      	bx	lr
1a0001a8:	4770      	bx	lr

1a0001aa <bss_init>:
    for (loop = 0; loop < len; loop = loop + 4)
1a0001aa:	2300      	movs	r3, #0
1a0001ac:	e003      	b.n	1a0001b6 <bss_init+0xc>
        *pulDest++ = 0;
1a0001ae:	2200      	movs	r2, #0
1a0001b0:	6002      	str	r2, [r0, #0]
    for (loop = 0; loop < len; loop = loop + 4)
1a0001b2:	3304      	adds	r3, #4
        *pulDest++ = 0;
1a0001b4:	3004      	adds	r0, #4
    for (loop = 0; loop < len; loop = loop + 4)
1a0001b6:	428b      	cmp	r3, r1
1a0001b8:	d3f9      	bcc.n	1a0001ae <bss_init+0x4>
}
1a0001ba:	4770      	bx	lr

1a0001bc <UART0_IRQHandler>:
/*==================[ISR external functions definition]======================*/

__attribute__ ((section(".after_vectors")))

/* 0x28 0x000000A0 - Handler for ISR UART0 (IRQ 24) */
void UART0_IRQHandler(void){
1a0001bc:	4770      	bx	lr
1a0001be:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001c2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001c6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ce:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001d2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001d6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001da:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001de:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ea:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ee:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001fa:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001fe:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000202:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000206:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00020a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00020e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000212:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000216:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00021a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00021e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000222:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000226:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00022a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00022e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000232:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000236:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00023a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00023e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000242:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000246:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00024a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00024e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000252:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000256:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00025a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00025e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000262:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000266:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00026a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00026e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000272:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000276:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00027a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00027e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000282:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000286:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00028a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00028e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000292:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000296:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00029a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00029e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002aa:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ae:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ba:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002be:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ce:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002da:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002de:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ea:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ee:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002fa:	Address 0x1a0002fa is out of bounds.


1a0002fc <CRP_WORD>:
1a0002fc:	ffff ffff                                   ....

1a000300 <IntTimer>:

//*************************************************************************************************
//			InterrupciÃ³n cada 5ms
//*************************************************************************************************
bool_t IntTimer (void *ptr)
{
1a000300:	b508      	push	{r3, lr}


// Llama a la rutina que actualiza el display de 4 digitos de 7 segmentos.
ActualizarDisplay();
1a000302:	f000 fe59 	bl	1a000fb8 <ActualizarDisplay>
	

return 1;
}
1a000306:	2001      	movs	r0, #1
1a000308:	bd08      	pop	{r3, pc}
1a00030a:	Address 0x1a00030a is out of bounds.


1a00030c <main>:


/*==================[funcion principal]======================================*/

// FUNCION PRINCIPAL, PUNTO DE ENTRADA AL PROGRAMA LUEGO DE ENCENDIDO O RESET.
int main( void ){
1a00030c:	b508      	push	{r3, lr}

// ---------- CONFIGURACIONES ------------------------------
// Inicializar y configurar la plataforma
boardConfig();   
1a00030e:	f001 fe0d 	bl	1a001f2c <boardConfig>

// Interupcion cada 5ms.
tickConfig (5, IntTimer);
1a000312:	4a24      	ldr	r2, [pc, #144]	; (1a0003a4 <main+0x98>)
1a000314:	2005      	movs	r0, #5
1a000316:	2100      	movs	r1, #0
1a000318:	f001 ffe6 	bl	1a0022e8 <tickConfig>

// ConfiguraciÃ³n de pines para el display 7 segmentos
ConfigDisplay();
1a00031c:	f000 fdd8 	bl	1a000ed0 <ConfigDisplay>

// Se inicializa la MEF que maneja el teclado matricial
InicializarMEF_tecladoMatrical();
1a000320:	f000 faf8 	bl	1a000914 <InicializarMEF_tecladoMatrical>


// Se inicializa la MEF que maneja el ascensor.
InicializarMEFAsc();
1a000324:	f000 f848 	bl	1a0003b8 <InicializarMEFAsc>

// Se inicializa la MEF que maneja la puerta del ascensor.
InicializarMEFPuerta();
1a000328:	f000 f862 	bl	1a0003f0 <InicializarMEFPuerta>



// UART_USB a 115200 baudios.
uartConfig( UART_USB, 115200 );
1a00032c:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
1a000330:	2000      	movs	r0, #0
1a000332:	f002 f8b3 	bl	1a00249c <uartConfig>
delayConfig(&timSerial, 200);   
1a000336:	22c8      	movs	r2, #200	; 0xc8
1a000338:	2300      	movs	r3, #0
1a00033a:	481b      	ldr	r0, [pc, #108]	; (1a0003a8 <main+0x9c>)
1a00033c:	f001 fe70 	bl	1a002020 <delayConfig>
1a000340:	e003      	b.n	1a00034a <main+0x3e>
if (delayRead(&timSerial))
	{
	if (estadoActualAsc != MODO_CONFIGURACION)
		EnviaEstadoInterno();
	
	if (!gpioRead(TEC4))
1a000342:	2027      	movs	r0, #39	; 0x27
1a000344:	f001 ff9b 	bl	1a00227e <gpioRead>
1a000348:	b188      	cbz	r0, 1a00036e <main+0x62>
ActualizarMEF_tecladoMatricial();
1a00034a:	f000 fc2b 	bl	1a000ba4 <ActualizarMEF_tecladoMatricial>
ActualizarMEFAsc();
1a00034e:	f000 f8ab 	bl	1a0004a8 <ActualizarMEFAsc>
ActualizaMEFPuerta();
1a000352:	f000 fa39 	bl	1a0007c8 <ActualizaMEFPuerta>
if (delayRead(&timSerial))
1a000356:	4814      	ldr	r0, [pc, #80]	; (1a0003a8 <main+0x9c>)
1a000358:	f001 fe72 	bl	1a002040 <delayRead>
1a00035c:	2800      	cmp	r0, #0
1a00035e:	d0f4      	beq.n	1a00034a <main+0x3e>
	if (estadoActualAsc != MODO_CONFIGURACION)
1a000360:	4b12      	ldr	r3, [pc, #72]	; (1a0003ac <main+0xa0>)
1a000362:	781b      	ldrb	r3, [r3, #0]
1a000364:	2b05      	cmp	r3, #5
1a000366:	d0ec      	beq.n	1a000342 <main+0x36>
		EnviaEstadoInterno();
1a000368:	f000 fcc8 	bl	1a000cfc <EnviaEstadoInterno>
1a00036c:	e7e9      	b.n	1a000342 <main+0x36>
		{
		almacenarPisos[0] = 6;
1a00036e:	4b10      	ldr	r3, [pc, #64]	; (1a0003b0 <main+0xa4>)
1a000370:	2206      	movs	r2, #6
1a000372:	601a      	str	r2, [r3, #0]
		almacenarPisos[1] = 9;
1a000374:	2209      	movs	r2, #9
1a000376:	605a      	str	r2, [r3, #4]
		almacenarPisos[2] = 12;
1a000378:	220c      	movs	r2, #12
1a00037a:	609a      	str	r2, [r3, #8]
		almacenarPisos[3] = 17;
1a00037c:	2211      	movs	r2, #17
1a00037e:	60da      	str	r2, [r3, #12]
		almacenarPisos[4] = 20;
1a000380:	2214      	movs	r2, #20
1a000382:	611a      	str	r2, [r3, #16]
		almacenarPisos[5] = 10;
1a000384:	220a      	movs	r2, #10
1a000386:	615a      	str	r2, [r3, #20]
		almacenarPisos[6] = -5;
1a000388:	f06f 0104 	mvn.w	r1, #4
1a00038c:	6199      	str	r1, [r3, #24]
		almacenarPisos[7] = 5;
1a00038e:	2105      	movs	r1, #5
1a000390:	61d9      	str	r1, [r3, #28]
		almacenarPisos[8] = -3;
1a000392:	f06f 0102 	mvn.w	r1, #2
1a000396:	6219      	str	r1, [r3, #32]
		almacenarPisos[9] = 8;
1a000398:	2108      	movs	r1, #8
1a00039a:	6259      	str	r1, [r3, #36]	; 0x24
		indice = 10;
1a00039c:	4b05      	ldr	r3, [pc, #20]	; (1a0003b4 <main+0xa8>)
1a00039e:	601a      	str	r2, [r3, #0]
1a0003a0:	e7d3      	b.n	1a00034a <main+0x3e>
1a0003a2:	bf00      	nop
1a0003a4:	1a000301 	.word	0x1a000301
1a0003a8:	10000130 	.word	0x10000130
1a0003ac:	10000148 	.word	0x10000148
1a0003b0:	1000014c 	.word	0x1000014c
1a0003b4:	100000fc 	.word	0x100000fc

1a0003b8 <InicializarMEFAsc>:

//*********************************************************************************************************************
//		Función inicializar MEF del ascensor
//*********************************************************************************************************************
void InicializarMEFAsc(void)
{
1a0003b8:	b510      	push	{r4, lr}
// Estado inicial.
estadoActualAsc = EN_PLANTA_BAJA;
1a0003ba:	2400      	movs	r4, #0
1a0003bc:	4b08      	ldr	r3, [pc, #32]	; (1a0003e0 <InicializarMEFAsc+0x28>)
1a0003be:	701c      	strb	r4, [r3, #0]
gpioWrite (LED_PBDETENIDO, 1);
1a0003c0:	2101      	movs	r1, #1
1a0003c2:	202d      	movs	r0, #45	; 0x2d
1a0003c4:	f001 ff30 	bl	1a002228 <gpioWrite>


// Se Configura el tiempo de desplazamiento del ascensor.
delayConfig(&timPisoPiso, velPisoPiso);   
1a0003c8:	4b06      	ldr	r3, [pc, #24]	; (1a0003e4 <InicializarMEFAsc+0x2c>)
1a0003ca:	681a      	ldr	r2, [r3, #0]
1a0003cc:	4623      	mov	r3, r4
1a0003ce:	4806      	ldr	r0, [pc, #24]	; (1a0003e8 <InicializarMEFAsc+0x30>)
1a0003d0:	f001 fe26 	bl	1a002020 <delayConfig>

// Se Configura el tiempo de espera para retornar a la PB.
//delayConfig(&timRetornoPB, TRETORNOPB);   

// Resetea flag que indica ejecucion unica de bloque dentro de estado PARADO.
Clr_AscParadoFlag;
1a0003d4:	4a05      	ldr	r2, [pc, #20]	; (1a0003ec <InicializarMEFAsc+0x34>)
1a0003d6:	6813      	ldr	r3, [r2, #0]
1a0003d8:	f023 0301 	bic.w	r3, r3, #1
1a0003dc:	6013      	str	r3, [r2, #0]
1a0003de:	bd10      	pop	{r4, pc}
1a0003e0:	10000148 	.word	0x10000148
1a0003e4:	10000008 	.word	0x10000008
1a0003e8:	10000090 	.word	0x10000090
1a0003ec:	10000058 	.word	0x10000058

1a0003f0 <InicializarMEFPuerta>:

//*********************************************************************************************************************
//		Función inicializar MEF de la puerta del ascensor
//*********************************************************************************************************************
void InicializarMEFPuerta(void)
{
1a0003f0:	b510      	push	{r4, lr}
// Estado inicial.
estadoActualPuerta = PUERTA_CERRADA;
1a0003f2:	2400      	movs	r4, #0
1a0003f4:	4b0d      	ldr	r3, [pc, #52]	; (1a00042c <InicializarMEFPuerta+0x3c>)
1a0003f6:	701c      	strb	r4, [r3, #0]

// Se Configura el tiempo para el parpadeo del led de alarma indicador de puerta abierta, 0,5seg.
delayConfig(&timAlarPuerta, TALARMAPUERTA);   
1a0003f8:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
1a0003fc:	2300      	movs	r3, #0
1a0003fe:	480c      	ldr	r0, [pc, #48]	; (1a000430 <InicializarMEFPuerta+0x40>)
1a000400:	f001 fe0e 	bl	1a002020 <delayConfig>

// Se configura tiempo de apertura de la puerta.
delayConfig(&timAbreCierraPuerta, velAbreCierraPuerta);   
1a000404:	4b0b      	ldr	r3, [pc, #44]	; (1a000434 <InicializarMEFPuerta+0x44>)
1a000406:	681a      	ldr	r2, [r3, #0]
1a000408:	4623      	mov	r3, r4
1a00040a:	480b      	ldr	r0, [pc, #44]	; (1a000438 <InicializarMEFPuerta+0x48>)
1a00040c:	f001 fe08 	bl	1a002020 <delayConfig>

// Se configura tiempo que queda la puerta abierta.
delayConfig(&timPuertaAbierta, TPUETAABIERTA);   
1a000410:	f241 3288 	movw	r2, #5000	; 0x1388
1a000414:	2300      	movs	r3, #0
1a000416:	4809      	ldr	r0, [pc, #36]	; (1a00043c <InicializarMEFPuerta+0x4c>)
1a000418:	f001 fe02 	bl	1a002020 <delayConfig>

// Se configura tiempo que espera antes de retornar a Planta Baja.
delayConfig(&timRetornoPB, TRETORNOPB);
1a00041c:	f242 7210 	movw	r2, #10000	; 0x2710
1a000420:	2300      	movs	r3, #0
1a000422:	4807      	ldr	r0, [pc, #28]	; (1a000440 <InicializarMEFPuerta+0x50>)
1a000424:	f001 fdfc 	bl	1a002020 <delayConfig>
1a000428:	bd10      	pop	{r4, pc}
1a00042a:	bf00      	nop
1a00042c:	10000149 	.word	0x10000149
1a000430:	10000078 	.word	0x10000078
1a000434:	10000004 	.word	0x10000004
1a000438:	10000060 	.word	0x10000060
1a00043c:	100000a8 	.word	0x100000a8
1a000440:	100000c0 	.word	0x100000c0

1a000444 <CargaNuevoPiso>:
void CargaNuevoPiso(void)
{
uint8_t i ;

// Si indice es distinto de cero significa que hay algun piso cargado en el buffer.
if (indice && !Ask_PideNuevoPisoFlag)
1a000444:	4b13      	ldr	r3, [pc, #76]	; (1a000494 <CargaNuevoPiso+0x50>)
1a000446:	681b      	ldr	r3, [r3, #0]
1a000448:	b31b      	cbz	r3, 1a000492 <CargaNuevoPiso+0x4e>
1a00044a:	4a13      	ldr	r2, [pc, #76]	; (1a000498 <CargaNuevoPiso+0x54>)
1a00044c:	6812      	ldr	r2, [r2, #0]
1a00044e:	f012 0f10 	tst.w	r2, #16
1a000452:	d11e      	bne.n	1a000492 <CargaNuevoPiso+0x4e>
	{
	// Si el piso actual es distinto del piso destino, se lo fija como nuevo, si no solo se desplaza el buffer.
	if (pisoActual != almacenarPisos[0])
1a000454:	4a11      	ldr	r2, [pc, #68]	; (1a00049c <CargaNuevoPiso+0x58>)
1a000456:	f992 1000 	ldrsb.w	r1, [r2]
1a00045a:	4a11      	ldr	r2, [pc, #68]	; (1a0004a0 <CargaNuevoPiso+0x5c>)
1a00045c:	6812      	ldr	r2, [r2, #0]
1a00045e:	4291      	cmp	r1, r2
1a000460:	d006      	beq.n	1a000470 <CargaNuevoPiso+0x2c>
		{
		pisoDestino = almacenarPisos[0];
1a000462:	4910      	ldr	r1, [pc, #64]	; (1a0004a4 <CargaNuevoPiso+0x60>)
1a000464:	700a      	strb	r2, [r1, #0]
		Set_PideNuevoPisoFlag;
1a000466:	490c      	ldr	r1, [pc, #48]	; (1a000498 <CargaNuevoPiso+0x54>)
1a000468:	680a      	ldr	r2, [r1, #0]
1a00046a:	f042 0210 	orr.w	r2, r2, #16
1a00046e:	600a      	str	r2, [r1, #0]
		}
	indice--;
1a000470:	3b01      	subs	r3, #1
1a000472:	4a08      	ldr	r2, [pc, #32]	; (1a000494 <CargaNuevoPiso+0x50>)
1a000474:	6013      	str	r3, [r2, #0]
	for (i=0; i<9; i++)
1a000476:	2300      	movs	r3, #0
1a000478:	e006      	b.n	1a000488 <CargaNuevoPiso+0x44>
		almacenarPisos[i] = almacenarPisos[i+1];
1a00047a:	1c5a      	adds	r2, r3, #1
1a00047c:	4908      	ldr	r1, [pc, #32]	; (1a0004a0 <CargaNuevoPiso+0x5c>)
1a00047e:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
1a000482:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
	for (i=0; i<9; i++)
1a000486:	b2d3      	uxtb	r3, r2
1a000488:	2b08      	cmp	r3, #8
1a00048a:	d9f6      	bls.n	1a00047a <CargaNuevoPiso+0x36>
	almacenarPisos[9] = 0;
1a00048c:	2200      	movs	r2, #0
1a00048e:	4b04      	ldr	r3, [pc, #16]	; (1a0004a0 <CargaNuevoPiso+0x5c>)
1a000490:	625a      	str	r2, [r3, #36]	; 0x24
1a000492:	4770      	bx	lr
1a000494:	100000fc 	.word	0x100000fc
1a000498:	10000058 	.word	0x10000058
1a00049c:	1000005d 	.word	0x1000005d
1a0004a0:	1000014c 	.word	0x1000014c
1a0004a4:	1000005e 	.word	0x1000005e

1a0004a8 <ActualizarMEFAsc>:

//*********************************************************************************************************************
//		Función Actualizar MEF del Ascensor
//*********************************************************************************************************************
void ActualizarMEFAsc(void)
{
1a0004a8:	b510      	push	{r4, lr}


	

switch(estadoActualAsc)
1a0004aa:	4ba9      	ldr	r3, [pc, #676]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a0004ac:	781b      	ldrb	r3, [r3, #0]
1a0004ae:	2b05      	cmp	r3, #5
1a0004b0:	f200 8181 	bhi.w	1a0007b6 <ActualizarMEFAsc+0x30e>
1a0004b4:	e8df f013 	tbh	[pc, r3, lsl #1]
1a0004b8:	004f0006 	.word	0x004f0006
1a0004bc:	00ad007e 	.word	0x00ad007e
1a0004c0:	01780116 	.word	0x01780116
	{
	case EN_PLANTA_BAJA:
		// Se solicita la apertura de puertas, una sola vez.
		if (!Ask_PidioAperturaFlag)
1a0004c4:	4ba3      	ldr	r3, [pc, #652]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a0004c6:	681b      	ldr	r3, [r3, #0]
1a0004c8:	f013 0f08 	tst.w	r3, #8
1a0004cc:	d108      	bne.n	1a0004e0 <ActualizarMEFAsc+0x38>
			{
			Set_PidioAperturaFlag;
1a0004ce:	4ba1      	ldr	r3, [pc, #644]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a0004d0:	681a      	ldr	r2, [r3, #0]
1a0004d2:	f042 0208 	orr.w	r2, r2, #8
1a0004d6:	601a      	str	r2, [r3, #0]
			Set_AbrePuertasFlag;
1a0004d8:	681a      	ldr	r2, [r3, #0]
1a0004da:	f042 0202 	orr.w	r2, r2, #2
1a0004de:	601a      	str	r2, [r3, #0]
			}
		// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
		CargaNuevoPiso();
1a0004e0:	f7ff ffb0 	bl	1a000444 <CargaNuevoPiso>
		
		if (Ask_PideNuevoPisoFlag)
1a0004e4:	4b9b      	ldr	r3, [pc, #620]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a0004e6:	681b      	ldr	r3, [r3, #0]
1a0004e8:	f013 0f10 	tst.w	r3, #16
1a0004ec:	d014      	beq.n	1a000518 <ActualizarMEFAsc+0x70>
			{
			if (estadoActualPuerta == PUERTA_ABIERTA)
1a0004ee:	4b9a      	ldr	r3, [pc, #616]	; (1a000758 <ActualizarMEFAsc+0x2b0>)
1a0004f0:	781b      	ldrb	r3, [r3, #0]
1a0004f2:	2b02      	cmp	r3, #2
1a0004f4:	d01c      	beq.n	1a000530 <ActualizarMEFAsc+0x88>
				Set_CierraPuertasFlag;			// Pide cerrar puertas.
			
			
			if (estadoActualPuerta == PUERTA_CERRADA)
1a0004f6:	b97b      	cbnz	r3, 1a000518 <ActualizarMEFAsc+0x70>
				{
				if (pisoActual < pisoDestino)
1a0004f8:	4b98      	ldr	r3, [pc, #608]	; (1a00075c <ActualizarMEFAsc+0x2b4>)
1a0004fa:	f993 2000 	ldrsb.w	r2, [r3]
1a0004fe:	4b98      	ldr	r3, [pc, #608]	; (1a000760 <ActualizarMEFAsc+0x2b8>)
1a000500:	f993 3000 	ldrsb.w	r3, [r3]
1a000504:	429a      	cmp	r2, r3
1a000506:	da19      	bge.n	1a00053c <ActualizarMEFAsc+0x94>
					{
					
					// El piso destino se encuentra arriba.
					estadoActualAsc = SUBIENDO;
1a000508:	2201      	movs	r2, #1
1a00050a:	4b91      	ldr	r3, [pc, #580]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a00050c:	701a      	strb	r2, [r3, #0]
					Clr_PidioAperturaFlag;
1a00050e:	4a91      	ldr	r2, [pc, #580]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a000510:	6813      	ldr	r3, [r2, #0]
1a000512:	f023 0308 	bic.w	r3, r3, #8
1a000516:	6013      	str	r3, [r2, #0]
					}
				}
			}
		
		// Se consulta si pide modo Configuracion.
		if (flagConfiguracion)
1a000518:	4b92      	ldr	r3, [pc, #584]	; (1a000764 <ActualizarMEFAsc+0x2bc>)
1a00051a:	781b      	ldrb	r3, [r3, #0]
1a00051c:	2b00      	cmp	r3, #0
1a00051e:	f000 814c 	beq.w	1a0007ba <ActualizarMEFAsc+0x312>
			{
			flagConfiguracion = 0;
1a000522:	2200      	movs	r2, #0
1a000524:	4b8f      	ldr	r3, [pc, #572]	; (1a000764 <ActualizarMEFAsc+0x2bc>)
1a000526:	701a      	strb	r2, [r3, #0]
			estadoActualAsc = MODO_CONFIGURACION;
1a000528:	2205      	movs	r2, #5
1a00052a:	4b89      	ldr	r3, [pc, #548]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a00052c:	701a      	strb	r2, [r3, #0]
1a00052e:	bd10      	pop	{r4, pc}
				Set_CierraPuertasFlag;			// Pide cerrar puertas.
1a000530:	4988      	ldr	r1, [pc, #544]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a000532:	680a      	ldr	r2, [r1, #0]
1a000534:	f042 0204 	orr.w	r2, r2, #4
1a000538:	600a      	str	r2, [r1, #0]
1a00053a:	e7dc      	b.n	1a0004f6 <ActualizarMEFAsc+0x4e>
					Set_CierraPuertasFlag;
1a00053c:	4b85      	ldr	r3, [pc, #532]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a00053e:	681a      	ldr	r2, [r3, #0]
1a000540:	f042 0204 	orr.w	r2, r2, #4
1a000544:	601a      	str	r2, [r3, #0]
					estadoActualAsc = BAJANDO;
1a000546:	2102      	movs	r1, #2
1a000548:	4a81      	ldr	r2, [pc, #516]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a00054a:	7011      	strb	r1, [r2, #0]
					Clr_PidioAperturaFlag;
1a00054c:	681a      	ldr	r2, [r3, #0]
1a00054e:	f022 0208 	bic.w	r2, r2, #8
1a000552:	601a      	str	r2, [r3, #0]
1a000554:	e7e0      	b.n	1a000518 <ActualizarMEFAsc+0x70>

		break;
			
	case SUBIENDO:
		// Se cerraron las puertas cambia de estado?
		if (estadoActualPuerta == PUERTA_CERRADA)
1a000556:	4b80      	ldr	r3, [pc, #512]	; (1a000758 <ActualizarMEFAsc+0x2b0>)
1a000558:	781b      	ldrb	r3, [r3, #0]
1a00055a:	2b00      	cmp	r3, #0
1a00055c:	f040 812d 	bne.w	1a0007ba <ActualizarMEFAsc+0x312>
			{
			gpioWrite (LED_PBDETENIDO, 0);
1a000560:	2100      	movs	r1, #0
1a000562:	202d      	movs	r0, #45	; 0x2d
1a000564:	f001 fe60 	bl	1a002228 <gpioWrite>
			gpioWrite (LED_ASCMOVIENDO, 1);
1a000568:	2101      	movs	r1, #1
1a00056a:	202a      	movs	r0, #42	; 0x2a
1a00056c:	f001 fe5c 	bl	1a002228 <gpioWrite>
	
			// SALIDA EN EL ESTADO:
			// Se hace subir el ascensor, demorara en subir lo configurado en "velPisoPiso".
			if (delayRead(&timPisoPiso))
1a000570:	487d      	ldr	r0, [pc, #500]	; (1a000768 <ActualizarMEFAsc+0x2c0>)
1a000572:	f001 fd65 	bl	1a002040 <delayRead>
1a000576:	2800      	cmp	r0, #0
1a000578:	f000 811f 	beq.w	1a0007ba <ActualizarMEFAsc+0x312>
				{
				pisoActual = pisoActual + 1;
1a00057c:	4a77      	ldr	r2, [pc, #476]	; (1a00075c <ActualizarMEFAsc+0x2b4>)
1a00057e:	7813      	ldrb	r3, [r2, #0]
1a000580:	3301      	adds	r3, #1
1a000582:	b25b      	sxtb	r3, r3
1a000584:	7013      	strb	r3, [r2, #0]
				//Se consulta si llego.
				if (pisoActual == pisoDestino)
1a000586:	4a76      	ldr	r2, [pc, #472]	; (1a000760 <ActualizarMEFAsc+0x2b8>)
1a000588:	f992 2000 	ldrsb.w	r2, [r2]
1a00058c:	4293      	cmp	r3, r2
1a00058e:	f040 8114 	bne.w	1a0007ba <ActualizarMEFAsc+0x312>
					{
					// CAMBIO DE ESTADO:
					estadoActualAsc = PARADO;
1a000592:	2203      	movs	r2, #3
1a000594:	4b6e      	ldr	r3, [pc, #440]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a000596:	701a      	strb	r2, [r3, #0]
					Clr_PideNuevoPisoFlag;
1a000598:	4a6e      	ldr	r2, [pc, #440]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a00059a:	6813      	ldr	r3, [r2, #0]
1a00059c:	f023 0310 	bic.w	r3, r3, #16
1a0005a0:	6013      	str	r3, [r2, #0]
					gpioWrite (LED_ASCMOVIENDO, 0);
1a0005a2:	2100      	movs	r1, #0
1a0005a4:	202a      	movs	r0, #42	; 0x2a
1a0005a6:	f001 fe3f 	bl	1a002228 <gpioWrite>
					gpioWrite (LED_PBDETENIDO, 1);
1a0005aa:	2101      	movs	r1, #1
1a0005ac:	202d      	movs	r0, #45	; 0x2d
1a0005ae:	f001 fe3b 	bl	1a002228 <gpioWrite>
1a0005b2:	bd10      	pop	{r4, pc}
			}
		break;

	case BAJANDO:
		// Se cerraron las puertas cambia de estado?
		if (estadoActualPuerta == PUERTA_CERRADA)
1a0005b4:	4b68      	ldr	r3, [pc, #416]	; (1a000758 <ActualizarMEFAsc+0x2b0>)
1a0005b6:	781b      	ldrb	r3, [r3, #0]
1a0005b8:	2b00      	cmp	r3, #0
1a0005ba:	f040 80fe 	bne.w	1a0007ba <ActualizarMEFAsc+0x312>
			{
			gpioWrite (LED_PBDETENIDO, 0);
1a0005be:	2100      	movs	r1, #0
1a0005c0:	202d      	movs	r0, #45	; 0x2d
1a0005c2:	f001 fe31 	bl	1a002228 <gpioWrite>
			gpioWrite (LED_ASCMOVIENDO, 1);
1a0005c6:	2101      	movs	r1, #1
1a0005c8:	202a      	movs	r0, #42	; 0x2a
1a0005ca:	f001 fe2d 	bl	1a002228 <gpioWrite>
		
			// SALIDA EN EL ESTADO:
			// Se hace bajar el ascensor, demorara en subir lo configurado en "velPisoPiso".
			if (delayRead(&timPisoPiso))
1a0005ce:	4866      	ldr	r0, [pc, #408]	; (1a000768 <ActualizarMEFAsc+0x2c0>)
1a0005d0:	f001 fd36 	bl	1a002040 <delayRead>
1a0005d4:	2800      	cmp	r0, #0
1a0005d6:	f000 80f0 	beq.w	1a0007ba <ActualizarMEFAsc+0x312>
				{
				pisoActual = pisoActual - 1;
1a0005da:	4a60      	ldr	r2, [pc, #384]	; (1a00075c <ActualizarMEFAsc+0x2b4>)
1a0005dc:	7813      	ldrb	r3, [r2, #0]
1a0005de:	3b01      	subs	r3, #1
1a0005e0:	b25b      	sxtb	r3, r3
1a0005e2:	7013      	strb	r3, [r2, #0]
				//Se consulta si llego.
				if (pisoActual == pisoDestino)
1a0005e4:	4a5e      	ldr	r2, [pc, #376]	; (1a000760 <ActualizarMEFAsc+0x2b8>)
1a0005e6:	f992 2000 	ldrsb.w	r2, [r2]
1a0005ea:	4293      	cmp	r3, r2
1a0005ec:	f040 80e5 	bne.w	1a0007ba <ActualizarMEFAsc+0x312>
					{
					// CAMBIO DE ESTADO:
					estadoActualAsc = PARADO;
1a0005f0:	2203      	movs	r2, #3
1a0005f2:	4b57      	ldr	r3, [pc, #348]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a0005f4:	701a      	strb	r2, [r3, #0]
					Clr_PideNuevoPisoFlag;
1a0005f6:	4a57      	ldr	r2, [pc, #348]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a0005f8:	6813      	ldr	r3, [r2, #0]
1a0005fa:	f023 0310 	bic.w	r3, r3, #16
1a0005fe:	6013      	str	r3, [r2, #0]
					gpioWrite (LED_ASCMOVIENDO, 0);
1a000600:	2100      	movs	r1, #0
1a000602:	202a      	movs	r0, #42	; 0x2a
1a000604:	f001 fe10 	bl	1a002228 <gpioWrite>
					gpioWrite (LED_PBDETENIDO, 1);
1a000608:	2101      	movs	r1, #1
1a00060a:	202d      	movs	r0, #45	; 0x2d
1a00060c:	f001 fe0c 	bl	1a002228 <gpioWrite>
1a000610:	bd10      	pop	{r4, pc}
			}
		break;

	case PARADO:
		// AL INGRESAR AL EL ESTADO SE EJECUTA POR UNICA VEZ:
		if (!Ask_AscParadoFlag)
1a000612:	4b50      	ldr	r3, [pc, #320]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a000614:	681b      	ldr	r3, [r3, #0]
1a000616:	f013 0f01 	tst.w	r3, #1
1a00061a:	d115      	bne.n	1a000648 <ActualizarMEFAsc+0x1a0>
			{
			if (estadoActualPuerta == PUERTA_CERRADA)
1a00061c:	4b4e      	ldr	r3, [pc, #312]	; (1a000758 <ActualizarMEFAsc+0x2b0>)
1a00061e:	781b      	ldrb	r3, [r3, #0]
1a000620:	b163      	cbz	r3, 1a00063c <ActualizarMEFAsc+0x194>
				Set_AbrePuertasFlag;			// MEF ascensor solicita apertura de puertas
			else if (estadoActualPuerta == PUERTA_ABIERTA)
1a000622:	2b02      	cmp	r3, #2
1a000624:	f040 80c9 	bne.w	1a0007ba <ActualizarMEFAsc+0x312>
				{
				Set_CierraPuertasFlag;			// MEF ascensor solicita cierre de puertas
1a000628:	4b4a      	ldr	r3, [pc, #296]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a00062a:	681a      	ldr	r2, [r3, #0]
1a00062c:	f042 0204 	orr.w	r2, r2, #4
1a000630:	601a      	str	r2, [r3, #0]
				Set_AscParadoFlag;
1a000632:	681a      	ldr	r2, [r3, #0]
1a000634:	f042 0201 	orr.w	r2, r2, #1
1a000638:	601a      	str	r2, [r3, #0]
1a00063a:	bd10      	pop	{r4, pc}
				Set_AbrePuertasFlag;			// MEF ascensor solicita apertura de puertas
1a00063c:	4a45      	ldr	r2, [pc, #276]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a00063e:	6813      	ldr	r3, [r2, #0]
1a000640:	f043 0302 	orr.w	r3, r3, #2
1a000644:	6013      	str	r3, [r2, #0]
1a000646:	bd10      	pop	{r4, pc}
				}
			}
			
		else if (estadoActualPuerta == PUERTA_CERRADA)
1a000648:	4b43      	ldr	r3, [pc, #268]	; (1a000758 <ActualizarMEFAsc+0x2b0>)
1a00064a:	781b      	ldrb	r3, [r3, #0]
1a00064c:	2b00      	cmp	r3, #0
1a00064e:	f040 80b4 	bne.w	1a0007ba <ActualizarMEFAsc+0x312>
			{
			// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
			CargaNuevoPiso();
1a000652:	f7ff fef7 	bl	1a000444 <CargaNuevoPiso>
			
			if (Ask_PideNuevoPisoFlag)
1a000656:	4b3f      	ldr	r3, [pc, #252]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a000658:	681b      	ldr	r3, [r3, #0]
1a00065a:	f013 0f10 	tst.w	r3, #16
1a00065e:	d024      	beq.n	1a0006aa <ActualizarMEFAsc+0x202>
				{
				Clr_AscParadoFlag;
1a000660:	4a3c      	ldr	r2, [pc, #240]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a000662:	6813      	ldr	r3, [r2, #0]
1a000664:	f023 0301 	bic.w	r3, r3, #1
1a000668:	6013      	str	r3, [r2, #0]
				if (pisoActual < pisoDestino) //COMPLETAR!!! no tendria que venir el mismo piso...
1a00066a:	4b3c      	ldr	r3, [pc, #240]	; (1a00075c <ActualizarMEFAsc+0x2b4>)
1a00066c:	f993 2000 	ldrsb.w	r2, [r3]
1a000670:	4b3b      	ldr	r3, [pc, #236]	; (1a000760 <ActualizarMEFAsc+0x2b8>)
1a000672:	f993 3000 	ldrsb.w	r3, [r3]
1a000676:	429a      	cmp	r2, r3
1a000678:	da0b      	bge.n	1a000692 <ActualizarMEFAsc+0x1ea>
					{
					// El piso se encuentra arriba.
					estadoActualAsc = SUBIENDO;
1a00067a:	2401      	movs	r4, #1
1a00067c:	4b34      	ldr	r3, [pc, #208]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a00067e:	701c      	strb	r4, [r3, #0]
					gpioWrite (LED_PBDETENIDO, 0);
1a000680:	2100      	movs	r1, #0
1a000682:	202d      	movs	r0, #45	; 0x2d
1a000684:	f001 fdd0 	bl	1a002228 <gpioWrite>
					gpioWrite (LED_ASCMOVIENDO, 1);
1a000688:	4621      	mov	r1, r4
1a00068a:	202a      	movs	r0, #42	; 0x2a
1a00068c:	f001 fdcc 	bl	1a002228 <gpioWrite>
1a000690:	bd10      	pop	{r4, pc}
					}
				else	{
					// El piso se encuentra abajo.
					estadoActualAsc = BAJANDO;
1a000692:	2202      	movs	r2, #2
1a000694:	4b2e      	ldr	r3, [pc, #184]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a000696:	701a      	strb	r2, [r3, #0]
					gpioWrite (LED_PBDETENIDO, 0);
1a000698:	2100      	movs	r1, #0
1a00069a:	202d      	movs	r0, #45	; 0x2d
1a00069c:	f001 fdc4 	bl	1a002228 <gpioWrite>
					gpioWrite (LED_ASCMOVIENDO, 1);
1a0006a0:	2101      	movs	r1, #1
1a0006a2:	202a      	movs	r0, #42	; 0x2a
1a0006a4:	f001 fdc0 	bl	1a002228 <gpioWrite>
1a0006a8:	bd10      	pop	{r4, pc}
					}
				}
			
			//VER!!! si esta en plata baja!
			// Se consulta si hay que ir a PB por tiempo.
			else if (delayRead(&timRetornoPB))
1a0006aa:	4830      	ldr	r0, [pc, #192]	; (1a00076c <ActualizarMEFAsc+0x2c4>)
1a0006ac:	f001 fcc8 	bl	1a002040 <delayRead>
1a0006b0:	2800      	cmp	r0, #0
1a0006b2:	f000 8082 	beq.w	1a0007ba <ActualizarMEFAsc+0x312>
				{
				Clr_AscParadoFlag;
1a0006b6:	4c27      	ldr	r4, [pc, #156]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a0006b8:	6823      	ldr	r3, [r4, #0]
1a0006ba:	f023 0301 	bic.w	r3, r3, #1
1a0006be:	6023      	str	r3, [r4, #0]
				estadoActualAsc = YENDO_A_PLANTA_BAJA;
1a0006c0:	2204      	movs	r2, #4
1a0006c2:	4b23      	ldr	r3, [pc, #140]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a0006c4:	701a      	strb	r2, [r3, #0]
				pisoDestino = 0;
1a0006c6:	2100      	movs	r1, #0
1a0006c8:	4b25      	ldr	r3, [pc, #148]	; (1a000760 <ActualizarMEFAsc+0x2b8>)
1a0006ca:	7019      	strb	r1, [r3, #0]
				gpioWrite (LED_PBDETENIDO, 0);
1a0006cc:	202d      	movs	r0, #45	; 0x2d
1a0006ce:	f001 fdab 	bl	1a002228 <gpioWrite>
				gpioWrite (LED_ASCMOVIENDO, 1);
1a0006d2:	2101      	movs	r1, #1
1a0006d4:	202a      	movs	r0, #42	; 0x2a
1a0006d6:	f001 fda7 	bl	1a002228 <gpioWrite>
				
				Clr_PideNuevoPisoFlag;			// SACAR!!!
1a0006da:	6823      	ldr	r3, [r4, #0]
1a0006dc:	f023 0310 	bic.w	r3, r3, #16
1a0006e0:	6023      	str	r3, [r4, #0]
1a0006e2:	bd10      	pop	{r4, pc}
			}
		break;

	case YENDO_A_PLANTA_BAJA:
		// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
		CargaNuevoPiso();
1a0006e4:	f7ff feae 	bl	1a000444 <CargaNuevoPiso>
			
		if (Ask_PideNuevoPisoFlag)	
1a0006e8:	4b1a      	ldr	r3, [pc, #104]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a0006ea:	681b      	ldr	r3, [r3, #0]
1a0006ec:	f013 0f10 	tst.w	r3, #16
1a0006f0:	d013      	beq.n	1a00071a <ActualizarMEFAsc+0x272>
			{
			if (pisoActual < pisoDestino)
1a0006f2:	4b1a      	ldr	r3, [pc, #104]	; (1a00075c <ActualizarMEFAsc+0x2b4>)
1a0006f4:	f993 2000 	ldrsb.w	r2, [r3]
1a0006f8:	4b19      	ldr	r3, [pc, #100]	; (1a000760 <ActualizarMEFAsc+0x2b8>)
1a0006fa:	f993 3000 	ldrsb.w	r3, [r3]
1a0006fe:	429a      	cmp	r2, r3
1a000700:	da19      	bge.n	1a000736 <ActualizarMEFAsc+0x28e>
				{
				// Ante un cambio de estado se ejecuta el cierre de las puertas.
				Set_CierraPuertasFlag;
1a000702:	4b14      	ldr	r3, [pc, #80]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a000704:	681a      	ldr	r2, [r3, #0]
1a000706:	f042 0204 	orr.w	r2, r2, #4
1a00070a:	601a      	str	r2, [r3, #0]
				// El piso destino se encuentra arriba.
				estadoActualAsc = SUBIENDO;
1a00070c:	2101      	movs	r1, #1
1a00070e:	4a10      	ldr	r2, [pc, #64]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a000710:	7011      	strb	r1, [r2, #0]
				Clr_PidioAperturaFlag;
1a000712:	681a      	ldr	r2, [r3, #0]
1a000714:	f022 0208 	bic.w	r2, r2, #8
1a000718:	601a      	str	r2, [r3, #0]
				}
			}

		// SALIDA EN EL ESTADO:
		// Se hace bajar o subir el ascensor, demorara en subir lo configurado en "velPisoPiso"
		if (pisoActual > 0) //COMPLETAR!!! no tendria que venir el mismo piso...
1a00071a:	4b10      	ldr	r3, [pc, #64]	; (1a00075c <ActualizarMEFAsc+0x2b4>)
1a00071c:	f993 3000 	ldrsb.w	r3, [r3]
1a000720:	2b00      	cmp	r3, #0
1a000722:	dd25      	ble.n	1a000770 <ActualizarMEFAsc+0x2c8>
			{
			// El piso actual se encuentra arriba.
			if (delayRead(&timPisoPiso))
1a000724:	4810      	ldr	r0, [pc, #64]	; (1a000768 <ActualizarMEFAsc+0x2c0>)
1a000726:	f001 fc8b 	bl	1a002040 <delayRead>
1a00072a:	b318      	cbz	r0, 1a000774 <ActualizarMEFAsc+0x2cc>
				pisoActual = pisoActual - 1;
1a00072c:	4a0b      	ldr	r2, [pc, #44]	; (1a00075c <ActualizarMEFAsc+0x2b4>)
1a00072e:	7813      	ldrb	r3, [r2, #0]
1a000730:	3b01      	subs	r3, #1
1a000732:	7013      	strb	r3, [r2, #0]
1a000734:	e01e      	b.n	1a000774 <ActualizarMEFAsc+0x2cc>
				Set_CierraPuertasFlag;
1a000736:	4b07      	ldr	r3, [pc, #28]	; (1a000754 <ActualizarMEFAsc+0x2ac>)
1a000738:	681a      	ldr	r2, [r3, #0]
1a00073a:	f042 0204 	orr.w	r2, r2, #4
1a00073e:	601a      	str	r2, [r3, #0]
				estadoActualAsc = BAJANDO;
1a000740:	2102      	movs	r1, #2
1a000742:	4a03      	ldr	r2, [pc, #12]	; (1a000750 <ActualizarMEFAsc+0x2a8>)
1a000744:	7011      	strb	r1, [r2, #0]
				Clr_PidioAperturaFlag;
1a000746:	681a      	ldr	r2, [r3, #0]
1a000748:	f022 0208 	bic.w	r2, r2, #8
1a00074c:	601a      	str	r2, [r3, #0]
1a00074e:	e7e4      	b.n	1a00071a <ActualizarMEFAsc+0x272>
1a000750:	10000148 	.word	0x10000148
1a000754:	10000058 	.word	0x10000058
1a000758:	10000149 	.word	0x10000149
1a00075c:	1000005d 	.word	0x1000005d
1a000760:	1000005e 	.word	0x1000005e
1a000764:	1000005c 	.word	0x1000005c
1a000768:	10000090 	.word	0x10000090
1a00076c:	100000c0 	.word	0x100000c0
			}
		else if (pisoActual < 0) 
1a000770:	2b00      	cmp	r3, #0
1a000772:	db0f      	blt.n	1a000794 <ActualizarMEFAsc+0x2ec>

			}
		
		// CAMBIO DE ESTADO:
		// Se consulta si llego a PB
		if (pisoActual == 0)
1a000774:	4b11      	ldr	r3, [pc, #68]	; (1a0007bc <ActualizarMEFAsc+0x314>)
1a000776:	f993 3000 	ldrsb.w	r3, [r3]
1a00077a:	b9f3      	cbnz	r3, 1a0007ba <ActualizarMEFAsc+0x312>
			{
			gpioWrite (LED_ASCMOVIENDO, 0);
1a00077c:	2100      	movs	r1, #0
1a00077e:	202a      	movs	r0, #42	; 0x2a
1a000780:	f001 fd52 	bl	1a002228 <gpioWrite>
			estadoActualAsc = EN_PLANTA_BAJA;
1a000784:	2200      	movs	r2, #0
1a000786:	4b0e      	ldr	r3, [pc, #56]	; (1a0007c0 <ActualizarMEFAsc+0x318>)
1a000788:	701a      	strb	r2, [r3, #0]
			gpioWrite (LED_PBDETENIDO, 1);
1a00078a:	2101      	movs	r1, #1
1a00078c:	202d      	movs	r0, #45	; 0x2d
1a00078e:	f001 fd4b 	bl	1a002228 <gpioWrite>
1a000792:	bd10      	pop	{r4, pc}
			if (delayRead(&timPisoPiso))
1a000794:	480b      	ldr	r0, [pc, #44]	; (1a0007c4 <ActualizarMEFAsc+0x31c>)
1a000796:	f001 fc53 	bl	1a002040 <delayRead>
1a00079a:	2800      	cmp	r0, #0
1a00079c:	d0ea      	beq.n	1a000774 <ActualizarMEFAsc+0x2cc>
				pisoActual = pisoActual + 1;
1a00079e:	4a07      	ldr	r2, [pc, #28]	; (1a0007bc <ActualizarMEFAsc+0x314>)
1a0007a0:	7813      	ldrb	r3, [r2, #0]
1a0007a2:	3301      	adds	r3, #1
1a0007a4:	7013      	strb	r3, [r2, #0]
1a0007a6:	e7e5      	b.n	1a000774 <ActualizarMEFAsc+0x2cc>
		break;

	case MODO_CONFIGURACION:
		
		// Secuencia de configuracion y CAMBIO DE ESTADO.
		if (modoConfiguracion())
1a0007a8:	f000 fcee 	bl	1a001188 <modoConfiguracion>
1a0007ac:	b128      	cbz	r0, 1a0007ba <ActualizarMEFAsc+0x312>
			estadoActualAsc = EN_PLANTA_BAJA;
1a0007ae:	2200      	movs	r2, #0
1a0007b0:	4b03      	ldr	r3, [pc, #12]	; (1a0007c0 <ActualizarMEFAsc+0x318>)
1a0007b2:	701a      	strb	r2, [r3, #0]
1a0007b4:	bd10      	pop	{r4, pc}
	
	

	default:
		// Si "estadoActualAsc" adquiere un valor invalido se configura un estado de recuperacion.
		InicializarMEFAsc();
1a0007b6:	f7ff fdff 	bl	1a0003b8 <InicializarMEFAsc>
1a0007ba:	bd10      	pop	{r4, pc}
1a0007bc:	1000005d 	.word	0x1000005d
1a0007c0:	10000148 	.word	0x10000148
1a0007c4:	10000090 	.word	0x10000090

1a0007c8 <ActualizaMEFPuerta>:

//*********************************************************************************************************************
//		Función Actualizar MEF de la puerta del ascensor
//*********************************************************************************************************************
void ActualizaMEFPuerta(void)
{
1a0007c8:	b508      	push	{r3, lr}
switch(estadoActualPuerta)
1a0007ca:	4b3f      	ldr	r3, [pc, #252]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a0007cc:	781b      	ldrb	r3, [r3, #0]
1a0007ce:	2b05      	cmp	r3, #5
1a0007d0:	d877      	bhi.n	1a0008c2 <ActualizaMEFPuerta+0xfa>
1a0007d2:	e8df f003 	tbb	[pc, r3]
1a0007d6:	1403      	.short	0x1403
1a0007d8:	624f3f28 	.word	0x624f3f28
	{
	case PUERTA_CERRADA:
		// CAMBIO DE ESTADO:
		// MEF ascensor solicita apertura de puertas?
		if (Ask_AbrePuertasFlag)
1a0007dc:	4b3b      	ldr	r3, [pc, #236]	; (1a0008cc <ActualizaMEFPuerta+0x104>)
1a0007de:	681b      	ldr	r3, [r3, #0]
1a0007e0:	f013 0f02 	tst.w	r3, #2
1a0007e4:	d06f      	beq.n	1a0008c6 <ActualizaMEFPuerta+0xfe>
			{
			Clr_AbrePuertasFlag;
1a0007e6:	4a39      	ldr	r2, [pc, #228]	; (1a0008cc <ActualizaMEFPuerta+0x104>)
1a0007e8:	6813      	ldr	r3, [r2, #0]
1a0007ea:	f023 0302 	bic.w	r3, r3, #2
1a0007ee:	6013      	str	r3, [r2, #0]
			estadoActualPuerta = ABRIENDO_PUERTA;
1a0007f0:	2101      	movs	r1, #1
1a0007f2:	4b35      	ldr	r3, [pc, #212]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a0007f4:	7019      	strb	r1, [r3, #0]
			gpioWrite(LED_ABRIENDOPUERTA, 1);
1a0007f6:	202b      	movs	r0, #43	; 0x2b
1a0007f8:	f001 fd16 	bl	1a002228 <gpioWrite>
1a0007fc:	bd08      	pop	{r3, pc}
		break;

	case ABRIENDO_PUERTA:
		// CAMBIO DE ESTADO:
		// Se cumplio tiempo de apertura?
		if (delayRead(&timAbreCierraPuerta))
1a0007fe:	4834      	ldr	r0, [pc, #208]	; (1a0008d0 <ActualizaMEFPuerta+0x108>)
1a000800:	f001 fc1e 	bl	1a002040 <delayRead>
1a000804:	2800      	cmp	r0, #0
1a000806:	d05e      	beq.n	1a0008c6 <ActualizaMEFPuerta+0xfe>
			{
			estadoActualPuerta = PUERTA_ABIERTA;
1a000808:	2202      	movs	r2, #2
1a00080a:	4b2f      	ldr	r3, [pc, #188]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a00080c:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_ABRIENDOPUERTA, 0);
1a00080e:	2100      	movs	r1, #0
1a000810:	202b      	movs	r0, #43	; 0x2b
1a000812:	f001 fd09 	bl	1a002228 <gpioWrite>
			gpioWrite(LED_PUERTAABIERTA, 1);
1a000816:	2101      	movs	r1, #1
1a000818:	2029      	movs	r0, #41	; 0x29
1a00081a:	f001 fd05 	bl	1a002228 <gpioWrite>
			delayRead(&timPuertaAbierta);
1a00081e:	482d      	ldr	r0, [pc, #180]	; (1a0008d4 <ActualizaMEFPuerta+0x10c>)
1a000820:	f001 fc0e 	bl	1a002040 <delayRead>
1a000824:	bd08      	pop	{r3, pc}
		break;

	case PUERTA_ABIERTA:
		// CAMBIO DE ESTADO:
		// MEF ascensor solicita cierre de puertas y paso el tiempo que tiene que estar abierta la puerta?
		if (Ask_CierraPuertasFlag && delayRead(&timPuertaAbierta))
1a000826:	4b29      	ldr	r3, [pc, #164]	; (1a0008cc <ActualizaMEFPuerta+0x104>)
1a000828:	681b      	ldr	r3, [r3, #0]
1a00082a:	f013 0f04 	tst.w	r3, #4
1a00082e:	d04a      	beq.n	1a0008c6 <ActualizaMEFPuerta+0xfe>
1a000830:	4828      	ldr	r0, [pc, #160]	; (1a0008d4 <ActualizaMEFPuerta+0x10c>)
1a000832:	f001 fc05 	bl	1a002040 <delayRead>
1a000836:	2800      	cmp	r0, #0
1a000838:	d045      	beq.n	1a0008c6 <ActualizaMEFPuerta+0xfe>
			{
			Clr_CierraPuertasFlag;
1a00083a:	4a24      	ldr	r2, [pc, #144]	; (1a0008cc <ActualizaMEFPuerta+0x104>)
1a00083c:	6813      	ldr	r3, [r2, #0]
1a00083e:	f023 0304 	bic.w	r3, r3, #4
1a000842:	6013      	str	r3, [r2, #0]
			estadoActualPuerta = INTENTANDO_CERRAR_PUERTAS;
1a000844:	2203      	movs	r2, #3
1a000846:	4b20      	ldr	r3, [pc, #128]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a000848:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_PUERTAABIERTA, 0);
1a00084a:	2100      	movs	r1, #0
1a00084c:	2029      	movs	r0, #41	; 0x29
1a00084e:	f001 fceb 	bl	1a002228 <gpioWrite>
1a000852:	bd08      	pop	{r3, pc}
		break;

	case INTENTANDO_CERRAR_PUERTAS:
		// CAMBIO DE ESTADO:
		// Hay gente?
		if (!gpioRead(TEC1))
1a000854:	2024      	movs	r0, #36	; 0x24
1a000856:	f001 fd12 	bl	1a00227e <gpioRead>
1a00085a:	b918      	cbnz	r0, 1a000864 <ActualizaMEFPuerta+0x9c>
			estadoActualPuerta = ALARMA_PUERTA_ABIERTA;	// Hay gente.
1a00085c:	2205      	movs	r2, #5
1a00085e:	4b1a      	ldr	r3, [pc, #104]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a000860:	701a      	strb	r2, [r3, #0]
1a000862:	bd08      	pop	{r3, pc}
		else	{
			estadoActualPuerta = CERRANDO_PUERTA;		// No hay gente.
1a000864:	2204      	movs	r2, #4
1a000866:	4b18      	ldr	r3, [pc, #96]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a000868:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_CERRANDOPUERTA, 1);
1a00086a:	2101      	movs	r1, #1
1a00086c:	202c      	movs	r0, #44	; 0x2c
1a00086e:	f001 fcdb 	bl	1a002228 <gpioWrite>
1a000872:	bd08      	pop	{r3, pc}
	
	
	case CERRANDO_PUERTA:
		// CAMBIO DE ESTADO:
		// Se cumplio tiempo de cierre? 
		if (delayRead(&timAbreCierraPuerta))
1a000874:	4816      	ldr	r0, [pc, #88]	; (1a0008d0 <ActualizaMEFPuerta+0x108>)
1a000876:	f001 fbe3 	bl	1a002040 <delayRead>
1a00087a:	b938      	cbnz	r0, 1a00088c <ActualizaMEFPuerta+0xc4>
			{
			estadoActualPuerta = PUERTA_CERRADA;
			gpioWrite(LED_CERRANDOPUERTA, 0);
			}
		// Hay gente?
		if (!gpioRead(TEC1))
1a00087c:	2024      	movs	r0, #36	; 0x24
1a00087e:	f001 fcfe 	bl	1a00227e <gpioRead>
1a000882:	bb00      	cbnz	r0, 1a0008c6 <ActualizaMEFPuerta+0xfe>
			estadoActualPuerta = ABRIENDO_PUERTA;	// Hay gente.
1a000884:	2201      	movs	r2, #1
1a000886:	4b10      	ldr	r3, [pc, #64]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a000888:	701a      	strb	r2, [r3, #0]
1a00088a:	bd08      	pop	{r3, pc}
			estadoActualPuerta = PUERTA_CERRADA;
1a00088c:	2100      	movs	r1, #0
1a00088e:	4b0e      	ldr	r3, [pc, #56]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a000890:	7019      	strb	r1, [r3, #0]
			gpioWrite(LED_CERRANDOPUERTA, 0);
1a000892:	202c      	movs	r0, #44	; 0x2c
1a000894:	f001 fcc8 	bl	1a002228 <gpioWrite>
1a000898:	e7f0      	b.n	1a00087c <ActualizaMEFPuerta+0xb4>
		break;

	case ALARMA_PUERTA_ABIERTA:
		// SALIDA EN EL ESTADO:
		if (delayRead(&timAlarPuerta))
1a00089a:	480f      	ldr	r0, [pc, #60]	; (1a0008d8 <ActualizaMEFPuerta+0x110>)
1a00089c:	f001 fbd0 	bl	1a002040 <delayRead>
1a0008a0:	b958      	cbnz	r0, 1a0008ba <ActualizaMEFPuerta+0xf2>
			gpioToggle(LED_ALARMAPABIERTA);		// Parpadeo led que Indica alarma de puerta abierta.
	
		// CAMBIO DE ESTADO:
		// Hay gente?
		if (gpioRead(TEC1))
1a0008a2:	2024      	movs	r0, #36	; 0x24
1a0008a4:	f001 fceb 	bl	1a00227e <gpioRead>
1a0008a8:	b168      	cbz	r0, 1a0008c6 <ActualizaMEFPuerta+0xfe>
			{
			estadoActualPuerta = CERRANDO_PUERTA;	// No hay gente.
1a0008aa:	2204      	movs	r2, #4
1a0008ac:	4b06      	ldr	r3, [pc, #24]	; (1a0008c8 <ActualizaMEFPuerta+0x100>)
1a0008ae:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_ALARMAPABIERTA, 0);
1a0008b0:	2100      	movs	r1, #0
1a0008b2:	2028      	movs	r0, #40	; 0x28
1a0008b4:	f001 fcb8 	bl	1a002228 <gpioWrite>
1a0008b8:	bd08      	pop	{r3, pc}
			gpioToggle(LED_ALARMAPABIERTA);		// Parpadeo led que Indica alarma de puerta abierta.
1a0008ba:	2028      	movs	r0, #40	; 0x28
1a0008bc:	f001 fd09 	bl	1a0022d2 <gpioToggle>
1a0008c0:	e7ef      	b.n	1a0008a2 <ActualizaMEFPuerta+0xda>
		break;


	default:
		// Si "estadoActualPuerta" adquiere un valor invalido se configura un estado de recuperacion.
		InicializarMEFPuerta();
1a0008c2:	f7ff fd95 	bl	1a0003f0 <InicializarMEFPuerta>
1a0008c6:	bd08      	pop	{r3, pc}
1a0008c8:	10000149 	.word	0x10000149
1a0008cc:	10000058 	.word	0x10000058
1a0008d0:	10000060 	.word	0x10000060
1a0008d4:	100000a8 	.word	0x100000a8
1a0008d8:	10000078 	.word	0x10000078

1a0008dc <configurarTecladoMatricial>:


//*********************************************************************************************************************
//
//*********************************************************************************************************************
void configurarTecladoMatricial (void){
1a0008dc:	b510      	push	{r4, lr}
    
uint8_t i = 0;  // Variable para recorrer el vector de filas y columnas.
    
/* Se recorre todo el vector de filas para configurar los pines como salida.*/
    for ( i = 0; i < 4; i++){
1a0008de:	2400      	movs	r4, #0
1a0008e0:	e006      	b.n	1a0008f0 <configurarTecladoMatricial+0x14>
        gpioConfig(pinesFila[i], GPIO_OUTPUT);
1a0008e2:	2101      	movs	r1, #1
1a0008e4:	4b09      	ldr	r3, [pc, #36]	; (1a00090c <configurarTecladoMatricial+0x30>)
1a0008e6:	5d18      	ldrb	r0, [r3, r4]
1a0008e8:	f001 fbe4 	bl	1a0020b4 <gpioConfig>
    for ( i = 0; i < 4; i++){
1a0008ec:	3401      	adds	r4, #1
1a0008ee:	b2e4      	uxtb	r4, r4
1a0008f0:	2c03      	cmp	r4, #3
1a0008f2:	d9f6      	bls.n	1a0008e2 <configurarTecladoMatricial+0x6>
1a0008f4:	2400      	movs	r4, #0
1a0008f6:	e006      	b.n	1a000906 <configurarTecladoMatricial+0x2a>
    } 

/* Se recorre todo el vector de columnas para configurar los pines como entrada en PULLUP (resistencia interna).*/
    for ( i = 0; i < 4; i++){
        gpioConfig(pinesColumna[i], GPIO_INPUT_PULLUP);
1a0008f8:	2102      	movs	r1, #2
1a0008fa:	4b05      	ldr	r3, [pc, #20]	; (1a000910 <configurarTecladoMatricial+0x34>)
1a0008fc:	5d18      	ldrb	r0, [r3, r4]
1a0008fe:	f001 fbd9 	bl	1a0020b4 <gpioConfig>
    for ( i = 0; i < 4; i++){
1a000902:	3401      	adds	r4, #1
1a000904:	b2e4      	uxtb	r4, r4
1a000906:	2c03      	cmp	r4, #3
1a000908:	d9f6      	bls.n	1a0008f8 <configurarTecladoMatricial+0x1c>
    }
}
1a00090a:	bd10      	pop	{r4, pc}
1a00090c:	1a0028b4 	.word	0x1a0028b4
1a000910:	1a0028b0 	.word	0x1a0028b0

1a000914 <InicializarMEF_tecladoMatrical>:


//*********************************************************************************************************************
//
//*********************************************************************************************************************
void InicializarMEF_tecladoMatrical(void) {
1a000914:	b510      	push	{r4, lr}

estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000916:	2400      	movs	r4, #0
1a000918:	4b03      	ldr	r3, [pc, #12]	; (1a000928 <InicializarMEF_tecladoMatrical+0x14>)
1a00091a:	701c      	strb	r4, [r3, #0]
configurarTecladoMatricial();
1a00091c:	f7ff ffde 	bl	1a0008dc <configurarTecladoMatricial>
estadoMefScanTeclado = ESCANEANDO_TECLADO;
1a000920:	4b02      	ldr	r3, [pc, #8]	; (1a00092c <InicializarMEF_tecladoMatrical+0x18>)
1a000922:	701c      	strb	r4, [r3, #0]
1a000924:	bd10      	pop	{r4, pc}
1a000926:	bf00      	nop
1a000928:	100000f9 	.word	0x100000f9
1a00092c:	100000f8 	.word	0x100000f8

1a000930 <ScanTeclas>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
bool_t ScanTeclas(void)
{
1a000930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

uint8_t f = 0; // Variable para recorrer los vectores de filas.
uint8_t c = 0; // Variable para recorrer los vectores de columnas.

// Lo primero que hacemos es poner todas las filas en estado "bajo".
for (f=0; f<4; f++)
1a000932:	2400      	movs	r4, #0
1a000934:	e006      	b.n	1a000944 <ScanTeclas+0x14>
	gpioWrite(pinesFila[f], 0);
1a000936:	2100      	movs	r1, #0
1a000938:	4b1f      	ldr	r3, [pc, #124]	; (1a0009b8 <ScanTeclas+0x88>)
1a00093a:	5d18      	ldrb	r0, [r3, r4]
1a00093c:	f001 fc74 	bl	1a002228 <gpioWrite>
for (f=0; f<4; f++)
1a000940:	3401      	adds	r4, #1
1a000942:	b2e4      	uxtb	r4, r4
1a000944:	2c03      	cmp	r4, #3
1a000946:	d9f6      	bls.n	1a000936 <ScanTeclas+0x6>
1a000948:	2600      	movs	r6, #0
1a00094a:	e027      	b.n	1a00099c <ScanTeclas+0x6c>
	// Si leo un estado BAJO en una columna entonces puede haber una tecla presionada-
        if (!gpioRead(pinesColumna[c]))
		{
		//Se ponen todas las filas en "alto", excepto la primera que se deja en "bajo".
		for (f=1; f<4 ; f++)
			gpioWrite(pinesFila[f], 1);
1a00094c:	2101      	movs	r1, #1
1a00094e:	4b1a      	ldr	r3, [pc, #104]	; (1a0009b8 <ScanTeclas+0x88>)
1a000950:	5d58      	ldrb	r0, [r3, r5]
1a000952:	f001 fc69 	bl	1a002228 <gpioWrite>
		for (f=1; f<4 ; f++)
1a000956:	3501      	adds	r5, #1
1a000958:	b2ed      	uxtb	r5, r5
1a00095a:	2d03      	cmp	r5, #3
1a00095c:	d9f6      	bls.n	1a00094c <ScanTeclas+0x1c>
1a00095e:	2400      	movs	r4, #0
		// Se procede a buscar la tecla presionada, para ello se recorren las filas. AcÃ¡ lo que buscamos es la coordenada de la fila.
		for (f=0; f<4; f++)
1a000960:	2c03      	cmp	r4, #3
1a000962:	d819      	bhi.n	1a000998 <ScanTeclas+0x68>
			{
			// El siguiente if es para evitar un Ã­ndice negativo en el vector.
			if (f > 0)
1a000964:	b12c      	cbz	r4, 1a000972 <ScanTeclas+0x42>
				gpioWrite(pinesFila[f-1], 1);
1a000966:	1e63      	subs	r3, r4, #1
1a000968:	2101      	movs	r1, #1
1a00096a:	4a13      	ldr	r2, [pc, #76]	; (1a0009b8 <ScanTeclas+0x88>)
1a00096c:	5cd0      	ldrb	r0, [r2, r3]
1a00096e:	f001 fc5b 	bl	1a002228 <gpioWrite>
			gpioWrite(pinesFila[f], 0);
1a000972:	2100      	movs	r1, #0
1a000974:	4b10      	ldr	r3, [pc, #64]	; (1a0009b8 <ScanTeclas+0x88>)
1a000976:	5d18      	ldrb	r0, [r3, r4]
1a000978:	f001 fc56 	bl	1a002228 <gpioWrite>

			//Se testea la columna actual con la fila actual, si detectamos un estado "BAJO"
			//en alguna columna, significa que hemos encontrado la coordenada de la fila 
			//correspondiente. Con esta coordenada ya podemos detectar que tecla fue presionada.
			if (!gpioRead(pinesColumna[c]))
1a00097c:	4b0f      	ldr	r3, [pc, #60]	; (1a0009bc <ScanTeclas+0x8c>)
1a00097e:	5dd8      	ldrb	r0, [r3, r7]
1a000980:	f001 fc7d 	bl	1a00227e <gpioRead>
1a000984:	b110      	cbz	r0, 1a00098c <ScanTeclas+0x5c>
		for (f=0; f<4; f++)
1a000986:	3401      	adds	r4, #1
1a000988:	b2e4      	uxtb	r4, r4
1a00098a:	e7e9      	b.n	1a000960 <ScanTeclas+0x30>
				{
				ret = 1;
				key = f * 4 + c;
1a00098c:	eb06 0484 	add.w	r4, r6, r4, lsl #2
1a000990:	4b0b      	ldr	r3, [pc, #44]	; (1a0009c0 <ScanTeclas+0x90>)
1a000992:	801c      	strh	r4, [r3, #0]
				return ret;
1a000994:	2001      	movs	r0, #1
1a000996:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
for (c=0; c<4; c++)
1a000998:	3601      	adds	r6, #1
1a00099a:	b2f6      	uxtb	r6, r6
1a00099c:	2e03      	cmp	r6, #3
1a00099e:	d808      	bhi.n	1a0009b2 <ScanTeclas+0x82>
        if (!gpioRead(pinesColumna[c]))
1a0009a0:	4637      	mov	r7, r6
1a0009a2:	4b06      	ldr	r3, [pc, #24]	; (1a0009bc <ScanTeclas+0x8c>)
1a0009a4:	5d98      	ldrb	r0, [r3, r6]
1a0009a6:	f001 fc6a 	bl	1a00227e <gpioRead>
1a0009aa:	2800      	cmp	r0, #0
1a0009ac:	d1f4      	bne.n	1a000998 <ScanTeclas+0x68>
1a0009ae:	2501      	movs	r5, #1
1a0009b0:	e7d3      	b.n	1a00095a <ScanTeclas+0x2a>
				*/
				}
			}
		}
	}
return ret;
1a0009b2:	2000      	movs	r0, #0
}
1a0009b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
1a0009b6:	bf00      	nop
1a0009b8:	1a0028b4 	.word	0x1a0028b4
1a0009bc:	1a0028b0 	.word	0x1a0028b0
1a0009c0:	10000104 	.word	0x10000104

1a0009c4 <ActualizaMEFScanTecla>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void ActualizaMEFScanTecla(void)
{
1a0009c4:	b508      	push	{r3, lr}
// Esta rutina hace la captura de una tecla con anti-bouncing.
// Al haber confirmado el proceso de una tecla pone "hayTeclaDisponible" en 1;
// Y la tecla confirmada en "teclaPresionada".

switch(estadoMefScanTeclado)
1a0009c6:	4b25      	ldr	r3, [pc, #148]	; (1a000a5c <ActualizaMEFScanTecla+0x98>)
1a0009c8:	781b      	ldrb	r3, [r3, #0]
1a0009ca:	2b01      	cmp	r3, #1
1a0009cc:	d011      	beq.n	1a0009f2 <ActualizaMEFScanTecla+0x2e>
1a0009ce:	b123      	cbz	r3, 1a0009da <ActualizaMEFScanTecla+0x16>
1a0009d0:	2b02      	cmp	r3, #2
1a0009d2:	d037      	beq.n	1a000a44 <ActualizaMEFScanTecla+0x80>
			}
	break;

	
	default:
	InicializarMEF_tecladoMatrical();
1a0009d4:	f7ff ff9e 	bl	1a000914 <InicializarMEF_tecladoMatrical>
1a0009d8:	bd08      	pop	{r3, pc}
		if (ScanTeclas())
1a0009da:	f7ff ffa9 	bl	1a000930 <ScanTeclas>
1a0009de:	2800      	cmp	r0, #0
1a0009e0:	d0fa      	beq.n	1a0009d8 <ActualizaMEFScanTecla+0x14>
			teclaPresionada = key;
1a0009e2:	4b1f      	ldr	r3, [pc, #124]	; (1a000a60 <ActualizaMEFScanTecla+0x9c>)
1a0009e4:	881a      	ldrh	r2, [r3, #0]
1a0009e6:	4b1f      	ldr	r3, [pc, #124]	; (1a000a64 <ActualizaMEFScanTecla+0xa0>)
1a0009e8:	801a      	strh	r2, [r3, #0]
			estadoMefScanTeclado = APRETANDO_TECLA;
1a0009ea:	2201      	movs	r2, #1
1a0009ec:	4b1b      	ldr	r3, [pc, #108]	; (1a000a5c <ActualizaMEFScanTecla+0x98>)
1a0009ee:	701a      	strb	r2, [r3, #0]
1a0009f0:	bd08      	pop	{r3, pc}
		if (flagEstadoApretandoTecla == 0)
1a0009f2:	4b1d      	ldr	r3, [pc, #116]	; (1a000a68 <ActualizaMEFScanTecla+0xa4>)
1a0009f4:	781b      	ldrb	r3, [r3, #0]
1a0009f6:	b1ab      	cbz	r3, 1a000a24 <ActualizaMEFScanTecla+0x60>
		if (delayRead(&delayAntirebote))
1a0009f8:	481c      	ldr	r0, [pc, #112]	; (1a000a6c <ActualizaMEFScanTecla+0xa8>)
1a0009fa:	f001 fb21 	bl	1a002040 <delayRead>
1a0009fe:	2800      	cmp	r0, #0
1a000a00:	d0ea      	beq.n	1a0009d8 <ActualizaMEFScanTecla+0x14>
			ScanTeclas();
1a000a02:	f7ff ff95 	bl	1a000930 <ScanTeclas>
			if (teclaPresionada == key)
1a000a06:	4b17      	ldr	r3, [pc, #92]	; (1a000a64 <ActualizaMEFScanTecla+0xa0>)
1a000a08:	881a      	ldrh	r2, [r3, #0]
1a000a0a:	4b15      	ldr	r3, [pc, #84]	; (1a000a60 <ActualizaMEFScanTecla+0x9c>)
1a000a0c:	881b      	ldrh	r3, [r3, #0]
1a000a0e:	429a      	cmp	r2, r3
1a000a10:	d011      	beq.n	1a000a36 <ActualizaMEFScanTecla+0x72>
				estadoMefScanTeclado = ESCANEANDO_TECLADO;
1a000a12:	2300      	movs	r3, #0
1a000a14:	4a11      	ldr	r2, [pc, #68]	; (1a000a5c <ActualizaMEFScanTecla+0x98>)
1a000a16:	7013      	strb	r3, [r2, #0]
				teclaPresionada = 0xff;
1a000a18:	21ff      	movs	r1, #255	; 0xff
1a000a1a:	4a12      	ldr	r2, [pc, #72]	; (1a000a64 <ActualizaMEFScanTecla+0xa0>)
1a000a1c:	8011      	strh	r1, [r2, #0]
				flagEstadoApretandoTecla = 0;
1a000a1e:	4a12      	ldr	r2, [pc, #72]	; (1a000a68 <ActualizaMEFScanTecla+0xa4>)
1a000a20:	7013      	strb	r3, [r2, #0]
1a000a22:	bd08      	pop	{r3, pc}
			flagEstadoApretandoTecla= 1;
1a000a24:	2201      	movs	r2, #1
1a000a26:	4b10      	ldr	r3, [pc, #64]	; (1a000a68 <ActualizaMEFScanTecla+0xa4>)
1a000a28:	701a      	strb	r2, [r3, #0]
			delayConfig(&delayAntirebote, 40);
1a000a2a:	2228      	movs	r2, #40	; 0x28
1a000a2c:	2300      	movs	r3, #0
1a000a2e:	480f      	ldr	r0, [pc, #60]	; (1a000a6c <ActualizaMEFScanTecla+0xa8>)
1a000a30:	f001 faf6 	bl	1a002020 <delayConfig>
1a000a34:	e7e0      	b.n	1a0009f8 <ActualizaMEFScanTecla+0x34>
				estadoMefScanTeclado = IDENTIFICAR_TECLA_Y_ESCRIBIR;
1a000a36:	2202      	movs	r2, #2
1a000a38:	4b08      	ldr	r3, [pc, #32]	; (1a000a5c <ActualizaMEFScanTecla+0x98>)
1a000a3a:	701a      	strb	r2, [r3, #0]
				flagEstadoApretandoTecla = 0;
1a000a3c:	2200      	movs	r2, #0
1a000a3e:	4b0a      	ldr	r3, [pc, #40]	; (1a000a68 <ActualizaMEFScanTecla+0xa4>)
1a000a40:	701a      	strb	r2, [r3, #0]
1a000a42:	bd08      	pop	{r3, pc}
		if (!(ScanTeclas()))
1a000a44:	f7ff ff74 	bl	1a000930 <ScanTeclas>
1a000a48:	2800      	cmp	r0, #0
1a000a4a:	d1c5      	bne.n	1a0009d8 <ActualizaMEFScanTecla+0x14>
			estadoMefScanTeclado = ESCANEANDO_TECLADO;  
1a000a4c:	2200      	movs	r2, #0
1a000a4e:	4b03      	ldr	r3, [pc, #12]	; (1a000a5c <ActualizaMEFScanTecla+0x98>)
1a000a50:	701a      	strb	r2, [r3, #0]
			hayTeclaDisponible = 1;
1a000a52:	2201      	movs	r2, #1
1a000a54:	4b06      	ldr	r3, [pc, #24]	; (1a000a70 <ActualizaMEFScanTecla+0xac>)
1a000a56:	701a      	strb	r2, [r3, #0]
1a000a58:	bd08      	pop	{r3, pc}
1a000a5a:	bf00      	nop
1a000a5c:	100000f8 	.word	0x100000f8
1a000a60:	10000104 	.word	0x10000104
1a000a64:	1000000c 	.word	0x1000000c
1a000a68:	100000fa 	.word	0x100000fa
1a000a6c:	100000e0 	.word	0x100000e0
1a000a70:	100000fb 	.word	0x100000fb

1a000a74 <ingresarDigito>:
bool_t ret = FALSE;	

/* Se testea la columna actual con la fila actual, si detectamos un estado "BAJO"
    en alguna columna, significa que hemos encontrado la coordenada de la fila 
    correspondiente. Con esta coordenada ya podemos detectar que tecla fue presionada.*/
if (hayTeclaDisponible)
1a000a74:	4b19      	ldr	r3, [pc, #100]	; (1a000adc <ingresarDigito+0x68>)
1a000a76:	7818      	ldrb	r0, [r3, #0]
1a000a78:	b148      	cbz	r0, 1a000a8e <ingresarDigito+0x1a>
	{
	hayTeclaDisponible = 0;
1a000a7a:	2200      	movs	r2, #0
1a000a7c:	701a      	strb	r2, [r3, #0]
	ret = TRUE;
                
	/* Etapa en la cual se evalua que digito se ingreso, basicamente llevando la cuenta de las veces que se presionÃ³ una tecla*/
	switch (indiceTeclaPresionada)
1a000a7e:	4b18      	ldr	r3, [pc, #96]	; (1a000ae0 <ingresarDigito+0x6c>)
1a000a80:	681b      	ldr	r3, [r3, #0]
1a000a82:	2b01      	cmp	r3, #1
1a000a84:	d00c      	beq.n	1a000aa0 <ingresarDigito+0x2c>
1a000a86:	b11b      	cbz	r3, 1a000a90 <ingresarDigito+0x1c>
1a000a88:	2b02      	cmp	r3, #2
1a000a8a:	d01e      	beq.n	1a000aca <ingresarDigito+0x56>
	ret = TRUE;
1a000a8c:	2001      	movs	r0, #1
			   indiceTeclaGuardar = 1;
		break;
		}
	}
return ret;
}    
1a000a8e:	4770      	bx	lr
		case 0:  primerDigito = teclaPresionada;
1a000a90:	4b14      	ldr	r3, [pc, #80]	; (1a000ae4 <ingresarDigito+0x70>)
1a000a92:	881a      	ldrh	r2, [r3, #0]
1a000a94:	4b14      	ldr	r3, [pc, #80]	; (1a000ae8 <ingresarDigito+0x74>)
1a000a96:	801a      	strh	r2, [r3, #0]
			   indiceTeclaPresionada = 1;
1a000a98:	2001      	movs	r0, #1
1a000a9a:	4b11      	ldr	r3, [pc, #68]	; (1a000ae0 <ingresarDigito+0x6c>)
1a000a9c:	6018      	str	r0, [r3, #0]
		break;
1a000a9e:	4770      	bx	lr
		case 1:  segundoDigito = teclaPresionada;
1a000aa0:	4b10      	ldr	r3, [pc, #64]	; (1a000ae4 <ingresarDigito+0x70>)
1a000aa2:	881b      	ldrh	r3, [r3, #0]
1a000aa4:	4a11      	ldr	r2, [pc, #68]	; (1a000aec <ingresarDigito+0x78>)
1a000aa6:	8013      	strh	r3, [r2, #0]
			    if ((pinesTeclado[segundoDigito] == 'A') || (pinesTeclado[segundoDigito] == 'B')) {
1a000aa8:	4a11      	ldr	r2, [pc, #68]	; (1a000af0 <ingresarDigito+0x7c>)
1a000aaa:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
1a000aae:	3b41      	subs	r3, #65	; 0x41
1a000ab0:	b29b      	uxth	r3, r3
1a000ab2:	2b01      	cmp	r3, #1
1a000ab4:	d904      	bls.n	1a000ac0 <ingresarDigito+0x4c>
				indiceTeclaPresionada = 2;
1a000ab6:	2202      	movs	r2, #2
1a000ab8:	4b09      	ldr	r3, [pc, #36]	; (1a000ae0 <ingresarDigito+0x6c>)
1a000aba:	601a      	str	r2, [r3, #0]
	ret = TRUE;
1a000abc:	2001      	movs	r0, #1
1a000abe:	4770      	bx	lr
				indiceTeclaPresionada = 0;
1a000ac0:	2200      	movs	r2, #0
1a000ac2:	4b07      	ldr	r3, [pc, #28]	; (1a000ae0 <ingresarDigito+0x6c>)
1a000ac4:	601a      	str	r2, [r3, #0]
	ret = TRUE;
1a000ac6:	2001      	movs	r0, #1
1a000ac8:	4770      	bx	lr
		case 2:  confirmar = teclaPresionada;
1a000aca:	4b06      	ldr	r3, [pc, #24]	; (1a000ae4 <ingresarDigito+0x70>)
1a000acc:	881a      	ldrh	r2, [r3, #0]
1a000ace:	4b09      	ldr	r3, [pc, #36]	; (1a000af4 <ingresarDigito+0x80>)
1a000ad0:	801a      	strh	r2, [r3, #0]
			   indiceTeclaPresionada= 0;
1a000ad2:	2200      	movs	r2, #0
1a000ad4:	4b02      	ldr	r3, [pc, #8]	; (1a000ae0 <ingresarDigito+0x6c>)
1a000ad6:	601a      	str	r2, [r3, #0]
	ret = TRUE;
1a000ad8:	2001      	movs	r0, #1
		break;
1a000ada:	4770      	bx	lr
1a000adc:	100000fb 	.word	0x100000fb
1a000ae0:	10000100 	.word	0x10000100
1a000ae4:	1000000c 	.word	0x1000000c
1a000ae8:	10000106 	.word	0x10000106
1a000aec:	10000108 	.word	0x10000108
1a000af0:	1a0028b8 	.word	0x1a0028b8
1a000af4:	100000d8 	.word	0x100000d8

1a000af8 <guardarPisoSimple>:
//*********************************************************************************************************************
//
//*********************************************************************************************************************
void guardarPisoSimple (int primerDigito) {
	/*======= Funcion que almacena el piso ingresado, de un solo digito, en el vector =======*/
	if (indice < 10) {
1a000af8:	4b0c      	ldr	r3, [pc, #48]	; (1a000b2c <guardarPisoSimple+0x34>)
1a000afa:	681b      	ldr	r3, [r3, #0]
1a000afc:	2b09      	cmp	r3, #9
1a000afe:	dc0a      	bgt.n	1a000b16 <guardarPisoSimple+0x1e>

		if (indice > 0)
1a000b00:	2b00      	cmp	r3, #0
1a000b02:	dd0c      	ble.n	1a000b1e <guardarPisoSimple+0x26>
			almacenarPisos[indice] = pinesTeclado[primerDigito];
1a000b04:	4a0a      	ldr	r2, [pc, #40]	; (1a000b30 <guardarPisoSimple+0x38>)
1a000b06:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
1a000b0a:	4a0a      	ldr	r2, [pc, #40]	; (1a000b34 <guardarPisoSimple+0x3c>)
1a000b0c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		else
			almacenarPisos[0] = pinesTeclado[primerDigito];

		indice ++;
1a000b10:	3301      	adds	r3, #1
1a000b12:	4a06      	ldr	r2, [pc, #24]	; (1a000b2c <guardarPisoSimple+0x34>)
1a000b14:	6013      	str	r3, [r2, #0]
	}

	/*======= Etapa para reinicializar las variables utilizadas y prepararlas para el proximo ingreso =======*/
	primerDigito  = 0;
	segundoDigito = 0;
1a000b16:	2200      	movs	r2, #0
1a000b18:	4b07      	ldr	r3, [pc, #28]	; (1a000b38 <guardarPisoSimple+0x40>)
1a000b1a:	801a      	strh	r2, [r3, #0]
1a000b1c:	4770      	bx	lr
			almacenarPisos[0] = pinesTeclado[primerDigito];
1a000b1e:	4a04      	ldr	r2, [pc, #16]	; (1a000b30 <guardarPisoSimple+0x38>)
1a000b20:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
1a000b24:	4a03      	ldr	r2, [pc, #12]	; (1a000b34 <guardarPisoSimple+0x3c>)
1a000b26:	6011      	str	r1, [r2, #0]
1a000b28:	e7f2      	b.n	1a000b10 <guardarPisoSimple+0x18>
1a000b2a:	bf00      	nop
1a000b2c:	100000fc 	.word	0x100000fc
1a000b30:	1a0028b8 	.word	0x1a0028b8
1a000b34:	1000014c 	.word	0x1000014c
1a000b38:	10000108 	.word	0x10000108

1a000b3c <guardarPisoDoble>:
	/*======= Funcion que almacena el piso ingresado, de dos digitos, en el vector =======*/
	
	int carga = 0;
	
	/*======= Etapa de guardar un subsuelo (numero negativo) en el vector de almacenamiento =======*/
	if (pinesTeclado[primerDigito] == '#' && pinesTeclado[segundoDigito] <= 5)
1a000b3c:	4b15      	ldr	r3, [pc, #84]	; (1a000b94 <guardarPisoDoble+0x58>)
1a000b3e:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
1a000b42:	2b23      	cmp	r3, #35	; 0x23
1a000b44:	d017      	beq.n	1a000b76 <guardarPisoDoble+0x3a>
		carga = 0 - pinesTeclado[segundoDigito];
	else 
		carga = (pinesTeclado[primerDigito] * 10) + pinesTeclado[segundoDigito];
1a000b46:	eb03 0383 	add.w	r3, r3, r3, lsl #2
1a000b4a:	005a      	lsls	r2, r3, #1
1a000b4c:	4b11      	ldr	r3, [pc, #68]	; (1a000b94 <guardarPisoDoble+0x58>)
1a000b4e:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
1a000b52:	4413      	add	r3, r2
	
	/*======= Etapa para verificar si se desea entrar al modo configuracion =======*/
    if (carga == 99) {
1a000b54:	2b63      	cmp	r3, #99	; 0x63
1a000b56:	d015      	beq.n	1a000b84 <guardarPisoDoble+0x48>
    flagConfiguracion = TRUE;
    }
	
	/*======= Etapa de carga en el vector que almacena los pisos ingresados =======*/	
	if (indice < 10){
1a000b58:	4a0f      	ldr	r2, [pc, #60]	; (1a000b98 <guardarPisoDoble+0x5c>)
1a000b5a:	6812      	ldr	r2, [r2, #0]
1a000b5c:	2a09      	cmp	r2, #9
1a000b5e:	dc09      	bgt.n	1a000b74 <guardarPisoDoble+0x38>

		if (carga <= 20){
1a000b60:	2b14      	cmp	r3, #20
1a000b62:	dc07      	bgt.n	1a000b74 <guardarPisoDoble+0x38>

			if (indice > 0)
1a000b64:	2a00      	cmp	r2, #0
1a000b66:	dd11      	ble.n	1a000b8c <guardarPisoDoble+0x50>
				almacenarPisos[indice] = carga;
1a000b68:	490c      	ldr	r1, [pc, #48]	; (1a000b9c <guardarPisoDoble+0x60>)
1a000b6a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
			else 
				almacenarPisos[0] = carga;

			indice++;
1a000b6e:	3201      	adds	r2, #1
1a000b70:	4b09      	ldr	r3, [pc, #36]	; (1a000b98 <guardarPisoDoble+0x5c>)
1a000b72:	601a      	str	r2, [r3, #0]
1a000b74:	4770      	bx	lr
	if (pinesTeclado[primerDigito] == '#' && pinesTeclado[segundoDigito] <= 5)
1a000b76:	4a07      	ldr	r2, [pc, #28]	; (1a000b94 <guardarPisoDoble+0x58>)
1a000b78:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
1a000b7c:	2a05      	cmp	r2, #5
1a000b7e:	d8e2      	bhi.n	1a000b46 <guardarPisoDoble+0xa>
		carga = 0 - pinesTeclado[segundoDigito];
1a000b80:	4253      	negs	r3, r2
1a000b82:	e7e7      	b.n	1a000b54 <guardarPisoDoble+0x18>
    flagConfiguracion = TRUE;
1a000b84:	2101      	movs	r1, #1
1a000b86:	4a06      	ldr	r2, [pc, #24]	; (1a000ba0 <guardarPisoDoble+0x64>)
1a000b88:	7011      	strb	r1, [r2, #0]
1a000b8a:	e7e5      	b.n	1a000b58 <guardarPisoDoble+0x1c>
				almacenarPisos[0] = carga;
1a000b8c:	4903      	ldr	r1, [pc, #12]	; (1a000b9c <guardarPisoDoble+0x60>)
1a000b8e:	600b      	str	r3, [r1, #0]
1a000b90:	e7ed      	b.n	1a000b6e <guardarPisoDoble+0x32>
1a000b92:	bf00      	nop
1a000b94:	1a0028b8 	.word	0x1a0028b8
1a000b98:	100000fc 	.word	0x100000fc
1a000b9c:	1000014c 	.word	0x1000014c
1a000ba0:	1000005c 	.word	0x1000005c

1a000ba4 <ActualizarMEF_tecladoMatricial>:
void ActualizarMEF_tecladoMatricial (void) { 
1a000ba4:	b508      	push	{r3, lr}
ActualizaMEFScanTecla();
1a000ba6:	f7ff ff0d 	bl	1a0009c4 <ActualizaMEFScanTecla>
switch (estadoMefTecladoMatricial) {
1a000baa:	4b28      	ldr	r3, [pc, #160]	; (1a000c4c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000bac:	781b      	ldrb	r3, [r3, #0]
1a000bae:	2b01      	cmp	r3, #1
1a000bb0:	d00d      	beq.n	1a000bce <ActualizarMEF_tecladoMatricial+0x2a>
1a000bb2:	b123      	cbz	r3, 1a000bbe <ActualizarMEF_tecladoMatricial+0x1a>
1a000bb4:	2b02      	cmp	r3, #2
1a000bb6:	d02b      	beq.n	1a000c10 <ActualizarMEF_tecladoMatricial+0x6c>
		InicializarMEF_tecladoMatrical();
1a000bb8:	f7ff feac 	bl	1a000914 <InicializarMEF_tecladoMatrical>
1a000bbc:	bd08      	pop	{r3, pc}
		if( ingresarDigito() ) {
1a000bbe:	f7ff ff59 	bl	1a000a74 <ingresarDigito>
1a000bc2:	2800      	cmp	r0, #0
1a000bc4:	d0fa      	beq.n	1a000bbc <ActualizarMEF_tecladoMatricial+0x18>
				estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_2;
1a000bc6:	2201      	movs	r2, #1
1a000bc8:	4b20      	ldr	r3, [pc, #128]	; (1a000c4c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000bca:	701a      	strb	r2, [r3, #0]
1a000bcc:	bd08      	pop	{r3, pc}
			if( ingresarDigito() ) {
1a000bce:	f7ff ff51 	bl	1a000a74 <ingresarDigito>
1a000bd2:	2800      	cmp	r0, #0
1a000bd4:	d0f2      	beq.n	1a000bbc <ActualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_LETRA;
1a000bd6:	2202      	movs	r2, #2
1a000bd8:	4b1c      	ldr	r3, [pc, #112]	; (1a000c4c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000bda:	701a      	strb	r2, [r3, #0]
				if (pinesTeclado[segundoDigito] == 'A') {
1a000bdc:	4b1c      	ldr	r3, [pc, #112]	; (1a000c50 <ActualizarMEF_tecladoMatricial+0xac>)
1a000bde:	881a      	ldrh	r2, [r3, #0]
1a000be0:	4b1c      	ldr	r3, [pc, #112]	; (1a000c54 <ActualizarMEF_tecladoMatricial+0xb0>)
1a000be2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000be6:	2b41      	cmp	r3, #65	; 0x41
1a000be8:	d00a      	beq.n	1a000c00 <ActualizarMEF_tecladoMatricial+0x5c>
				else if (pinesTeclado[confirmar] == 'B') {
1a000bea:	4b1b      	ldr	r3, [pc, #108]	; (1a000c58 <ActualizarMEF_tecladoMatricial+0xb4>)
1a000bec:	881a      	ldrh	r2, [r3, #0]
1a000bee:	4b19      	ldr	r3, [pc, #100]	; (1a000c54 <ActualizarMEF_tecladoMatricial+0xb0>)
1a000bf0:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000bf4:	2b42      	cmp	r3, #66	; 0x42
1a000bf6:	d1e1      	bne.n	1a000bbc <ActualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000bf8:	2200      	movs	r2, #0
1a000bfa:	4b14      	ldr	r3, [pc, #80]	; (1a000c4c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000bfc:	701a      	strb	r2, [r3, #0]
1a000bfe:	bd08      	pop	{r3, pc}
					guardarPisoSimple (primerDigito);
1a000c00:	4b16      	ldr	r3, [pc, #88]	; (1a000c5c <ActualizarMEF_tecladoMatricial+0xb8>)
1a000c02:	8818      	ldrh	r0, [r3, #0]
1a000c04:	f7ff ff78 	bl	1a000af8 <guardarPisoSimple>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000c08:	2200      	movs	r2, #0
1a000c0a:	4b10      	ldr	r3, [pc, #64]	; (1a000c4c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000c0c:	701a      	strb	r2, [r3, #0]
1a000c0e:	bd08      	pop	{r3, pc}
			if ( ingresarDigito() ) {
1a000c10:	f7ff ff30 	bl	1a000a74 <ingresarDigito>
1a000c14:	2800      	cmp	r0, #0
1a000c16:	d0d1      	beq.n	1a000bbc <ActualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_LETRA;
1a000c18:	2202      	movs	r2, #2
1a000c1a:	4b0c      	ldr	r3, [pc, #48]	; (1a000c4c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000c1c:	701a      	strb	r2, [r3, #0]
				if (pinesTeclado[confirmar] == 'A' ) {
1a000c1e:	4b0e      	ldr	r3, [pc, #56]	; (1a000c58 <ActualizarMEF_tecladoMatricial+0xb4>)
1a000c20:	881a      	ldrh	r2, [r3, #0]
1a000c22:	4b0c      	ldr	r3, [pc, #48]	; (1a000c54 <ActualizarMEF_tecladoMatricial+0xb0>)
1a000c24:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000c28:	2b41      	cmp	r3, #65	; 0x41
1a000c2a:	d005      	beq.n	1a000c38 <ActualizarMEF_tecladoMatricial+0x94>
				else if (pinesTeclado[confirmar] == 'B') {
1a000c2c:	2b42      	cmp	r3, #66	; 0x42
1a000c2e:	d1c5      	bne.n	1a000bbc <ActualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000c30:	2200      	movs	r2, #0
1a000c32:	4b06      	ldr	r3, [pc, #24]	; (1a000c4c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000c34:	701a      	strb	r2, [r3, #0]
1a000c36:	bd08      	pop	{r3, pc}
					estadoMefTecladoMatricial = GUARDAR_PISO;
1a000c38:	2203      	movs	r2, #3
1a000c3a:	4b04      	ldr	r3, [pc, #16]	; (1a000c4c <ActualizarMEF_tecladoMatricial+0xa8>)
1a000c3c:	701a      	strb	r2, [r3, #0]
					guardarPisoDoble (primerDigito, segundoDigito);
1a000c3e:	4b04      	ldr	r3, [pc, #16]	; (1a000c50 <ActualizarMEF_tecladoMatricial+0xac>)
1a000c40:	8819      	ldrh	r1, [r3, #0]
1a000c42:	4b06      	ldr	r3, [pc, #24]	; (1a000c5c <ActualizarMEF_tecladoMatricial+0xb8>)
1a000c44:	8818      	ldrh	r0, [r3, #0]
1a000c46:	f7ff ff79 	bl	1a000b3c <guardarPisoDoble>
1a000c4a:	bd08      	pop	{r3, pc}
1a000c4c:	100000f9 	.word	0x100000f9
1a000c50:	10000108 	.word	0x10000108
1a000c54:	1a0028b8 	.word	0x1a0028b8
1a000c58:	100000d8 	.word	0x100000d8
1a000c5c:	10000106 	.word	0x10000106

1a000c60 <itoa>:

 */
char* itoa(int value, char* result, int base)
{
   // check that the base if valid
   if (base < 2 || base > 36) { *result = '\0'; return result; }
1a000c60:	1e93      	subs	r3, r2, #2
1a000c62:	2b22      	cmp	r3, #34	; 0x22
1a000c64:	d802      	bhi.n	1a000c6c <itoa+0xc>
{
1a000c66:	b4f0      	push	{r4, r5, r6, r7}
1a000c68:	460d      	mov	r5, r1
1a000c6a:	e005      	b.n	1a000c78 <itoa+0x18>
   if (base < 2 || base > 36) { *result = '\0'; return result; }
1a000c6c:	2300      	movs	r3, #0
1a000c6e:	700b      	strb	r3, [r1, #0]
      tmp_char = *ptr;
      *ptr--= *ptr1;
      *ptr1++ = tmp_char;
   }
   return result;
}
1a000c70:	4608      	mov	r0, r1
1a000c72:	4770      	bx	lr
      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
1a000c74:	4635      	mov	r5, r6
      value /= base;
1a000c76:	4620      	mov	r0, r4
1a000c78:	fb90 f4f2 	sdiv	r4, r0, r2
      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
1a000c7c:	1c6e      	adds	r6, r5, #1
1a000c7e:	fb02 0314 	mls	r3, r2, r4, r0
1a000c82:	3323      	adds	r3, #35	; 0x23
1a000c84:	4f0f      	ldr	r7, [pc, #60]	; (1a000cc4 <itoa+0x64>)
1a000c86:	5cfb      	ldrb	r3, [r7, r3]
1a000c88:	702b      	strb	r3, [r5, #0]
   } while ( value );
1a000c8a:	2c00      	cmp	r4, #0
1a000c8c:	d1f2      	bne.n	1a000c74 <itoa+0x14>
   if (tmp_value < 0) *ptr++ = '-';
1a000c8e:	2800      	cmp	r0, #0
1a000c90:	db04      	blt.n	1a000c9c <itoa+0x3c>
   *ptr-- = '\0';
1a000c92:	1e72      	subs	r2, r6, #1
1a000c94:	2300      	movs	r3, #0
1a000c96:	7033      	strb	r3, [r6, #0]
   char* ptr = result, *ptr1 = result, tmp_char;
1a000c98:	460b      	mov	r3, r1
   while(ptr1 < ptr) {
1a000c9a:	e00d      	b.n	1a000cb8 <itoa+0x58>
   if (tmp_value < 0) *ptr++ = '-';
1a000c9c:	232d      	movs	r3, #45	; 0x2d
1a000c9e:	7033      	strb	r3, [r6, #0]
1a000ca0:	1cae      	adds	r6, r5, #2
1a000ca2:	e7f6      	b.n	1a000c92 <itoa+0x32>
      tmp_char = *ptr;
1a000ca4:	4614      	mov	r4, r2
1a000ca6:	f814 0901 	ldrb.w	r0, [r4], #-1
      *ptr--= *ptr1;
1a000caa:	461d      	mov	r5, r3
1a000cac:	f815 6b01 	ldrb.w	r6, [r5], #1
1a000cb0:	7016      	strb	r6, [r2, #0]
      *ptr1++ = tmp_char;
1a000cb2:	7018      	strb	r0, [r3, #0]
1a000cb4:	462b      	mov	r3, r5
      *ptr--= *ptr1;
1a000cb6:	4622      	mov	r2, r4
   while(ptr1 < ptr) {
1a000cb8:	429a      	cmp	r2, r3
1a000cba:	d8f3      	bhi.n	1a000ca4 <itoa+0x44>
}
1a000cbc:	4608      	mov	r0, r1
1a000cbe:	bcf0      	pop	{r4, r5, r6, r7}
1a000cc0:	4770      	bx	lr
1a000cc2:	bf00      	nop
1a000cc4:	1a002ab0 	.word	0x1a002ab0

1a000cc8 <uartWriteMiDato>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void uartWriteMiDato(char* str, int value, int base)
{
1a000cc8:	b570      	push	{r4, r5, r6, lr}
1a000cca:	460d      	mov	r5, r1
1a000ccc:	4616      	mov	r6, r2

uartWriteString(UART_USB, str);
1a000cce:	4601      	mov	r1, r0
1a000cd0:	2000      	movs	r0, #0
1a000cd2:	f001 fc4f 	bl	1a002574 <uartWriteString>
itoa( value, numeroEnString, base);         
1a000cd6:	4c07      	ldr	r4, [pc, #28]	; (1a000cf4 <uartWriteMiDato+0x2c>)
1a000cd8:	4632      	mov	r2, r6
1a000cda:	4621      	mov	r1, r4
1a000cdc:	4628      	mov	r0, r5
1a000cde:	f7ff ffbf 	bl	1a000c60 <itoa>
uartWriteString( UART_USB, numeroEnString );  
1a000ce2:	4621      	mov	r1, r4
1a000ce4:	2000      	movs	r0, #0
1a000ce6:	f001 fc45 	bl	1a002574 <uartWriteString>
uartWriteString( UART_USB, "\r\n" );  
1a000cea:	4903      	ldr	r1, [pc, #12]	; (1a000cf8 <uartWriteMiDato+0x30>)
1a000cec:	2000      	movs	r0, #0
1a000cee:	f001 fc41 	bl	1a002574 <uartWriteString>
1a000cf2:	bd70      	pop	{r4, r5, r6, pc}
1a000cf4:	10000174 	.word	0x10000174
1a000cf8:	1a002c5c 	.word	0x1a002c5c

1a000cfc <EnviaEstadoInterno>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void EnviaEstadoInterno(void)
{
1a000cfc:	b510      	push	{r4, lr}
// Esta linea permite el borrado de la terminal en la PC usando RealTerm.
uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
1a000cfe:	4952      	ldr	r1, [pc, #328]	; (1a000e48 <EnviaEstadoInterno+0x14c>)
1a000d00:	2000      	movs	r0, #0
1a000d02:	f001 fc37 	bl	1a002574 <uartWriteString>


uartWriteMiDato("Buf[0]= ", almacenarPisos[0], 10);
1a000d06:	4c51      	ldr	r4, [pc, #324]	; (1a000e4c <EnviaEstadoInterno+0x150>)
1a000d08:	220a      	movs	r2, #10
1a000d0a:	6821      	ldr	r1, [r4, #0]
1a000d0c:	4850      	ldr	r0, [pc, #320]	; (1a000e50 <EnviaEstadoInterno+0x154>)
1a000d0e:	f7ff ffdb 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[1]= ", almacenarPisos[1], 10);
1a000d12:	220a      	movs	r2, #10
1a000d14:	6861      	ldr	r1, [r4, #4]
1a000d16:	484f      	ldr	r0, [pc, #316]	; (1a000e54 <EnviaEstadoInterno+0x158>)
1a000d18:	f7ff ffd6 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[2]= ", almacenarPisos[2], 10);
1a000d1c:	220a      	movs	r2, #10
1a000d1e:	68a1      	ldr	r1, [r4, #8]
1a000d20:	484d      	ldr	r0, [pc, #308]	; (1a000e58 <EnviaEstadoInterno+0x15c>)
1a000d22:	f7ff ffd1 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[3]= ", almacenarPisos[3], 10);
1a000d26:	220a      	movs	r2, #10
1a000d28:	68e1      	ldr	r1, [r4, #12]
1a000d2a:	484c      	ldr	r0, [pc, #304]	; (1a000e5c <EnviaEstadoInterno+0x160>)
1a000d2c:	f7ff ffcc 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[4]= ", almacenarPisos[4], 10);
1a000d30:	220a      	movs	r2, #10
1a000d32:	6921      	ldr	r1, [r4, #16]
1a000d34:	484a      	ldr	r0, [pc, #296]	; (1a000e60 <EnviaEstadoInterno+0x164>)
1a000d36:	f7ff ffc7 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[5]= ", almacenarPisos[5], 10);
1a000d3a:	220a      	movs	r2, #10
1a000d3c:	6961      	ldr	r1, [r4, #20]
1a000d3e:	4849      	ldr	r0, [pc, #292]	; (1a000e64 <EnviaEstadoInterno+0x168>)
1a000d40:	f7ff ffc2 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[6]= ", almacenarPisos[6], 10);
1a000d44:	220a      	movs	r2, #10
1a000d46:	69a1      	ldr	r1, [r4, #24]
1a000d48:	4847      	ldr	r0, [pc, #284]	; (1a000e68 <EnviaEstadoInterno+0x16c>)
1a000d4a:	f7ff ffbd 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[7]= ", almacenarPisos[7], 10);
1a000d4e:	220a      	movs	r2, #10
1a000d50:	69e1      	ldr	r1, [r4, #28]
1a000d52:	4846      	ldr	r0, [pc, #280]	; (1a000e6c <EnviaEstadoInterno+0x170>)
1a000d54:	f7ff ffb8 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[8]= ", almacenarPisos[8], 10);
1a000d58:	220a      	movs	r2, #10
1a000d5a:	6a21      	ldr	r1, [r4, #32]
1a000d5c:	4844      	ldr	r0, [pc, #272]	; (1a000e70 <EnviaEstadoInterno+0x174>)
1a000d5e:	f7ff ffb3 	bl	1a000cc8 <uartWriteMiDato>
uartWriteMiDato("Buf[9]= ", almacenarPisos[9], 10);
1a000d62:	220a      	movs	r2, #10
1a000d64:	6a61      	ldr	r1, [r4, #36]	; 0x24
1a000d66:	4843      	ldr	r0, [pc, #268]	; (1a000e74 <EnviaEstadoInterno+0x178>)
1a000d68:	f7ff ffae 	bl	1a000cc8 <uartWriteMiDato>

// uartWriteMiDato("Indice = ", indice, 10);


//uartWriteString(UART_USB, "estadoActualAsc = ");
uartWriteString(UART_USB, "Estado del Ascensor: ");
1a000d6c:	4942      	ldr	r1, [pc, #264]	; (1a000e78 <EnviaEstadoInterno+0x17c>)
1a000d6e:	2000      	movs	r0, #0
1a000d70:	f001 fc00 	bl	1a002574 <uartWriteString>
switch(estadoActualAsc)
1a000d74:	4b41      	ldr	r3, [pc, #260]	; (1a000e7c <EnviaEstadoInterno+0x180>)
1a000d76:	781b      	ldrb	r3, [r3, #0]
1a000d78:	2b05      	cmp	r3, #5
1a000d7a:	d808      	bhi.n	1a000d8e <EnviaEstadoInterno+0x92>
1a000d7c:	e8df f003 	tbb	[pc, r3]
1a000d80:	1a151003 	.word	0x1a151003
1a000d84:	241f      	.short	0x241f
	{
	case EN_PLANTA_BAJA:
		uartWriteString(UART_USB, "En Planta Baja y ");
1a000d86:	493e      	ldr	r1, [pc, #248]	; (1a000e80 <EnviaEstadoInterno+0x184>)
1a000d88:	2000      	movs	r0, #0
1a000d8a:	f001 fbf3 	bl	1a002574 <uartWriteString>
		break;
 	}      	
	
	
// uartWriteString(UART_USB, "estadoActualPuerta = ");	
switch(estadoActualPuerta)
1a000d8e:	4b3d      	ldr	r3, [pc, #244]	; (1a000e84 <EnviaEstadoInterno+0x188>)
1a000d90:	781b      	ldrb	r3, [r3, #0]
1a000d92:	2b05      	cmp	r3, #5
1a000d94:	d821      	bhi.n	1a000dda <EnviaEstadoInterno+0xde>
1a000d96:	e8df f003 	tbb	[pc, r3]
1a000d9a:	381c      	.short	0x381c
1a000d9c:	4c47423d 	.word	0x4c47423d
		uartWriteString(UART_USB, "Subiendo y ");
1a000da0:	4939      	ldr	r1, [pc, #228]	; (1a000e88 <EnviaEstadoInterno+0x18c>)
1a000da2:	2000      	movs	r0, #0
1a000da4:	f001 fbe6 	bl	1a002574 <uartWriteString>
		break;
1a000da8:	e7f1      	b.n	1a000d8e <EnviaEstadoInterno+0x92>
		uartWriteString(UART_USB, "Bajando y ");	
1a000daa:	4938      	ldr	r1, [pc, #224]	; (1a000e8c <EnviaEstadoInterno+0x190>)
1a000dac:	2000      	movs	r0, #0
1a000dae:	f001 fbe1 	bl	1a002574 <uartWriteString>
		break;
1a000db2:	e7ec      	b.n	1a000d8e <EnviaEstadoInterno+0x92>
		uartWriteString(UART_USB, "Parado y ");	
1a000db4:	4936      	ldr	r1, [pc, #216]	; (1a000e90 <EnviaEstadoInterno+0x194>)
1a000db6:	2000      	movs	r0, #0
1a000db8:	f001 fbdc 	bl	1a002574 <uartWriteString>
		break;
1a000dbc:	e7e7      	b.n	1a000d8e <EnviaEstadoInterno+0x92>
		uartWriteString(UART_USB, "Yendo a Planta Baja y ");
1a000dbe:	4935      	ldr	r1, [pc, #212]	; (1a000e94 <EnviaEstadoInterno+0x198>)
1a000dc0:	2000      	movs	r0, #0
1a000dc2:	f001 fbd7 	bl	1a002574 <uartWriteString>
		break;
1a000dc6:	e7e2      	b.n	1a000d8e <EnviaEstadoInterno+0x92>
		uartWriteString(UART_USB, "Modo Configuracion y ");
1a000dc8:	4933      	ldr	r1, [pc, #204]	; (1a000e98 <EnviaEstadoInterno+0x19c>)
1a000dca:	2000      	movs	r0, #0
1a000dcc:	f001 fbd2 	bl	1a002574 <uartWriteString>
		break;
1a000dd0:	e7dd      	b.n	1a000d8e <EnviaEstadoInterno+0x92>
	{
	case PUERTA_CERRADA:
		uartWriteString(UART_USB, "Puertas Cerradas\r\n");
1a000dd2:	4932      	ldr	r1, [pc, #200]	; (1a000e9c <EnviaEstadoInterno+0x1a0>)
1a000dd4:	2000      	movs	r0, #0
1a000dd6:	f001 fbcd 	bl	1a002574 <uartWriteString>
	default:

		break;
 	}      

if (Ask_PideNuevoPisoFlag)
1a000dda:	4b31      	ldr	r3, [pc, #196]	; (1a000ea0 <EnviaEstadoInterno+0x1a4>)
1a000ddc:	681b      	ldr	r3, [r3, #0]
1a000dde:	f013 0f10 	tst.w	r3, #16
1a000de2:	d12b      	bne.n	1a000e3c <EnviaEstadoInterno+0x140>
	uartWriteString(UART_USB, "Pide nuevo piso = SI\r\n");
else	uartWriteString(UART_USB, "Pide nuevo piso = NO\r\n");
1a000de4:	492f      	ldr	r1, [pc, #188]	; (1a000ea4 <EnviaEstadoInterno+0x1a8>)
1a000de6:	2000      	movs	r0, #0
1a000de8:	f001 fbc4 	bl	1a002574 <uartWriteString>

uartWriteMiDato ("Piso Destino = ", pisoDestino, 10);
1a000dec:	220a      	movs	r2, #10
1a000dee:	4b2e      	ldr	r3, [pc, #184]	; (1a000ea8 <EnviaEstadoInterno+0x1ac>)
1a000df0:	f993 1000 	ldrsb.w	r1, [r3]
1a000df4:	482d      	ldr	r0, [pc, #180]	; (1a000eac <EnviaEstadoInterno+0x1b0>)
1a000df6:	f7ff ff67 	bl	1a000cc8 <uartWriteMiDato>

uartWriteMiDato ("Piso Actual = ", pisoActual, 10);
1a000dfa:	220a      	movs	r2, #10
1a000dfc:	4b2c      	ldr	r3, [pc, #176]	; (1a000eb0 <EnviaEstadoInterno+0x1b4>)
1a000dfe:	f993 1000 	ldrsb.w	r1, [r3]
1a000e02:	482c      	ldr	r0, [pc, #176]	; (1a000eb4 <EnviaEstadoInterno+0x1b8>)
1a000e04:	f7ff ff60 	bl	1a000cc8 <uartWriteMiDato>
1a000e08:	bd10      	pop	{r4, pc}
		uartWriteString(UART_USB, "Abriendo Puertas\r\n");
1a000e0a:	492b      	ldr	r1, [pc, #172]	; (1a000eb8 <EnviaEstadoInterno+0x1bc>)
1a000e0c:	2000      	movs	r0, #0
1a000e0e:	f001 fbb1 	bl	1a002574 <uartWriteString>
		break;
1a000e12:	e7e2      	b.n	1a000dda <EnviaEstadoInterno+0xde>
		uartWriteString(UART_USB, "Puertas Abiertas\r\n");
1a000e14:	4929      	ldr	r1, [pc, #164]	; (1a000ebc <EnviaEstadoInterno+0x1c0>)
1a000e16:	2000      	movs	r0, #0
1a000e18:	f001 fbac 	bl	1a002574 <uartWriteString>
		break;
1a000e1c:	e7dd      	b.n	1a000dda <EnviaEstadoInterno+0xde>
		uartWriteString(UART_USB, "Intentado Cerrar Puertas\r\n");
1a000e1e:	4928      	ldr	r1, [pc, #160]	; (1a000ec0 <EnviaEstadoInterno+0x1c4>)
1a000e20:	2000      	movs	r0, #0
1a000e22:	f001 fba7 	bl	1a002574 <uartWriteString>
		break;
1a000e26:	e7d8      	b.n	1a000dda <EnviaEstadoInterno+0xde>
		uartWriteString(UART_USB, "Cerrando Puertas\r\n");
1a000e28:	4926      	ldr	r1, [pc, #152]	; (1a000ec4 <EnviaEstadoInterno+0x1c8>)
1a000e2a:	2000      	movs	r0, #0
1a000e2c:	f001 fba2 	bl	1a002574 <uartWriteString>
		break;
1a000e30:	e7d3      	b.n	1a000dda <EnviaEstadoInterno+0xde>
		uartWriteString(UART_USB, "Alarma Puertas Abiertas\r\n");
1a000e32:	4925      	ldr	r1, [pc, #148]	; (1a000ec8 <EnviaEstadoInterno+0x1cc>)
1a000e34:	2000      	movs	r0, #0
1a000e36:	f001 fb9d 	bl	1a002574 <uartWriteString>
		break;
1a000e3a:	e7ce      	b.n	1a000dda <EnviaEstadoInterno+0xde>
	uartWriteString(UART_USB, "Pide nuevo piso = SI\r\n");
1a000e3c:	4923      	ldr	r1, [pc, #140]	; (1a000ecc <EnviaEstadoInterno+0x1d0>)
1a000e3e:	2000      	movs	r0, #0
1a000e40:	f001 fb98 	bl	1a002574 <uartWriteString>
1a000e44:	e7d2      	b.n	1a000dec <EnviaEstadoInterno+0xf0>
1a000e46:	bf00      	nop
1a000e48:	1a0028d8 	.word	0x1a0028d8
1a000e4c:	1000014c 	.word	0x1000014c
1a000e50:	1a0028e0 	.word	0x1a0028e0
1a000e54:	1a0028ec 	.word	0x1a0028ec
1a000e58:	1a0028f8 	.word	0x1a0028f8
1a000e5c:	1a002904 	.word	0x1a002904
1a000e60:	1a002910 	.word	0x1a002910
1a000e64:	1a00291c 	.word	0x1a00291c
1a000e68:	1a002928 	.word	0x1a002928
1a000e6c:	1a002934 	.word	0x1a002934
1a000e70:	1a002940 	.word	0x1a002940
1a000e74:	1a00294c 	.word	0x1a00294c
1a000e78:	1a002958 	.word	0x1a002958
1a000e7c:	10000148 	.word	0x10000148
1a000e80:	1a002970 	.word	0x1a002970
1a000e84:	10000149 	.word	0x10000149
1a000e88:	1a002984 	.word	0x1a002984
1a000e8c:	1a002990 	.word	0x1a002990
1a000e90:	1a00299c 	.word	0x1a00299c
1a000e94:	1a0029a8 	.word	0x1a0029a8
1a000e98:	1a0029c0 	.word	0x1a0029c0
1a000e9c:	1a0029d8 	.word	0x1a0029d8
1a000ea0:	10000058 	.word	0x10000058
1a000ea4:	1a002a78 	.word	0x1a002a78
1a000ea8:	1000005e 	.word	0x1000005e
1a000eac:	1a002a90 	.word	0x1a002a90
1a000eb0:	1000005d 	.word	0x1000005d
1a000eb4:	1a002aa0 	.word	0x1a002aa0
1a000eb8:	1a0029ec 	.word	0x1a0029ec
1a000ebc:	1a002a00 	.word	0x1a002a00
1a000ec0:	1a002a14 	.word	0x1a002a14
1a000ec4:	1a002a30 	.word	0x1a002a30
1a000ec8:	1a002a44 	.word	0x1a002a44
1a000ecc:	1a002a60 	.word	0x1a002a60

1a000ed0 <ConfigDisplay>:

//*************************************************************************************************
//			Configura pines para los dígitos Anodo Comun!
//*************************************************************************************************
void ConfigDisplay(void)
{
1a000ed0:	b538      	push	{r3, r4, r5, lr}
uint8_t i = 0;

// Se setean los pines correspondientes a los segmentos como salida y en cero.
for (i=0; i<8; i++)
1a000ed2:	2400      	movs	r4, #0
1a000ed4:	e00b      	b.n	1a000eee <ConfigDisplay+0x1e>
	{
	gpioConfig (segmentosdisplayB[i], GPIO_OUTPUT);
1a000ed6:	4b0f      	ldr	r3, [pc, #60]	; (1a000f14 <ConfigDisplay+0x44>)
1a000ed8:	5d1d      	ldrb	r5, [r3, r4]
1a000eda:	2101      	movs	r1, #1
1a000edc:	4628      	mov	r0, r5
1a000ede:	f001 f8e9 	bl	1a0020b4 <gpioConfig>
	#ifdef ANODO_COMUN
	gpioWrite (segmentosdisplayB[i], 1);
1a000ee2:	2101      	movs	r1, #1
1a000ee4:	4628      	mov	r0, r5
1a000ee6:	f001 f99f 	bl	1a002228 <gpioWrite>
for (i=0; i<8; i++)
1a000eea:	3401      	adds	r4, #1
1a000eec:	b2e4      	uxtb	r4, r4
1a000eee:	2c07      	cmp	r4, #7
1a000ef0:	d9f1      	bls.n	1a000ed6 <ConfigDisplay+0x6>
1a000ef2:	2400      	movs	r4, #0
1a000ef4:	e00b      	b.n	1a000f0e <ConfigDisplay+0x3e>
	}

// Se setean los pines correspondientes al control de los anodos común de los dígitos, en salida y cero.
for (i=0; i<4; i++)
	{
	gpioConfig (quedisplayB[i], GPIO_OUTPUT);
1a000ef6:	4b08      	ldr	r3, [pc, #32]	; (1a000f18 <ConfigDisplay+0x48>)
1a000ef8:	5d1d      	ldrb	r5, [r3, r4]
1a000efa:	2101      	movs	r1, #1
1a000efc:	4628      	mov	r0, r5
1a000efe:	f001 f8d9 	bl	1a0020b4 <gpioConfig>
	#ifdef ANODO_COMUN
		gpioWrite (quedisplayB[i], 1);
1a000f02:	2101      	movs	r1, #1
1a000f04:	4628      	mov	r0, r5
1a000f06:	f001 f98f 	bl	1a002228 <gpioWrite>
for (i=0; i<4; i++)
1a000f0a:	3401      	adds	r4, #1
1a000f0c:	b2e4      	uxtb	r4, r4
1a000f0e:	2c03      	cmp	r4, #3
1a000f10:	d9f1      	bls.n	1a000ef6 <ConfigDisplay+0x26>
	#elif defined(CATODO_COMUN)
		gpioWrite (quedisplayB[i], 0);
	#endif   		
	}
}
1a000f12:	bd38      	pop	{r3, r4, r5, pc}
1a000f14:	1a002b18 	.word	0x1a002b18
1a000f18:	1a002b14 	.word	0x1a002b14

1a000f1c <SacaDigito>:

//*********************************************************************************************************************
//			Actualiza un dígito Anodo Comun!
//*********************************************************************************************************************
void SacaDigito(uint8_t numero, uint8_t lcdx)
{
1a000f1c:	b538      	push	{r3, r4, r5, lr}
1a000f1e:	4605      	mov	r5, r0
1a000f20:	460c      	mov	r4, r1
uint8_t i = 0;

gpioWrite (LCD1, 1);
1a000f22:	2101      	movs	r1, #1
1a000f24:	2010      	movs	r0, #16
1a000f26:	f001 f97f 	bl	1a002228 <gpioWrite>
gpioWrite (LCD2, 1);
1a000f2a:	2101      	movs	r1, #1
1a000f2c:	2011      	movs	r0, #17
1a000f2e:	f001 f97b 	bl	1a002228 <gpioWrite>
gpioWrite (LCD3, 1);
1a000f32:	2101      	movs	r1, #1
1a000f34:	2012      	movs	r0, #18
1a000f36:	f001 f977 	bl	1a002228 <gpioWrite>
gpioWrite (LCD4, 1);
1a000f3a:	2101      	movs	r1, #1
1a000f3c:	2014      	movs	r0, #20
1a000f3e:	f001 f973 	bl	1a002228 <gpioWrite>
gpioWrite (lcdx, 0);
1a000f42:	2100      	movs	r1, #0
1a000f44:	4620      	mov	r0, r4
1a000f46:	f001 f96f 	bl	1a002228 <gpioWrite>

for (i=0; i<=7; i++)
1a000f4a:	2400      	movs	r4, #0
1a000f4c:	e00d      	b.n	1a000f6a <SacaDigito+0x4e>
	#ifdef ANODO_COMUN
		gpioWrite (segmentosdisplayB[i], !(numeroadisplayB[numero] & (1 << i)));
1a000f4e:	4b08      	ldr	r3, [pc, #32]	; (1a000f70 <SacaDigito+0x54>)
1a000f50:	5d5b      	ldrb	r3, [r3, r5]
1a000f52:	4123      	asrs	r3, r4
1a000f54:	f013 0f01 	tst.w	r3, #1
1a000f58:	bf0c      	ite	eq
1a000f5a:	2101      	moveq	r1, #1
1a000f5c:	2100      	movne	r1, #0
1a000f5e:	4b05      	ldr	r3, [pc, #20]	; (1a000f74 <SacaDigito+0x58>)
1a000f60:	5d18      	ldrb	r0, [r3, r4]
1a000f62:	f001 f961 	bl	1a002228 <gpioWrite>
for (i=0; i<=7; i++)
1a000f66:	3401      	adds	r4, #1
1a000f68:	b2e4      	uxtb	r4, r4
1a000f6a:	2c07      	cmp	r4, #7
1a000f6c:	d9ef      	bls.n	1a000f4e <SacaDigito+0x32>
	#elif defined(CATODO_COMUN)
		gpioWrite (segmentosdisplayB[i], (numeroadisplayB[numero] & (1 << i)));
	#endif   	
}
1a000f6e:	bd38      	pop	{r3, r4, r5, pc}
1a000f70:	1a002af8 	.word	0x1a002af8
1a000f74:	1a002b18 	.word	0x1a002b18

1a000f78 <ConvierteByte>:
//*********************************************************************************************************************
//
//*********************************************************************************************************************
void ConvierteByte(uint8_t X, uint8_t *p)
{   
if (X)
1a000f78:	4603      	mov	r3, r0
1a000f7a:	b920      	cbnz	r0, 1a000f86 <ConvierteByte+0xe>
	p[1] = X/10;
	X = X%10;
	p[0] = X;
	}
else	{
	p[2] = 0;
1a000f7c:	2300      	movs	r3, #0
1a000f7e:	708b      	strb	r3, [r1, #2]
	p[1] = 0;
1a000f80:	704b      	strb	r3, [r1, #1]
	p[0] = 0;
1a000f82:	700b      	strb	r3, [r1, #0]
1a000f84:	4770      	bx	lr
	p[2] = X/100;
1a000f86:	480a      	ldr	r0, [pc, #40]	; (1a000fb0 <ConvierteByte+0x38>)
1a000f88:	fba0 2003 	umull	r2, r0, r0, r3
1a000f8c:	0940      	lsrs	r0, r0, #5
1a000f8e:	7088      	strb	r0, [r1, #2]
	X = X%100;
1a000f90:	2264      	movs	r2, #100	; 0x64
1a000f92:	fb02 3010 	mls	r0, r2, r0, r3
1a000f96:	b2c0      	uxtb	r0, r0
	p[1] = X/10;
1a000f98:	4b06      	ldr	r3, [pc, #24]	; (1a000fb4 <ConvierteByte+0x3c>)
1a000f9a:	fba3 2300 	umull	r2, r3, r3, r0
1a000f9e:	08db      	lsrs	r3, r3, #3
1a000fa0:	704b      	strb	r3, [r1, #1]
	X = X%10;
1a000fa2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
1a000fa6:	005a      	lsls	r2, r3, #1
1a000fa8:	1a80      	subs	r0, r0, r2
	p[0] = X;
1a000faa:	7008      	strb	r0, [r1, #0]
1a000fac:	4770      	bx	lr
1a000fae:	bf00      	nop
1a000fb0:	51eb851f 	.word	0x51eb851f
1a000fb4:	cccccccd 	.word	0xcccccccd

1a000fb8 <ActualizarDisplay>:

//*********************************************************************************************************************
//			Funcion que se encarga de actualizar el display de 4 gigitos 7 segmentos
//*********************************************************************************************************************
void ActualizarDisplay(void)
{
1a000fb8:	b500      	push	{lr}
1a000fba:	b083      	sub	sp, #12

uint8_t valores[3];

// Esta en planta baja?
if (pisoActual == 0 && estadoActualAsc != SUBIENDO && estadoActualAsc != BAJANDO)
1a000fbc:	4b51      	ldr	r3, [pc, #324]	; (1a001104 <ActualizarDisplay+0x14c>)
1a000fbe:	f993 0000 	ldrsb.w	r0, [r3]
1a000fc2:	b9c8      	cbnz	r0, 1a000ff8 <ActualizarDisplay+0x40>
1a000fc4:	4b50      	ldr	r3, [pc, #320]	; (1a001108 <ActualizarDisplay+0x150>)
1a000fc6:	781b      	ldrb	r3, [r3, #0]
1a000fc8:	2b01      	cmp	r3, #1
1a000fca:	d015      	beq.n	1a000ff8 <ActualizarDisplay+0x40>
1a000fcc:	2b02      	cmp	r3, #2
1a000fce:	d013      	beq.n	1a000ff8 <ActualizarDisplay+0x40>
	{
	decenasB = LETRA_P;
1a000fd0:	2216      	movs	r2, #22
1a000fd2:	4b4e      	ldr	r3, [pc, #312]	; (1a00110c <ActualizarDisplay+0x154>)
1a000fd4:	701a      	strb	r2, [r3, #0]
	unidadesB = LETRA_b;
1a000fd6:	220b      	movs	r2, #11
1a000fd8:	4b4d      	ldr	r3, [pc, #308]	; (1a001110 <ActualizarDisplay+0x158>)
1a000fda:	701a      	strb	r2, [r3, #0]
	centenasB = DIGITOAPAGADO;
1a000fdc:	231a      	movs	r3, #26
1a000fde:	4a4d      	ldr	r2, [pc, #308]	; (1a001114 <ActualizarDisplay+0x15c>)
1a000fe0:	7013      	strb	r3, [r2, #0]
	unidadesmilB = DIGITOAPAGADO;
1a000fe2:	4a4d      	ldr	r2, [pc, #308]	; (1a001118 <ActualizarDisplay+0x160>)
1a000fe4:	7013      	strb	r3, [r2, #0]
		unidadesmilB = LETRA_b;
}
	
	

switch (secuenciaB)
1a000fe6:	4b4d      	ldr	r3, [pc, #308]	; (1a00111c <ActualizarDisplay+0x164>)
1a000fe8:	781b      	ldrb	r3, [r3, #0]
1a000fea:	2b03      	cmp	r3, #3
1a000fec:	f200 8084 	bhi.w	1a0010f8 <ActualizarDisplay+0x140>
1a000ff0:	e8df f003 	tbb	[pc, r3]
1a000ff4:	7d73695f 	.word	0x7d73695f
	ConvierteByte(abs(pisoActual), valores);
1a000ff8:	2800      	cmp	r0, #0
1a000ffa:	bfb8      	it	lt
1a000ffc:	4240      	neglt	r0, r0
1a000ffe:	a901      	add	r1, sp, #4
1a001000:	b2c0      	uxtb	r0, r0
1a001002:	f7ff ffb9 	bl	1a000f78 <ConvierteByte>
	if (pisoActual == 0)
1a001006:	4b3f      	ldr	r3, [pc, #252]	; (1a001104 <ActualizarDisplay+0x14c>)
1a001008:	f993 3000 	ldrsb.w	r3, [r3]
1a00100c:	b9c3      	cbnz	r3, 1a001040 <ActualizarDisplay+0x88>
		decenasB = LETRA_P;
1a00100e:	2216      	movs	r2, #22
1a001010:	4b3e      	ldr	r3, [pc, #248]	; (1a00110c <ActualizarDisplay+0x154>)
1a001012:	701a      	strb	r2, [r3, #0]
		unidadesB = LETRA_b;
1a001014:	220b      	movs	r2, #11
1a001016:	4b3e      	ldr	r3, [pc, #248]	; (1a001110 <ActualizarDisplay+0x158>)
1a001018:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a00101a:	231a      	movs	r3, #26
1a00101c:	4a3d      	ldr	r2, [pc, #244]	; (1a001114 <ActualizarDisplay+0x15c>)
1a00101e:	7013      	strb	r3, [r2, #0]
		unidadesmilB = DIGITOAPAGADO;
1a001020:	4a3d      	ldr	r2, [pc, #244]	; (1a001118 <ActualizarDisplay+0x160>)
1a001022:	7013      	strb	r3, [r2, #0]
	if (estadoActualAsc == YENDO_A_PLANTA_BAJA)
1a001024:	4b38      	ldr	r3, [pc, #224]	; (1a001108 <ActualizarDisplay+0x150>)
1a001026:	781b      	ldrb	r3, [r3, #0]
1a001028:	2b04      	cmp	r3, #4
1a00102a:	d027      	beq.n	1a00107c <ActualizarDisplay+0xc4>
	else if (estadoActualAsc == PARADO)
1a00102c:	2b03      	cmp	r3, #3
1a00102e:	d038      	beq.n	1a0010a2 <ActualizarDisplay+0xea>
	else if (estadoActualAsc == SUBIENDO)
1a001030:	2b01      	cmp	r3, #1
1a001032:	d03a      	beq.n	1a0010aa <ActualizarDisplay+0xf2>
	else if (estadoActualAsc == BAJANDO)
1a001034:	2b02      	cmp	r3, #2
1a001036:	d1d6      	bne.n	1a000fe6 <ActualizarDisplay+0x2e>
		unidadesmilB = LETRA_b;
1a001038:	220b      	movs	r2, #11
1a00103a:	4b37      	ldr	r3, [pc, #220]	; (1a001118 <ActualizarDisplay+0x160>)
1a00103c:	701a      	strb	r2, [r3, #0]
1a00103e:	e7d2      	b.n	1a000fe6 <ActualizarDisplay+0x2e>
	else if (pisoActual > 0)
1a001040:	2b00      	cmp	r3, #0
1a001042:	dd10      	ble.n	1a001066 <ActualizarDisplay+0xae>
		if (!valores[1])
1a001044:	f89d 3005 	ldrb.w	r3, [sp, #5]
1a001048:	b953      	cbnz	r3, 1a001060 <ActualizarDisplay+0xa8>
			decenasB = DIGITOAPAGADO;
1a00104a:	221a      	movs	r2, #26
1a00104c:	4b2f      	ldr	r3, [pc, #188]	; (1a00110c <ActualizarDisplay+0x154>)
1a00104e:	701a      	strb	r2, [r3, #0]
		unidadesB = valores[0];
1a001050:	f89d 2004 	ldrb.w	r2, [sp, #4]
1a001054:	4b2e      	ldr	r3, [pc, #184]	; (1a001110 <ActualizarDisplay+0x158>)
1a001056:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a001058:	221a      	movs	r2, #26
1a00105a:	4b2e      	ldr	r3, [pc, #184]	; (1a001114 <ActualizarDisplay+0x15c>)
1a00105c:	701a      	strb	r2, [r3, #0]
1a00105e:	e7e1      	b.n	1a001024 <ActualizarDisplay+0x6c>
		else	decenasB = valores[1];
1a001060:	4a2a      	ldr	r2, [pc, #168]	; (1a00110c <ActualizarDisplay+0x154>)
1a001062:	7013      	strb	r3, [r2, #0]
1a001064:	e7f4      	b.n	1a001050 <ActualizarDisplay+0x98>
		decenasB = SIGNONEG;
1a001066:	2219      	movs	r2, #25
1a001068:	4b28      	ldr	r3, [pc, #160]	; (1a00110c <ActualizarDisplay+0x154>)
1a00106a:	701a      	strb	r2, [r3, #0]
		unidadesB = valores[0];
1a00106c:	f89d 2004 	ldrb.w	r2, [sp, #4]
1a001070:	4b27      	ldr	r3, [pc, #156]	; (1a001110 <ActualizarDisplay+0x158>)
1a001072:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a001074:	221a      	movs	r2, #26
1a001076:	4b27      	ldr	r3, [pc, #156]	; (1a001114 <ActualizarDisplay+0x15c>)
1a001078:	701a      	strb	r2, [r3, #0]
1a00107a:	e7d3      	b.n	1a001024 <ActualizarDisplay+0x6c>
		if (pisoActual > 0)
1a00107c:	4b21      	ldr	r3, [pc, #132]	; (1a001104 <ActualizarDisplay+0x14c>)
1a00107e:	f993 3000 	ldrsb.w	r3, [r3]
1a001082:	2b00      	cmp	r3, #0
1a001084:	dd03      	ble.n	1a00108e <ActualizarDisplay+0xd6>
			unidadesmilB = LETRA_b;
1a001086:	220b      	movs	r2, #11
1a001088:	4b23      	ldr	r3, [pc, #140]	; (1a001118 <ActualizarDisplay+0x160>)
1a00108a:	701a      	strb	r2, [r3, #0]
1a00108c:	e7ab      	b.n	1a000fe6 <ActualizarDisplay+0x2e>
		else if (pisoActual < 0) 
1a00108e:	2b00      	cmp	r3, #0
1a001090:	db03      	blt.n	1a00109a <ActualizarDisplay+0xe2>
		else	unidadesmilB = DIGITOAPAGADO;
1a001092:	221a      	movs	r2, #26
1a001094:	4b20      	ldr	r3, [pc, #128]	; (1a001118 <ActualizarDisplay+0x160>)
1a001096:	701a      	strb	r2, [r3, #0]
1a001098:	e7a5      	b.n	1a000fe6 <ActualizarDisplay+0x2e>
			unidadesmilB = LETRA_S;
1a00109a:	2205      	movs	r2, #5
1a00109c:	4b1e      	ldr	r3, [pc, #120]	; (1a001118 <ActualizarDisplay+0x160>)
1a00109e:	701a      	strb	r2, [r3, #0]
1a0010a0:	e7a1      	b.n	1a000fe6 <ActualizarDisplay+0x2e>
		unidadesmilB = DIGITOAPAGADO;
1a0010a2:	221a      	movs	r2, #26
1a0010a4:	4b1c      	ldr	r3, [pc, #112]	; (1a001118 <ActualizarDisplay+0x160>)
1a0010a6:	701a      	strb	r2, [r3, #0]
1a0010a8:	e79d      	b.n	1a000fe6 <ActualizarDisplay+0x2e>
		unidadesmilB = LETRA_S;
1a0010aa:	2205      	movs	r2, #5
1a0010ac:	4b1a      	ldr	r3, [pc, #104]	; (1a001118 <ActualizarDisplay+0x160>)
1a0010ae:	701a      	strb	r2, [r3, #0]
1a0010b0:	e799      	b.n	1a000fe6 <ActualizarDisplay+0x2e>
	{
	case 0:
		SacaDigito (unidadesB, LCD1);
1a0010b2:	2110      	movs	r1, #16
1a0010b4:	4b16      	ldr	r3, [pc, #88]	; (1a001110 <ActualizarDisplay+0x158>)
1a0010b6:	7818      	ldrb	r0, [r3, #0]
1a0010b8:	f7ff ff30 	bl	1a000f1c <SacaDigito>
		secuenciaB++;
1a0010bc:	4a17      	ldr	r2, [pc, #92]	; (1a00111c <ActualizarDisplay+0x164>)
1a0010be:	7813      	ldrb	r3, [r2, #0]
1a0010c0:	3301      	adds	r3, #1
1a0010c2:	7013      	strb	r3, [r2, #0]
		break;
1a0010c4:	e01b      	b.n	1a0010fe <ActualizarDisplay+0x146>
	case 1:
		SacaDigito (decenasB, LCD2);
1a0010c6:	2111      	movs	r1, #17
1a0010c8:	4b10      	ldr	r3, [pc, #64]	; (1a00110c <ActualizarDisplay+0x154>)
1a0010ca:	7818      	ldrb	r0, [r3, #0]
1a0010cc:	f7ff ff26 	bl	1a000f1c <SacaDigito>
		secuenciaB++;
1a0010d0:	4a12      	ldr	r2, [pc, #72]	; (1a00111c <ActualizarDisplay+0x164>)
1a0010d2:	7813      	ldrb	r3, [r2, #0]
1a0010d4:	3301      	adds	r3, #1
1a0010d6:	7013      	strb	r3, [r2, #0]
		break;
1a0010d8:	e011      	b.n	1a0010fe <ActualizarDisplay+0x146>
	case 2:
		SacaDigito (centenasB, LCD3);
1a0010da:	2112      	movs	r1, #18
1a0010dc:	4b0d      	ldr	r3, [pc, #52]	; (1a001114 <ActualizarDisplay+0x15c>)
1a0010de:	7818      	ldrb	r0, [r3, #0]
1a0010e0:	f7ff ff1c 	bl	1a000f1c <SacaDigito>
		secuenciaB++;
1a0010e4:	4a0d      	ldr	r2, [pc, #52]	; (1a00111c <ActualizarDisplay+0x164>)
1a0010e6:	7813      	ldrb	r3, [r2, #0]
1a0010e8:	3301      	adds	r3, #1
1a0010ea:	7013      	strb	r3, [r2, #0]
		break;
1a0010ec:	e007      	b.n	1a0010fe <ActualizarDisplay+0x146>
	case 3:
		SacaDigito (unidadesmilB, LCD4);
1a0010ee:	2114      	movs	r1, #20
1a0010f0:	4b09      	ldr	r3, [pc, #36]	; (1a001118 <ActualizarDisplay+0x160>)
1a0010f2:	7818      	ldrb	r0, [r3, #0]
1a0010f4:	f7ff ff12 	bl	1a000f1c <SacaDigito>
	
	default:
		secuenciaB = 0;
1a0010f8:	2200      	movs	r2, #0
1a0010fa:	4b08      	ldr	r3, [pc, #32]	; (1a00111c <ActualizarDisplay+0x164>)
1a0010fc:	701a      	strb	r2, [r3, #0]
		break;
	}
}
1a0010fe:	b003      	add	sp, #12
1a001100:	f85d fb04 	ldr.w	pc, [sp], #4
1a001104:	1000005d 	.word	0x1000005d
1a001108:	10000148 	.word	0x10000148
1a00110c:	1000010b 	.word	0x1000010b
1a001110:	1000010d 	.word	0x1000010d
1a001114:	1000010a 	.word	0x1000010a
1a001118:	1000010e 	.word	0x1000010e
1a00111c:	1000010c 	.word	0x1000010c

1a001120 <itoa_2>:

 */
char* itoa_2(int value, char* result, int base)
{
   // check that the base if valid
   if (base < 2 || base > 36) { *result = '\0'; return result; }
1a001120:	1e93      	subs	r3, r2, #2
1a001122:	2b22      	cmp	r3, #34	; 0x22
1a001124:	d802      	bhi.n	1a00112c <itoa_2+0xc>
{
1a001126:	b4f0      	push	{r4, r5, r6, r7}
1a001128:	460d      	mov	r5, r1
1a00112a:	e005      	b.n	1a001138 <itoa_2+0x18>
   if (base < 2 || base > 36) { *result = '\0'; return result; }
1a00112c:	2300      	movs	r3, #0
1a00112e:	700b      	strb	r3, [r1, #0]
      tmp_char = *ptr;
      *ptr--= *ptr1;
      *ptr1++ = tmp_char;
   }
   return result;
}
1a001130:	4608      	mov	r0, r1
1a001132:	4770      	bx	lr
      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
1a001134:	4635      	mov	r5, r6
      value /= base;
1a001136:	4620      	mov	r0, r4
1a001138:	fb90 f4f2 	sdiv	r4, r0, r2
      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
1a00113c:	1c6e      	adds	r6, r5, #1
1a00113e:	fb02 0314 	mls	r3, r2, r4, r0
1a001142:	3323      	adds	r3, #35	; 0x23
1a001144:	4f0f      	ldr	r7, [pc, #60]	; (1a001184 <itoa_2+0x64>)
1a001146:	5cfb      	ldrb	r3, [r7, r3]
1a001148:	702b      	strb	r3, [r5, #0]
   } while ( value );
1a00114a:	2c00      	cmp	r4, #0
1a00114c:	d1f2      	bne.n	1a001134 <itoa_2+0x14>
   if (tmp_value < 0) *ptr++ = '-';
1a00114e:	2800      	cmp	r0, #0
1a001150:	db04      	blt.n	1a00115c <itoa_2+0x3c>
   *ptr-- = '\0';
1a001152:	1e72      	subs	r2, r6, #1
1a001154:	2300      	movs	r3, #0
1a001156:	7033      	strb	r3, [r6, #0]
   char* ptr = result, *ptr1 = result, tmp_char;
1a001158:	460b      	mov	r3, r1
   while(ptr1 < ptr) {
1a00115a:	e00d      	b.n	1a001178 <itoa_2+0x58>
   if (tmp_value < 0) *ptr++ = '-';
1a00115c:	232d      	movs	r3, #45	; 0x2d
1a00115e:	7033      	strb	r3, [r6, #0]
1a001160:	1cae      	adds	r6, r5, #2
1a001162:	e7f6      	b.n	1a001152 <itoa_2+0x32>
      tmp_char = *ptr;
1a001164:	4614      	mov	r4, r2
1a001166:	f814 0901 	ldrb.w	r0, [r4], #-1
      *ptr--= *ptr1;
1a00116a:	461d      	mov	r5, r3
1a00116c:	f815 6b01 	ldrb.w	r6, [r5], #1
1a001170:	7016      	strb	r6, [r2, #0]
      *ptr1++ = tmp_char;
1a001172:	7018      	strb	r0, [r3, #0]
1a001174:	462b      	mov	r3, r5
      *ptr--= *ptr1;
1a001176:	4622      	mov	r2, r4
   while(ptr1 < ptr) {
1a001178:	429a      	cmp	r2, r3
1a00117a:	d8f3      	bhi.n	1a001164 <itoa_2+0x44>
}
1a00117c:	4608      	mov	r0, r1
1a00117e:	bcf0      	pop	{r4, r5, r6, r7}
1a001180:	4770      	bx	lr
1a001182:	bf00      	nop
1a001184:	1a002ab0 	.word	0x1a002ab0

1a001188 <modoConfiguracion>:





bool_t modoConfiguracion( void ){
1a001188:	b570      	push	{r4, r5, r6, lr}
1a00118a:	b082      	sub	sp, #8
static uint32_t datoRecibido = 0;


    
/*================== MENU =====================*/
    if (!flagMenu) {
1a00118c:	4b9f      	ldr	r3, [pc, #636]	; (1a00140c <modoConfiguracion+0x284>)
1a00118e:	781b      	ldrb	r3, [r3, #0]
1a001190:	b183      	cbz	r3, 1a0011b4 <modoConfiguracion+0x2c>


    uartWriteString( UART_USB, "5) Salir del modo configuracion.\r\n" );
	flagMenu = 1;
	}
	if (!flagDatoMenu) {
1a001192:	4b9f      	ldr	r3, [pc, #636]	; (1a001410 <modoConfiguracion+0x288>)
1a001194:	781b      	ldrb	r3, [r3, #0]
1a001196:	2b00      	cmp	r3, #0
1a001198:	d06d      	beq.n	1a001276 <modoConfiguracion+0xee>
			flagDatoMenu = 1;
			//AGREGAR UN CLEAR DE PANTALLA ACÁ.
    	}
	}
	
    switch (datoRecibido)
1a00119a:	4b9e      	ldr	r3, [pc, #632]	; (1a001414 <modoConfiguracion+0x28c>)
1a00119c:	681b      	ldr	r3, [r3, #0]
1a00119e:	3b01      	subs	r3, #1
1a0011a0:	2b04      	cmp	r3, #4
1a0011a2:	f200 8126 	bhi.w	1a0013f2 <modoConfiguracion+0x26a>
1a0011a6:	e8df f013 	tbh	[pc, r3, lsl #1]
1a0011aa:	0075      	.short	0x0075
1a0011ac:	00cd00a2 	.word	0x00cd00a2
1a0011b0:	011c00f6 	.word	0x011c00f6
	uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
1a0011b4:	4998      	ldr	r1, [pc, #608]	; (1a001418 <modoConfiguracion+0x290>)
1a0011b6:	2000      	movs	r0, #0
1a0011b8:	f001 f9dc 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "Eliga una de las siguientes opciones a configurar:\r\n" );
1a0011bc:	4997      	ldr	r1, [pc, #604]	; (1a00141c <modoConfiguracion+0x294>)
1a0011be:	2000      	movs	r0, #0
1a0011c0:	f001 f9d8 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "1) Configurar velocidad entre piso y piso (seg):  " );
1a0011c4:	4996      	ldr	r1, [pc, #600]	; (1a001420 <modoConfiguracion+0x298>)
1a0011c6:	2000      	movs	r0, #0
1a0011c8:	f001 f9d4 	bl	1a002574 <uartWriteString>
	valor = velPisoPiso / 1000;
1a0011cc:	4b95      	ldr	r3, [pc, #596]	; (1a001424 <modoConfiguracion+0x29c>)
1a0011ce:	6818      	ldr	r0, [r3, #0]
1a0011d0:	4e95      	ldr	r6, [pc, #596]	; (1a001428 <modoConfiguracion+0x2a0>)
1a0011d2:	fba6 3000 	umull	r3, r0, r6, r0
	itoa_2( valor, numeroEnString, 10);         
1a0011d6:	4c95      	ldr	r4, [pc, #596]	; (1a00142c <modoConfiguracion+0x2a4>)
1a0011d8:	220a      	movs	r2, #10
1a0011da:	4621      	mov	r1, r4
1a0011dc:	0980      	lsrs	r0, r0, #6
1a0011de:	f7ff ff9f 	bl	1a001120 <itoa_2>
	uartWriteString( UART_USB, numeroEnString );  
1a0011e2:	4621      	mov	r1, r4
1a0011e4:	2000      	movs	r0, #0
1a0011e6:	f001 f9c5 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "\r\n" );  
1a0011ea:	4d91      	ldr	r5, [pc, #580]	; (1a001430 <modoConfiguracion+0x2a8>)
1a0011ec:	4629      	mov	r1, r5
1a0011ee:	2000      	movs	r0, #0
1a0011f0:	f001 f9c0 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "2) Configurar velocidad de apertura o cerrado de puertas (seg):  " );
1a0011f4:	498f      	ldr	r1, [pc, #572]	; (1a001434 <modoConfiguracion+0x2ac>)
1a0011f6:	2000      	movs	r0, #0
1a0011f8:	f001 f9bc 	bl	1a002574 <uartWriteString>
	valor = velAbreCierraPuerta / 1000;
1a0011fc:	4b8e      	ldr	r3, [pc, #568]	; (1a001438 <modoConfiguracion+0x2b0>)
1a0011fe:	6818      	ldr	r0, [r3, #0]
1a001200:	fba6 3000 	umull	r3, r0, r6, r0
	itoa_2( valor, numeroEnString, 10);         
1a001204:	220a      	movs	r2, #10
1a001206:	4621      	mov	r1, r4
1a001208:	0980      	lsrs	r0, r0, #6
1a00120a:	f7ff ff89 	bl	1a001120 <itoa_2>
	uartWriteString( UART_USB, numeroEnString );  
1a00120e:	4621      	mov	r1, r4
1a001210:	2000      	movs	r0, #0
1a001212:	f001 f9af 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "\r\n" );    
1a001216:	4629      	mov	r1, r5
1a001218:	2000      	movs	r0, #0
1a00121a:	f001 f9ab 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "3) Configurar cantidad maxima de pisos (1 a 20):  " );
1a00121e:	4987      	ldr	r1, [pc, #540]	; (1a00143c <modoConfiguracion+0x2b4>)
1a001220:	2000      	movs	r0, #0
1a001222:	f001 f9a7 	bl	1a002574 <uartWriteString>
	itoa_2( maximoDePisos, numeroEnString, 10);         
1a001226:	220a      	movs	r2, #10
1a001228:	4621      	mov	r1, r4
1a00122a:	4b85      	ldr	r3, [pc, #532]	; (1a001440 <modoConfiguracion+0x2b8>)
1a00122c:	7818      	ldrb	r0, [r3, #0]
1a00122e:	f7ff ff77 	bl	1a001120 <itoa_2>
	uartWriteString( UART_USB, numeroEnString );  
1a001232:	4621      	mov	r1, r4
1a001234:	2000      	movs	r0, #0
1a001236:	f001 f99d 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "\r\n" );    
1a00123a:	4629      	mov	r1, r5
1a00123c:	2000      	movs	r0, #0
1a00123e:	f001 f999 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "4) Configurar cantidad maxima de subsuelos (0 a 5):  " );
1a001242:	4980      	ldr	r1, [pc, #512]	; (1a001444 <modoConfiguracion+0x2bc>)
1a001244:	2000      	movs	r0, #0
1a001246:	f001 f995 	bl	1a002574 <uartWriteString>
	itoa_2( maximoDeSubsuelos, numeroEnString, 10);         
1a00124a:	220a      	movs	r2, #10
1a00124c:	4621      	mov	r1, r4
1a00124e:	4b7e      	ldr	r3, [pc, #504]	; (1a001448 <modoConfiguracion+0x2c0>)
1a001250:	7818      	ldrb	r0, [r3, #0]
1a001252:	f7ff ff65 	bl	1a001120 <itoa_2>
	uartWriteString( UART_USB, numeroEnString );  
1a001256:	4621      	mov	r1, r4
1a001258:	2000      	movs	r0, #0
1a00125a:	f001 f98b 	bl	1a002574 <uartWriteString>
	uartWriteString( UART_USB, "\r\n" );    
1a00125e:	4629      	mov	r1, r5
1a001260:	2000      	movs	r0, #0
1a001262:	f001 f987 	bl	1a002574 <uartWriteString>
    uartWriteString( UART_USB, "5) Salir del modo configuracion.\r\n" );
1a001266:	4979      	ldr	r1, [pc, #484]	; (1a00144c <modoConfiguracion+0x2c4>)
1a001268:	2000      	movs	r0, #0
1a00126a:	f001 f983 	bl	1a002574 <uartWriteString>
	flagMenu = 1;
1a00126e:	2201      	movs	r2, #1
1a001270:	4b66      	ldr	r3, [pc, #408]	; (1a00140c <modoConfiguracion+0x284>)
1a001272:	701a      	strb	r2, [r3, #0]
1a001274:	e78d      	b.n	1a001192 <modoConfiguracion+0xa>
		if( uartReadByte( UART_USB, &receivedByte ) ) {
1a001276:	f10d 0107 	add.w	r1, sp, #7
1a00127a:	2000      	movs	r0, #0
1a00127c:	f001 f940 	bl	1a002500 <uartReadByte>
1a001280:	2800      	cmp	r0, #0
1a001282:	d08a      	beq.n	1a00119a <modoConfiguracion+0x12>
			datoRecibido = receivedByte; 
1a001284:	f89d 2007 	ldrb.w	r2, [sp, #7]
1a001288:	4b62      	ldr	r3, [pc, #392]	; (1a001414 <modoConfiguracion+0x28c>)
1a00128a:	601a      	str	r2, [r3, #0]
			flagDatoMenu = 1;
1a00128c:	2201      	movs	r2, #1
1a00128e:	4b60      	ldr	r3, [pc, #384]	; (1a001410 <modoConfiguracion+0x288>)
1a001290:	701a      	strb	r2, [r3, #0]
1a001292:	e782      	b.n	1a00119a <modoConfiguracion+0x12>
	{
    
        case 1:
		if (!flagCase1) {
1a001294:	4b6e      	ldr	r3, [pc, #440]	; (1a001450 <modoConfiguracion+0x2c8>)
1a001296:	781b      	ldrb	r3, [r3, #0]
1a001298:	b1eb      	cbz	r3, 1a0012d6 <modoConfiguracion+0x14e>
			uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
			uartWriteString( UART_USB, "Ingrese la velocidad entre piso y piso en segundos:\r\n" );
			flagCase1 = 1;
			}
                if( uartReadByte( UART_USB, &receivedByte ) ) {
1a00129a:	f10d 0107 	add.w	r1, sp, #7
1a00129e:	2000      	movs	r0, #0
1a0012a0:	f001 f92e 	bl	1a002500 <uartReadByte>
1a0012a4:	4603      	mov	r3, r0
1a0012a6:	2800      	cmp	r0, #0
1a0012a8:	f000 80a0 	beq.w	1a0013ec <modoConfiguracion+0x264>
			if (receivedByte)
1a0012ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
1a0012b0:	2b00      	cmp	r3, #0
1a0012b2:	f000 80a2 	beq.w	1a0013fa <modoConfiguracion+0x272>
				{
				velPisoPiso = receivedByte * 1000;
1a0012b6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
1a0012ba:	fb02 f303 	mul.w	r3, r2, r3
1a0012be:	4a59      	ldr	r2, [pc, #356]	; (1a001424 <modoConfiguracion+0x29c>)
1a0012c0:	6013      	str	r3, [r2, #0]
				flagMenu = 0;
1a0012c2:	2300      	movs	r3, #0
1a0012c4:	4a51      	ldr	r2, [pc, #324]	; (1a00140c <modoConfiguracion+0x284>)
1a0012c6:	7013      	strb	r3, [r2, #0]
				flagCase1 = 0;
1a0012c8:	4a61      	ldr	r2, [pc, #388]	; (1a001450 <modoConfiguracion+0x2c8>)
1a0012ca:	7013      	strb	r3, [r2, #0]
				flagDatoMenu = 0;
1a0012cc:	4a50      	ldr	r2, [pc, #320]	; (1a001410 <modoConfiguracion+0x288>)
1a0012ce:	7013      	strb	r3, [r2, #0]
				datoRecibido = 0;
1a0012d0:	4a50      	ldr	r2, [pc, #320]	; (1a001414 <modoConfiguracion+0x28c>)
1a0012d2:	6013      	str	r3, [r2, #0]
1a0012d4:	e08a      	b.n	1a0013ec <modoConfiguracion+0x264>
			uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
1a0012d6:	4950      	ldr	r1, [pc, #320]	; (1a001418 <modoConfiguracion+0x290>)
1a0012d8:	2000      	movs	r0, #0
1a0012da:	f001 f94b 	bl	1a002574 <uartWriteString>
			uartWriteString( UART_USB, "Ingrese la velocidad entre piso y piso en segundos:\r\n" );
1a0012de:	495d      	ldr	r1, [pc, #372]	; (1a001454 <modoConfiguracion+0x2cc>)
1a0012e0:	2000      	movs	r0, #0
1a0012e2:	f001 f947 	bl	1a002574 <uartWriteString>
			flagCase1 = 1;
1a0012e6:	2201      	movs	r2, #1
1a0012e8:	4b59      	ldr	r3, [pc, #356]	; (1a001450 <modoConfiguracion+0x2c8>)
1a0012ea:	701a      	strb	r2, [r3, #0]
1a0012ec:	e7d5      	b.n	1a00129a <modoConfiguracion+0x112>
				}
			}
            break;
                
        case 2:
		if (!flagCase2) {
1a0012ee:	4b5a      	ldr	r3, [pc, #360]	; (1a001458 <modoConfiguracion+0x2d0>)
1a0012f0:	781b      	ldrb	r3, [r3, #0]
1a0012f2:	b1db      	cbz	r3, 1a00132c <modoConfiguracion+0x1a4>
			uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
			uartWriteString( UART_USB, "Ingrese la velocidad de apertura o cerrado de puertas en segundos:\r\n" );
			flagCase2 = 1;
			}
                if( uartReadByte( UART_USB, &receivedByte ) ) {
1a0012f4:	f10d 0107 	add.w	r1, sp, #7
1a0012f8:	2000      	movs	r0, #0
1a0012fa:	f001 f901 	bl	1a002500 <uartReadByte>
1a0012fe:	4603      	mov	r3, r0
1a001300:	2800      	cmp	r0, #0
1a001302:	d073      	beq.n	1a0013ec <modoConfiguracion+0x264>
			if (receivedByte)
1a001304:	f89d 3007 	ldrb.w	r3, [sp, #7]
1a001308:	2b00      	cmp	r3, #0
1a00130a:	d078      	beq.n	1a0013fe <modoConfiguracion+0x276>
				{
				velAbreCierraPuerta = receivedByte * 1000;
1a00130c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
1a001310:	fb02 f303 	mul.w	r3, r2, r3
1a001314:	4a48      	ldr	r2, [pc, #288]	; (1a001438 <modoConfiguracion+0x2b0>)
1a001316:	6013      	str	r3, [r2, #0]
				flagMenu = 0;
1a001318:	2300      	movs	r3, #0
1a00131a:	4a3c      	ldr	r2, [pc, #240]	; (1a00140c <modoConfiguracion+0x284>)
1a00131c:	7013      	strb	r3, [r2, #0]
				flagCase1 = 0;
1a00131e:	4a4c      	ldr	r2, [pc, #304]	; (1a001450 <modoConfiguracion+0x2c8>)
1a001320:	7013      	strb	r3, [r2, #0]
				flagDatoMenu = 0;
1a001322:	4a3b      	ldr	r2, [pc, #236]	; (1a001410 <modoConfiguracion+0x288>)
1a001324:	7013      	strb	r3, [r2, #0]
				datoRecibido = 0;
1a001326:	4a3b      	ldr	r2, [pc, #236]	; (1a001414 <modoConfiguracion+0x28c>)
1a001328:	6013      	str	r3, [r2, #0]
1a00132a:	e05f      	b.n	1a0013ec <modoConfiguracion+0x264>
			uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
1a00132c:	493a      	ldr	r1, [pc, #232]	; (1a001418 <modoConfiguracion+0x290>)
1a00132e:	2000      	movs	r0, #0
1a001330:	f001 f920 	bl	1a002574 <uartWriteString>
			uartWriteString( UART_USB, "Ingrese la velocidad de apertura o cerrado de puertas en segundos:\r\n" );
1a001334:	4949      	ldr	r1, [pc, #292]	; (1a00145c <modoConfiguracion+0x2d4>)
1a001336:	2000      	movs	r0, #0
1a001338:	f001 f91c 	bl	1a002574 <uartWriteString>
			flagCase2 = 1;
1a00133c:	2201      	movs	r2, #1
1a00133e:	4b46      	ldr	r3, [pc, #280]	; (1a001458 <modoConfiguracion+0x2d0>)
1a001340:	701a      	strb	r2, [r3, #0]
1a001342:	e7d7      	b.n	1a0012f4 <modoConfiguracion+0x16c>
				}
			}
            break;
            
        case 3:
		if (!flagCase3) {
1a001344:	4b46      	ldr	r3, [pc, #280]	; (1a001460 <modoConfiguracion+0x2d8>)
1a001346:	781b      	ldrb	r3, [r3, #0]
1a001348:	b1cb      	cbz	r3, 1a00137e <modoConfiguracion+0x1f6>
			uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
			uartWriteString( UART_USB, "Ingrese la cantidad de pisos (1 a 20):\r\n" );
			flagCase3 = 1;
			}
                if( uartReadByte( UART_USB, &receivedByte ) ) {
1a00134a:	f10d 0107 	add.w	r1, sp, #7
1a00134e:	2000      	movs	r0, #0
1a001350:	f001 f8d6 	bl	1a002500 <uartReadByte>
1a001354:	4603      	mov	r3, r0
1a001356:	2800      	cmp	r0, #0
1a001358:	d048      	beq.n	1a0013ec <modoConfiguracion+0x264>
                    if (receivedByte >= 1 && receivedByte <= 20) {
1a00135a:	f89d 2007 	ldrb.w	r2, [sp, #7]
1a00135e:	1e53      	subs	r3, r2, #1
1a001360:	b2db      	uxtb	r3, r3
1a001362:	2b13      	cmp	r3, #19
1a001364:	d84d      	bhi.n	1a001402 <modoConfiguracion+0x27a>
                        maximoDePisos = receivedByte;
1a001366:	4b36      	ldr	r3, [pc, #216]	; (1a001440 <modoConfiguracion+0x2b8>)
1a001368:	701a      	strb	r2, [r3, #0]
			flagMenu = 0;
1a00136a:	2300      	movs	r3, #0
1a00136c:	4a27      	ldr	r2, [pc, #156]	; (1a00140c <modoConfiguracion+0x284>)
1a00136e:	7013      	strb	r3, [r2, #0]
			flagCase1 = 0;
1a001370:	4a37      	ldr	r2, [pc, #220]	; (1a001450 <modoConfiguracion+0x2c8>)
1a001372:	7013      	strb	r3, [r2, #0]
			flagDatoMenu = 0;
1a001374:	4a26      	ldr	r2, [pc, #152]	; (1a001410 <modoConfiguracion+0x288>)
1a001376:	7013      	strb	r3, [r2, #0]
			datoRecibido = 0;
1a001378:	4a26      	ldr	r2, [pc, #152]	; (1a001414 <modoConfiguracion+0x28c>)
1a00137a:	6013      	str	r3, [r2, #0]
1a00137c:	e036      	b.n	1a0013ec <modoConfiguracion+0x264>
			uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
1a00137e:	4926      	ldr	r1, [pc, #152]	; (1a001418 <modoConfiguracion+0x290>)
1a001380:	2000      	movs	r0, #0
1a001382:	f001 f8f7 	bl	1a002574 <uartWriteString>
			uartWriteString( UART_USB, "Ingrese la cantidad de pisos (1 a 20):\r\n" );
1a001386:	4937      	ldr	r1, [pc, #220]	; (1a001464 <modoConfiguracion+0x2dc>)
1a001388:	2000      	movs	r0, #0
1a00138a:	f001 f8f3 	bl	1a002574 <uartWriteString>
			flagCase3 = 1;
1a00138e:	2201      	movs	r2, #1
1a001390:	4b33      	ldr	r3, [pc, #204]	; (1a001460 <modoConfiguracion+0x2d8>)
1a001392:	701a      	strb	r2, [r3, #0]
1a001394:	e7d9      	b.n	1a00134a <modoConfiguracion+0x1c2>
                }
            break;
            
            
        case 4:
		if (!flagCase4) {
1a001396:	4b34      	ldr	r3, [pc, #208]	; (1a001468 <modoConfiguracion+0x2e0>)
1a001398:	781b      	ldrb	r3, [r3, #0]
1a00139a:	b1b3      	cbz	r3, 1a0013ca <modoConfiguracion+0x242>
			uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
			uartWriteString( UART_USB, "Ingrese la cantidad de subsuelos (0 a 5):\r\n" );
			flagCase4 = 1;
			}
                if( uartReadByte( UART_USB, &receivedByte ) ) {
1a00139c:	f10d 0107 	add.w	r1, sp, #7
1a0013a0:	2000      	movs	r0, #0
1a0013a2:	f001 f8ad 	bl	1a002500 <uartReadByte>
1a0013a6:	4603      	mov	r3, r0
1a0013a8:	b300      	cbz	r0, 1a0013ec <modoConfiguracion+0x264>
                    if (receivedByte >= 0 && receivedByte <= 5) {
1a0013aa:	f89d 3007 	ldrb.w	r3, [sp, #7]
1a0013ae:	2b05      	cmp	r3, #5
1a0013b0:	d829      	bhi.n	1a001406 <modoConfiguracion+0x27e>
                        maximoDeSubsuelos = receivedByte;
1a0013b2:	4a25      	ldr	r2, [pc, #148]	; (1a001448 <modoConfiguracion+0x2c0>)
1a0013b4:	7013      	strb	r3, [r2, #0]
                        flagMenu = 0;
1a0013b6:	2300      	movs	r3, #0
1a0013b8:	4a14      	ldr	r2, [pc, #80]	; (1a00140c <modoConfiguracion+0x284>)
1a0013ba:	7013      	strb	r3, [r2, #0]
			flagCase1 = 0;
1a0013bc:	4a24      	ldr	r2, [pc, #144]	; (1a001450 <modoConfiguracion+0x2c8>)
1a0013be:	7013      	strb	r3, [r2, #0]
			flagDatoMenu = 0;
1a0013c0:	4a13      	ldr	r2, [pc, #76]	; (1a001410 <modoConfiguracion+0x288>)
1a0013c2:	7013      	strb	r3, [r2, #0]
			datoRecibido = 0;
1a0013c4:	4a13      	ldr	r2, [pc, #76]	; (1a001414 <modoConfiguracion+0x28c>)
1a0013c6:	6013      	str	r3, [r2, #0]
1a0013c8:	e010      	b.n	1a0013ec <modoConfiguracion+0x264>
			uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
1a0013ca:	4913      	ldr	r1, [pc, #76]	; (1a001418 <modoConfiguracion+0x290>)
1a0013cc:	2000      	movs	r0, #0
1a0013ce:	f001 f8d1 	bl	1a002574 <uartWriteString>
			uartWriteString( UART_USB, "Ingrese la cantidad de subsuelos (0 a 5):\r\n" );
1a0013d2:	4926      	ldr	r1, [pc, #152]	; (1a00146c <modoConfiguracion+0x2e4>)
1a0013d4:	2000      	movs	r0, #0
1a0013d6:	f001 f8cd 	bl	1a002574 <uartWriteString>
			flagCase4 = 1;
1a0013da:	2201      	movs	r2, #1
1a0013dc:	4b22      	ldr	r3, [pc, #136]	; (1a001468 <modoConfiguracion+0x2e0>)
1a0013de:	701a      	strb	r2, [r3, #0]
1a0013e0:	e7dc      	b.n	1a00139c <modoConfiguracion+0x214>
                }
            break;
            
        case 5:
                //MANEJAR UN FLAG U OTRA OPCION PARA SALIR DEL MODO CONFIGURACION
		uartWriteString( UART_USB, "\x1b[2J\x1b[H" );
1a0013e2:	490d      	ldr	r1, [pc, #52]	; (1a001418 <modoConfiguracion+0x290>)
1a0013e4:	2000      	movs	r0, #0
1a0013e6:	f001 f8c5 	bl	1a002574 <uartWriteString>
		salida = 1;
1a0013ea:	2301      	movs	r3, #1
		flagDatoMenu = 0;
		break;
}

return salida;
}
1a0013ec:	4618      	mov	r0, r3
1a0013ee:	b002      	add	sp, #8
1a0013f0:	bd70      	pop	{r4, r5, r6, pc}
		flagDatoMenu = 0;
1a0013f2:	2300      	movs	r3, #0
1a0013f4:	4a06      	ldr	r2, [pc, #24]	; (1a001410 <modoConfiguracion+0x288>)
1a0013f6:	7013      	strb	r3, [r2, #0]
		break;
1a0013f8:	e7f8      	b.n	1a0013ec <modoConfiguracion+0x264>
bool_t salida = 0;
1a0013fa:	2300      	movs	r3, #0
1a0013fc:	e7f6      	b.n	1a0013ec <modoConfiguracion+0x264>
1a0013fe:	2300      	movs	r3, #0
1a001400:	e7f4      	b.n	1a0013ec <modoConfiguracion+0x264>
1a001402:	2300      	movs	r3, #0
1a001404:	e7f2      	b.n	1a0013ec <modoConfiguracion+0x264>
1a001406:	2300      	movs	r3, #0
1a001408:	e7f0      	b.n	1a0013ec <modoConfiguracion+0x264>
1a00140a:	bf00      	nop
1a00140c:	10000119 	.word	0x10000119
1a001410:	10000118 	.word	0x10000118
1a001414:	10000110 	.word	0x10000110
1a001418:	1a0028d8 	.word	0x1a0028d8
1a00141c:	1a002b20 	.word	0x1a002b20
1a001420:	1a002b58 	.word	0x1a002b58
1a001424:	10000008 	.word	0x10000008
1a001428:	10624dd3 	.word	0x10624dd3
1a00142c:	1000011c 	.word	0x1000011c
1a001430:	1a002c5c 	.word	0x1a002c5c
1a001434:	1a002b8c 	.word	0x1a002b8c
1a001438:	10000004 	.word	0x10000004
1a00143c:	1a002bd0 	.word	0x1a002bd0
1a001440:	10000000 	.word	0x10000000
1a001444:	1a002c04 	.word	0x1a002c04
1a001448:	10000001 	.word	0x10000001
1a00144c:	1a002c3c 	.word	0x1a002c3c
1a001450:	10000114 	.word	0x10000114
1a001454:	1a002c60 	.word	0x1a002c60
1a001458:	10000115 	.word	0x10000115
1a00145c:	1a002c98 	.word	0x1a002c98
1a001460:	10000116 	.word	0x10000116
1a001464:	1a002ce0 	.word	0x1a002ce0
1a001468:	10000117 	.word	0x10000117
1a00146c:	1a002d0c 	.word	0x1a002d0c

1a001470 <SystemCoreClockUpdate>:


/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
1a001470:	b508      	push	{r3, lr}
   /* CPU core speed */
   SystemCoreClock = Chip_Clock_GetRate(CLK_MX_MXCORE);
1a001472:	2069      	movs	r0, #105	; 0x69
1a001474:	f000 fa86 	bl	1a001984 <Chip_Clock_GetRate>
1a001478:	4b01      	ldr	r3, [pc, #4]	; (1a001480 <SystemCoreClockUpdate+0x10>)
1a00147a:	6018      	str	r0, [r3, #0]
1a00147c:	bd08      	pop	{r3, pc}
1a00147e:	bf00      	nop
1a001480:	10000180 	.word	0x10000180

1a001484 <pll_calc_divs>:
       return -val;
   return val;
}

static void pll_calc_divs(uint32_t freq, PLL_PARAM_T *ppll)
{
1a001484:	b5f0      	push	{r4, r5, r6, r7, lr}

   uint32_t prev = freq;
   int n, m, p;

   /* When direct mode is set FBSEL should be a don't care */
   if (ppll->ctrl & (1 << 7)) {
1a001486:	680b      	ldr	r3, [r1, #0]
1a001488:	f013 0f80 	tst.w	r3, #128	; 0x80
1a00148c:	d002      	beq.n	1a001494 <pll_calc_divs+0x10>
       ppll->ctrl &= ~(1 << 6);
1a00148e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
1a001492:	600b      	str	r3, [r1, #0]
1a001494:	4607      	mov	r7, r0
1a001496:	2501      	movs	r5, #1
1a001498:	e03b      	b.n	1a001512 <pll_calc_divs+0x8e>
           for (m = 1; m <= 256; m++) {
               uint32_t fcco, fout;
               if (ppll->ctrl & (1 << 6)) {
                   fcco = ((m << (p + 1)) * ppll->fin) / n;
               } else {
                   fcco = (m * ppll->fin) / n;
1a00149a:	694b      	ldr	r3, [r1, #20]
1a00149c:	fb03 f302 	mul.w	r3, r3, r2
1a0014a0:	fbb3 f3f5 	udiv	r3, r3, r5
1a0014a4:	e014      	b.n	1a0014d0 <pll_calc_divs+0x4c>
               }
               if (fcco < PLL_MIN_CCO_FREQ) continue;
               if (fcco > PLL_MAX_CCO_FREQ) break;
               if (ppll->ctrl & (1 << 7)) {
                   fout = fcco;
1a0014a6:	461c      	mov	r4, r3
1a0014a8:	e020      	b.n	1a0014ec <pll_calc_divs+0x68>
       return -val;
1a0014aa:	f1ce 0e00 	rsb	lr, lr, #0
1a0014ae:	e020      	b.n	1a0014f2 <pll_calc_divs+0x6e>
           for (m = 1; m <= 256; m++) {
1a0014b0:	3201      	adds	r2, #1
1a0014b2:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
1a0014b6:	dc26      	bgt.n	1a001506 <pll_calc_divs+0x82>
               if (ppll->ctrl & (1 << 6)) {
1a0014b8:	680c      	ldr	r4, [r1, #0]
1a0014ba:	f014 0f40 	tst.w	r4, #64	; 0x40
1a0014be:	d0ec      	beq.n	1a00149a <pll_calc_divs+0x16>
                   fcco = ((m << (p + 1)) * ppll->fin) / n;
1a0014c0:	1c73      	adds	r3, r6, #1
1a0014c2:	fa02 fe03 	lsl.w	lr, r2, r3
1a0014c6:	694b      	ldr	r3, [r1, #20]
1a0014c8:	fb03 f30e 	mul.w	r3, r3, lr
1a0014cc:	fbb3 f3f5 	udiv	r3, r3, r5
               if (fcco < PLL_MIN_CCO_FREQ) continue;
1a0014d0:	f8df e048 	ldr.w	lr, [pc, #72]	; 1a00151c <pll_calc_divs+0x98>
1a0014d4:	4573      	cmp	r3, lr
1a0014d6:	d9eb      	bls.n	1a0014b0 <pll_calc_divs+0x2c>
               if (fcco > PLL_MAX_CCO_FREQ) break;
1a0014d8:	f8df e044 	ldr.w	lr, [pc, #68]	; 1a001520 <pll_calc_divs+0x9c>
1a0014dc:	4573      	cmp	r3, lr
1a0014de:	d812      	bhi.n	1a001506 <pll_calc_divs+0x82>
               if (ppll->ctrl & (1 << 7)) {
1a0014e0:	f014 0f80 	tst.w	r4, #128	; 0x80
1a0014e4:	d1df      	bne.n	1a0014a6 <pll_calc_divs+0x22>
               } else {
                   fout = fcco >> (p + 1);
1a0014e6:	1c74      	adds	r4, r6, #1
1a0014e8:	fa23 f404 	lsr.w	r4, r3, r4
   if (val < 0)
1a0014ec:	ebb0 0e04 	subs.w	lr, r0, r4
1a0014f0:	d4db      	bmi.n	1a0014aa <pll_calc_divs+0x26>
               }

               if (ABS(freq - fout) < prev) {
1a0014f2:	4577      	cmp	r7, lr
1a0014f4:	d9dc      	bls.n	1a0014b0 <pll_calc_divs+0x2c>
                   ppll->nsel = n;
1a0014f6:	608d      	str	r5, [r1, #8]
                   ppll->psel = p + 1;
1a0014f8:	1c77      	adds	r7, r6, #1
1a0014fa:	60cf      	str	r7, [r1, #12]
                   ppll->msel = m;
1a0014fc:	610a      	str	r2, [r1, #16]
                   ppll->fout = fout;
1a0014fe:	618c      	str	r4, [r1, #24]
                   ppll->fcco = fcco;
1a001500:	61cb      	str	r3, [r1, #28]
                   prev = ABS(freq - fout);
1a001502:	4677      	mov	r7, lr
1a001504:	e7d4      	b.n	1a0014b0 <pll_calc_divs+0x2c>
       for (p = 0; p < 4; p ++) {
1a001506:	3601      	adds	r6, #1
1a001508:	2e03      	cmp	r6, #3
1a00150a:	dc01      	bgt.n	1a001510 <pll_calc_divs+0x8c>
1a00150c:	2201      	movs	r2, #1
1a00150e:	e7d0      	b.n	1a0014b2 <pll_calc_divs+0x2e>
   for (n = 1; n <= 4; n++) {
1a001510:	3501      	adds	r5, #1
1a001512:	2d04      	cmp	r5, #4
1a001514:	dc01      	bgt.n	1a00151a <pll_calc_divs+0x96>
1a001516:	2600      	movs	r6, #0
1a001518:	e7f6      	b.n	1a001508 <pll_calc_divs+0x84>
               }
           }
       }
   }
}
1a00151a:	bdf0      	pop	{r4, r5, r6, r7, pc}
1a00151c:	094c5eff 	.word	0x094c5eff
1a001520:	1312d000 	.word	0x1312d000

1a001524 <pll_get_frac>:

static void pll_get_frac(uint32_t freq, PLL_PARAM_T *ppll)
{
1a001524:	b5f0      	push	{r4, r5, r6, r7, lr}
1a001526:	b099      	sub	sp, #100	; 0x64
1a001528:	4605      	mov	r5, r0
1a00152a:	460c      	mov	r4, r1
   int diff[3];
   PLL_PARAM_T pll[3] = {{0},{0},{0}};
1a00152c:	2260      	movs	r2, #96	; 0x60
1a00152e:	2100      	movs	r1, #0
1a001530:	4668      	mov	r0, sp
1a001532:	f001 f9b5 	bl	1a0028a0 <memset>

   /* Try direct mode */
   pll[0].ctrl |= (1 << 7);
1a001536:	2380      	movs	r3, #128	; 0x80
1a001538:	9300      	str	r3, [sp, #0]
   pll[0].fin = ppll->fin;
1a00153a:	6963      	ldr	r3, [r4, #20]
1a00153c:	9305      	str	r3, [sp, #20]
   pll[0].srcin = ppll->srcin;
1a00153e:	7923      	ldrb	r3, [r4, #4]
1a001540:	f88d 3004 	strb.w	r3, [sp, #4]
   pll_calc_divs(freq, &pll[0]);
1a001544:	4669      	mov	r1, sp
1a001546:	4628      	mov	r0, r5
1a001548:	f7ff ff9c 	bl	1a001484 <pll_calc_divs>
   if (pll[0].fout == freq) {
1a00154c:	9b06      	ldr	r3, [sp, #24]
1a00154e:	429d      	cmp	r5, r3
1a001550:	d02f      	beq.n	1a0015b2 <pll_get_frac+0x8e>
   if (val < 0)
1a001552:	1aeb      	subs	r3, r5, r3
1a001554:	d436      	bmi.n	1a0015c4 <pll_get_frac+0xa0>
       *ppll = pll[0];
       return ;
   }
   diff[0] = ABS(freq - pll[0].fout);
1a001556:	461e      	mov	r6, r3

   /* Try non-Integer mode */
   pll[2].ctrl = (1 << 6);
1a001558:	2340      	movs	r3, #64	; 0x40
1a00155a:	9310      	str	r3, [sp, #64]	; 0x40
   pll[2].fin = ppll->fin;
1a00155c:	6963      	ldr	r3, [r4, #20]
1a00155e:	9315      	str	r3, [sp, #84]	; 0x54
   pll[2].srcin = ppll->srcin;
1a001560:	7923      	ldrb	r3, [r4, #4]
1a001562:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
   pll_calc_divs(freq, &pll[2]);
1a001566:	a910      	add	r1, sp, #64	; 0x40
1a001568:	4628      	mov	r0, r5
1a00156a:	f7ff ff8b 	bl	1a001484 <pll_calc_divs>
   if (pll[2].fout == freq) {
1a00156e:	9b16      	ldr	r3, [sp, #88]	; 0x58
1a001570:	429d      	cmp	r5, r3
1a001572:	d029      	beq.n	1a0015c8 <pll_get_frac+0xa4>
   if (val < 0)
1a001574:	1aeb      	subs	r3, r5, r3
1a001576:	d42f      	bmi.n	1a0015d8 <pll_get_frac+0xb4>
       *ppll = pll[2];
       return ;
   }

   diff[2] = ABS(freq - pll[2].fout);
1a001578:	461f      	mov	r7, r3
   /* Try integer mode */
   pll[1].ctrl = (1 << 6);
1a00157a:	2340      	movs	r3, #64	; 0x40
1a00157c:	9308      	str	r3, [sp, #32]
   pll[1].fin = ppll->fin;
1a00157e:	6963      	ldr	r3, [r4, #20]
1a001580:	930d      	str	r3, [sp, #52]	; 0x34
   pll[1].srcin = ppll->srcin;
1a001582:	7923      	ldrb	r3, [r4, #4]
1a001584:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   pll_calc_divs(freq, &pll[1]);
1a001588:	a908      	add	r1, sp, #32
1a00158a:	4628      	mov	r0, r5
1a00158c:	f7ff ff7a 	bl	1a001484 <pll_calc_divs>
   if (pll[1].fout == freq) {
1a001590:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1a001592:	429d      	cmp	r5, r3
1a001594:	d022      	beq.n	1a0015dc <pll_get_frac+0xb8>
   if (val < 0)
1a001596:	1aed      	subs	r5, r5, r3
1a001598:	d428      	bmi.n	1a0015ec <pll_get_frac+0xc8>
       return ;
   }
   diff[1] = ABS(freq - pll[1].fout);

   /* Find the min of 3 and return */
   if (diff[0] <= diff[1]) {
1a00159a:	42ae      	cmp	r6, r5
1a00159c:	dc30      	bgt.n	1a001600 <pll_get_frac+0xdc>
       if (diff[0] <= diff[2]) {
1a00159e:	42be      	cmp	r6, r7
1a0015a0:	dc26      	bgt.n	1a0015f0 <pll_get_frac+0xcc>
           *ppll = pll[0];
1a0015a2:	466d      	mov	r5, sp
1a0015a4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0015a6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0015a8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0015ac:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a0015b0:	e006      	b.n	1a0015c0 <pll_get_frac+0x9c>
       *ppll = pll[0];
1a0015b2:	466d      	mov	r5, sp
1a0015b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0015b6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0015b8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0015bc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
           *ppll = pll[1];
       } else {
           *ppll = pll[2];
       }
   }
}
1a0015c0:	b019      	add	sp, #100	; 0x64
1a0015c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
       return -val;
1a0015c4:	425b      	negs	r3, r3
1a0015c6:	e7c6      	b.n	1a001556 <pll_get_frac+0x32>
       *ppll = pll[2];
1a0015c8:	ad10      	add	r5, sp, #64	; 0x40
1a0015ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0015cc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0015ce:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0015d2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
       return ;
1a0015d6:	e7f3      	b.n	1a0015c0 <pll_get_frac+0x9c>
       return -val;
1a0015d8:	425b      	negs	r3, r3
1a0015da:	e7cd      	b.n	1a001578 <pll_get_frac+0x54>
       *ppll = pll[1];
1a0015dc:	ad08      	add	r5, sp, #32
1a0015de:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0015e0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0015e2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0015e6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
       return ;
1a0015ea:	e7e9      	b.n	1a0015c0 <pll_get_frac+0x9c>
       return -val;
1a0015ec:	426d      	negs	r5, r5
1a0015ee:	e7d4      	b.n	1a00159a <pll_get_frac+0x76>
           *ppll = pll[2];
1a0015f0:	ad10      	add	r5, sp, #64	; 0x40
1a0015f2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0015f4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0015f6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0015fa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a0015fe:	e7df      	b.n	1a0015c0 <pll_get_frac+0x9c>
       if (diff[1] <= diff[2]) {
1a001600:	42af      	cmp	r7, r5
1a001602:	db07      	blt.n	1a001614 <pll_get_frac+0xf0>
           *ppll = pll[1];
1a001604:	ad08      	add	r5, sp, #32
1a001606:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001608:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a00160a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a00160e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a001612:	e7d5      	b.n	1a0015c0 <pll_get_frac+0x9c>
           *ppll = pll[2];
1a001614:	ad10      	add	r5, sp, #64	; 0x40
1a001616:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001618:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a00161a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a00161e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a001622:	e7cd      	b.n	1a0015c0 <pll_get_frac+0x9c>

1a001624 <Chip_Clock_FindBaseClock>:
   return Chip_Clock_GetClockInputHz(input) / (div + 1);
}

/* Finds the base clock for the peripheral clock */
static CHIP_CGU_BASE_CLK_T Chip_Clock_FindBaseClock(CHIP_CCU_CLK_T clk)
{
1a001624:	b430      	push	{r4, r5}
1a001626:	4605      	mov	r5, r0
   CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
   int i = 0;
1a001628:	2300      	movs	r3, #0
   CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
1a00162a:	201c      	movs	r0, #28

   while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
1a00162c:	e000      	b.n	1a001630 <Chip_Clock_FindBaseClock+0xc>
       if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
           baseclk = periph_to_base[i].clkbase;
       }
       else {
           i++;
1a00162e:	3301      	adds	r3, #1
   while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
1a001630:	281c      	cmp	r0, #28
1a001632:	d118      	bne.n	1a001666 <Chip_Clock_FindBaseClock+0x42>
1a001634:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a001638:	0051      	lsls	r1, r2, #1
1a00163a:	4a0c      	ldr	r2, [pc, #48]	; (1a00166c <Chip_Clock_FindBaseClock+0x48>)
1a00163c:	440a      	add	r2, r1
1a00163e:	7914      	ldrb	r4, [r2, #4]
1a001640:	42a0      	cmp	r0, r4
1a001642:	d010      	beq.n	1a001666 <Chip_Clock_FindBaseClock+0x42>
       if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
1a001644:	eb03 0143 	add.w	r1, r3, r3, lsl #1
1a001648:	004a      	lsls	r2, r1, #1
1a00164a:	4908      	ldr	r1, [pc, #32]	; (1a00166c <Chip_Clock_FindBaseClock+0x48>)
1a00164c:	5a8a      	ldrh	r2, [r1, r2]
1a00164e:	42aa      	cmp	r2, r5
1a001650:	d8ed      	bhi.n	1a00162e <Chip_Clock_FindBaseClock+0xa>
1a001652:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a001656:	0051      	lsls	r1, r2, #1
1a001658:	4a04      	ldr	r2, [pc, #16]	; (1a00166c <Chip_Clock_FindBaseClock+0x48>)
1a00165a:	440a      	add	r2, r1
1a00165c:	8852      	ldrh	r2, [r2, #2]
1a00165e:	4295      	cmp	r5, r2
1a001660:	d8e5      	bhi.n	1a00162e <Chip_Clock_FindBaseClock+0xa>
           baseclk = periph_to_base[i].clkbase;
1a001662:	4620      	mov	r0, r4
1a001664:	e7e4      	b.n	1a001630 <Chip_Clock_FindBaseClock+0xc>
       }
   }

   return baseclk;
}
1a001666:	bc30      	pop	{r4, r5}
1a001668:	4770      	bx	lr
1a00166a:	bf00      	nop
1a00166c:	1a002d44 	.word	0x1a002d44

1a001670 <Chip_Clock_EnableCrystal>:
 * Public functions
 ****************************************************************************/

/* Enables the crystal oscillator */
void Chip_Clock_EnableCrystal(void)
{
1a001670:	b082      	sub	sp, #8
   volatile uint32_t delay = 1000;
1a001672:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
1a001676:	9301      	str	r3, [sp, #4]

   uint32_t OldCrystalConfig = LPC_CGU->XTAL_OSC_CTRL;
1a001678:	4a0d      	ldr	r2, [pc, #52]	; (1a0016b0 <Chip_Clock_EnableCrystal+0x40>)
1a00167a:	6993      	ldr	r3, [r2, #24]

   /* Clear bypass mode */
   OldCrystalConfig &= (~2);
1a00167c:	f023 0102 	bic.w	r1, r3, #2
   if (OldCrystalConfig != LPC_CGU->XTAL_OSC_CTRL) {
1a001680:	6992      	ldr	r2, [r2, #24]
1a001682:	4291      	cmp	r1, r2
1a001684:	d001      	beq.n	1a00168a <Chip_Clock_EnableCrystal+0x1a>
       LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
1a001686:	4a0a      	ldr	r2, [pc, #40]	; (1a0016b0 <Chip_Clock_EnableCrystal+0x40>)
1a001688:	6191      	str	r1, [r2, #24]
   }

   /* Enable crystal oscillator */
   OldCrystalConfig &= (~1);
1a00168a:	f023 0303 	bic.w	r3, r3, #3
   if (OscRateIn >= 20000000) {
1a00168e:	4a09      	ldr	r2, [pc, #36]	; (1a0016b4 <Chip_Clock_EnableCrystal+0x44>)
1a001690:	6811      	ldr	r1, [r2, #0]
1a001692:	4a09      	ldr	r2, [pc, #36]	; (1a0016b8 <Chip_Clock_EnableCrystal+0x48>)
1a001694:	4291      	cmp	r1, r2
1a001696:	d901      	bls.n	1a00169c <Chip_Clock_EnableCrystal+0x2c>
       OldCrystalConfig |= 4;  /* Set high frequency mode */
1a001698:	f043 0304 	orr.w	r3, r3, #4

   }
   LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
1a00169c:	4a04      	ldr	r2, [pc, #16]	; (1a0016b0 <Chip_Clock_EnableCrystal+0x40>)
1a00169e:	6193      	str	r3, [r2, #24]

   /* Delay for 250uSec */
   while(delay--) {}
1a0016a0:	9b01      	ldr	r3, [sp, #4]
1a0016a2:	1e5a      	subs	r2, r3, #1
1a0016a4:	9201      	str	r2, [sp, #4]
1a0016a6:	2b00      	cmp	r3, #0
1a0016a8:	d1fa      	bne.n	1a0016a0 <Chip_Clock_EnableCrystal+0x30>
}
1a0016aa:	b002      	add	sp, #8
1a0016ac:	4770      	bx	lr
1a0016ae:	bf00      	nop
1a0016b0:	40050000 	.word	0x40050000
1a0016b4:	1a002e0c 	.word	0x1a002e0c
1a0016b8:	01312cff 	.word	0x01312cff

1a0016bc <Chip_Clock_GetDividerSource>:
}

/* Gets a CGU clock divider source */
CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider)
{
   uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];
1a0016bc:	3012      	adds	r0, #18
1a0016be:	4b05      	ldr	r3, [pc, #20]	; (1a0016d4 <Chip_Clock_GetDividerSource+0x18>)
1a0016c0:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

   if (reg & 1) {  /* divider is powered down */
1a0016c4:	f010 0f01 	tst.w	r0, #1
1a0016c8:	d001      	beq.n	1a0016ce <Chip_Clock_GetDividerSource+0x12>
       return CLKINPUT_PD;
1a0016ca:	2011      	movs	r0, #17
   }

   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
}
1a0016cc:	4770      	bx	lr
   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
1a0016ce:	f3c0 6004 	ubfx	r0, r0, #24, #5
1a0016d2:	4770      	bx	lr
1a0016d4:	40050000 	.word	0x40050000

1a0016d8 <Chip_Clock_GetDividerDivisor>:

/* Gets a CGU clock divider divisor */
uint32_t Chip_Clock_GetDividerDivisor(CHIP_CGU_IDIV_T Divider)
{
   return (CHIP_CGU_CLKIN_T) ((LPC_CGU->IDIV_CTRL[Divider] >> 2) & CHIP_CGU_IDIV_MASK(Divider));
1a0016d8:	f100 0212 	add.w	r2, r0, #18
1a0016dc:	4b03      	ldr	r3, [pc, #12]	; (1a0016ec <Chip_Clock_GetDividerDivisor+0x14>)
1a0016de:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
1a0016e2:	4b03      	ldr	r3, [pc, #12]	; (1a0016f0 <Chip_Clock_GetDividerDivisor+0x18>)
1a0016e4:	5c18      	ldrb	r0, [r3, r0]
}
1a0016e6:	ea00 0092 	and.w	r0, r0, r2, lsr #2
1a0016ea:	4770      	bx	lr
1a0016ec:	40050000 	.word	0x40050000
1a0016f0:	1a002d3c 	.word	0x1a002d3c

1a0016f4 <Chip_Clock_GetClockInputHz>:

/* Returns the frequency of the specified input clock source */
uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input)
{
1a0016f4:	b508      	push	{r3, lr}
   uint32_t rate = 0;

   switch (input) {
1a0016f6:	2810      	cmp	r0, #16
1a0016f8:	d80a      	bhi.n	1a001710 <Chip_Clock_GetClockInputHz+0x1c>
1a0016fa:	e8df f000 	tbb	[pc, r0]
1a0016fe:	0b44      	.short	0x0b44
1a001700:	0921180d 	.word	0x0921180d
1a001704:	2d2a2724 	.word	0x2d2a2724
1a001708:	34300909 	.word	0x34300909
1a00170c:	3c38      	.short	0x3c38
1a00170e:	40          	.byte	0x40
1a00170f:	00          	.byte	0x00
   uint32_t rate = 0;
1a001710:	2000      	movs	r0, #0
1a001712:	bd08      	pop	{r3, pc}
   case CLKIN_32K:
       rate = CRYSTAL_32K_FREQ_IN;
       break;

   case CLKIN_IRC:
       rate = CGU_IRC_FREQ;
1a001714:	481e      	ldr	r0, [pc, #120]	; (1a001790 <Chip_Clock_GetClockInputHz+0x9c>)
       break;
1a001716:	bd08      	pop	{r3, pc}

   case CLKIN_ENET_RX:
       if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
1a001718:	4b1e      	ldr	r3, [pc, #120]	; (1a001794 <Chip_Clock_GetClockInputHz+0xa0>)
1a00171a:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
1a00171e:	f003 0307 	and.w	r3, r3, #7
1a001722:	2b04      	cmp	r3, #4
1a001724:	d001      	beq.n	1a00172a <Chip_Clock_GetClockInputHz+0x36>
           /* MII mode requires 25MHz clock */
           rate = 25000000;
1a001726:	481c      	ldr	r0, [pc, #112]	; (1a001798 <Chip_Clock_GetClockInputHz+0xa4>)
1a001728:	bd08      	pop	{r3, pc}
   uint32_t rate = 0;
1a00172a:	2000      	movs	r0, #0
1a00172c:	bd08      	pop	{r3, pc}
       }
       break;

   case CLKIN_ENET_TX:
       if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
1a00172e:	4b19      	ldr	r3, [pc, #100]	; (1a001794 <Chip_Clock_GetClockInputHz+0xa0>)
1a001730:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
1a001734:	f003 0307 	and.w	r3, r3, #7
1a001738:	2b04      	cmp	r3, #4
1a00173a:	d027      	beq.n	1a00178c <Chip_Clock_GetClockInputHz+0x98>
           rate = 25000000; /* MII uses 25 MHz */
1a00173c:	4816      	ldr	r0, [pc, #88]	; (1a001798 <Chip_Clock_GetClockInputHz+0xa4>)
1a00173e:	bd08      	pop	{r3, pc}
           rate = 50000000; /* RMII uses 50 MHz */
       }
       break;

   case CLKIN_CLKIN:
       rate = ExtRateIn;
1a001740:	4b16      	ldr	r3, [pc, #88]	; (1a00179c <Chip_Clock_GetClockInputHz+0xa8>)
1a001742:	6818      	ldr	r0, [r3, #0]
       break;
1a001744:	bd08      	pop	{r3, pc}

   case CLKIN_CRYSTAL:
       rate = OscRateIn;
1a001746:	4b16      	ldr	r3, [pc, #88]	; (1a0017a0 <Chip_Clock_GetClockInputHz+0xac>)
1a001748:	6818      	ldr	r0, [r3, #0]
       break;
1a00174a:	bd08      	pop	{r3, pc}

   case CLKIN_USBPLL:
       rate = audio_usb_pll_freq[CGU_USB_PLL];
1a00174c:	4b15      	ldr	r3, [pc, #84]	; (1a0017a4 <Chip_Clock_GetClockInputHz+0xb0>)
1a00174e:	6818      	ldr	r0, [r3, #0]
       break;
1a001750:	bd08      	pop	{r3, pc}

   case CLKIN_AUDIOPLL:
       rate = audio_usb_pll_freq[CGU_AUDIO_PLL];
1a001752:	4b14      	ldr	r3, [pc, #80]	; (1a0017a4 <Chip_Clock_GetClockInputHz+0xb0>)
1a001754:	6858      	ldr	r0, [r3, #4]
       break;
1a001756:	bd08      	pop	{r3, pc}

   case CLKIN_MAINPLL:
       rate = Chip_Clock_GetMainPLLHz();
1a001758:	f000 f868 	bl	1a00182c <Chip_Clock_GetMainPLLHz>
       break;
1a00175c:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVA:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_A);
1a00175e:	2100      	movs	r1, #0
1a001760:	f000 f89a 	bl	1a001898 <Chip_Clock_GetDivRate>
       break;
1a001764:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVB:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_B);
1a001766:	2101      	movs	r1, #1
1a001768:	f000 f896 	bl	1a001898 <Chip_Clock_GetDivRate>
       break;
1a00176c:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVC:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_C);
1a00176e:	2102      	movs	r1, #2
1a001770:	f000 f892 	bl	1a001898 <Chip_Clock_GetDivRate>
       break;
1a001774:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVD:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_D);
1a001776:	2103      	movs	r1, #3
1a001778:	f000 f88e 	bl	1a001898 <Chip_Clock_GetDivRate>
       break;
1a00177c:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVE:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_E);
1a00177e:	2104      	movs	r1, #4
1a001780:	f000 f88a 	bl	1a001898 <Chip_Clock_GetDivRate>
       break;
1a001784:	bd08      	pop	{r3, pc}
       rate = CRYSTAL_32K_FREQ_IN;
1a001786:	f44f 4000 	mov.w	r0, #32768	; 0x8000
1a00178a:	bd08      	pop	{r3, pc}
           rate = 50000000; /* RMII uses 50 MHz */
1a00178c:	4806      	ldr	r0, [pc, #24]	; (1a0017a8 <Chip_Clock_GetClockInputHz+0xb4>)
   default:
       break;
   }

   return rate;
}
1a00178e:	bd08      	pop	{r3, pc}
1a001790:	00b71b00 	.word	0x00b71b00
1a001794:	40043000 	.word	0x40043000
1a001798:	017d7840 	.word	0x017d7840
1a00179c:	1a002e08 	.word	0x1a002e08
1a0017a0:	1a002e0c 	.word	0x1a002e0c
1a0017a4:	10000128 	.word	0x10000128
1a0017a8:	02faf080 	.word	0x02faf080

1a0017ac <Chip_Clock_CalcMainPLLValue>:
{
1a0017ac:	b538      	push	{r3, r4, r5, lr}
1a0017ae:	4605      	mov	r5, r0
1a0017b0:	460c      	mov	r4, r1
   ppll->fin = Chip_Clock_GetClockInputHz(ppll->srcin);
1a0017b2:	7908      	ldrb	r0, [r1, #4]
1a0017b4:	f7ff ff9e 	bl	1a0016f4 <Chip_Clock_GetClockInputHz>
1a0017b8:	6160      	str	r0, [r4, #20]
   if (freq > MAX_CLOCK_FREQ || freq < (PLL_MIN_CCO_FREQ / 16) || !ppll->fin) {
1a0017ba:	4b19      	ldr	r3, [pc, #100]	; (1a001820 <Chip_Clock_CalcMainPLLValue+0x74>)
1a0017bc:	442b      	add	r3, r5
1a0017be:	4a19      	ldr	r2, [pc, #100]	; (1a001824 <Chip_Clock_CalcMainPLLValue+0x78>)
1a0017c0:	4293      	cmp	r3, r2
1a0017c2:	d821      	bhi.n	1a001808 <Chip_Clock_CalcMainPLLValue+0x5c>
1a0017c4:	b318      	cbz	r0, 1a00180e <Chip_Clock_CalcMainPLLValue+0x62>
   ppll->ctrl = 1 << 7; /* Enable direct mode [If possible] */
1a0017c6:	2380      	movs	r3, #128	; 0x80
1a0017c8:	6023      	str	r3, [r4, #0]
   ppll->nsel = 0;
1a0017ca:	2300      	movs	r3, #0
1a0017cc:	60a3      	str	r3, [r4, #8]
   ppll->psel = 0;
1a0017ce:	60e3      	str	r3, [r4, #12]
   ppll->msel = freq / ppll->fin;
1a0017d0:	fbb5 f3f0 	udiv	r3, r5, r0
1a0017d4:	6123      	str	r3, [r4, #16]
   if (freq < PLL_MIN_CCO_FREQ || ppll->msel * ppll->fin != freq) {
1a0017d6:	4a14      	ldr	r2, [pc, #80]	; (1a001828 <Chip_Clock_CalcMainPLLValue+0x7c>)
1a0017d8:	4295      	cmp	r5, r2
1a0017da:	d903      	bls.n	1a0017e4 <Chip_Clock_CalcMainPLLValue+0x38>
1a0017dc:	fb03 f000 	mul.w	r0, r3, r0
1a0017e0:	4285      	cmp	r5, r0
1a0017e2:	d007      	beq.n	1a0017f4 <Chip_Clock_CalcMainPLLValue+0x48>
       pll_get_frac(freq, ppll);
1a0017e4:	4621      	mov	r1, r4
1a0017e6:	4628      	mov	r0, r5
1a0017e8:	f7ff fe9c 	bl	1a001524 <pll_get_frac>
       if (!ppll->nsel) {
1a0017ec:	68a3      	ldr	r3, [r4, #8]
1a0017ee:	b18b      	cbz	r3, 1a001814 <Chip_Clock_CalcMainPLLValue+0x68>
       ppll->nsel --;
1a0017f0:	3b01      	subs	r3, #1
1a0017f2:	60a3      	str	r3, [r4, #8]
   if (ppll->msel == 0) {
1a0017f4:	6923      	ldr	r3, [r4, #16]
1a0017f6:	b183      	cbz	r3, 1a00181a <Chip_Clock_CalcMainPLLValue+0x6e>
   if (ppll->psel) {
1a0017f8:	68e2      	ldr	r2, [r4, #12]
1a0017fa:	b10a      	cbz	r2, 1a001800 <Chip_Clock_CalcMainPLLValue+0x54>
       ppll->psel --;
1a0017fc:	3a01      	subs	r2, #1
1a0017fe:	60e2      	str	r2, [r4, #12]
   ppll->msel --;
1a001800:	3b01      	subs	r3, #1
1a001802:	6123      	str	r3, [r4, #16]
   return 0;
1a001804:	2000      	movs	r0, #0
1a001806:	bd38      	pop	{r3, r4, r5, pc}
       return -1;
1a001808:	f04f 30ff 	mov.w	r0, #4294967295
1a00180c:	bd38      	pop	{r3, r4, r5, pc}
1a00180e:	f04f 30ff 	mov.w	r0, #4294967295
1a001812:	bd38      	pop	{r3, r4, r5, pc}
           return -1;
1a001814:	f04f 30ff 	mov.w	r0, #4294967295
1a001818:	bd38      	pop	{r3, r4, r5, pc}
       return - 1;
1a00181a:	f04f 30ff 	mov.w	r0, #4294967295
}
1a00181e:	bd38      	pop	{r3, r4, r5, pc}
1a001820:	ff6b3a10 	.word	0xff6b3a10
1a001824:	0b940510 	.word	0x0b940510
1a001828:	094c5eff 	.word	0x094c5eff

1a00182c <Chip_Clock_GetMainPLLHz>:
{
1a00182c:	b530      	push	{r4, r5, lr}
1a00182e:	b083      	sub	sp, #12
   uint32_t PLLReg = LPC_CGU->PLL1_CTRL;
1a001830:	4d17      	ldr	r5, [pc, #92]	; (1a001890 <Chip_Clock_GetMainPLLHz+0x64>)
1a001832:	6c6c      	ldr	r4, [r5, #68]	; 0x44
   uint32_t freq = Chip_Clock_GetClockInputHz((CHIP_CGU_CLKIN_T) ((PLLReg >> 24) & 0xF));
1a001834:	f3c4 6003 	ubfx	r0, r4, #24, #4
1a001838:	f7ff ff5c 	bl	1a0016f4 <Chip_Clock_GetClockInputHz>
   const uint8_t ptab[] = {1, 2, 4, 8};
1a00183c:	4b15      	ldr	r3, [pc, #84]	; (1a001894 <Chip_Clock_GetMainPLLHz+0x68>)
1a00183e:	681b      	ldr	r3, [r3, #0]
1a001840:	9301      	str	r3, [sp, #4]
   if (!(LPC_CGU->PLL1_STAT & 1)) {
1a001842:	6c2b      	ldr	r3, [r5, #64]	; 0x40
1a001844:	f013 0f01 	tst.w	r3, #1
1a001848:	d01f      	beq.n	1a00188a <Chip_Clock_GetMainPLLHz+0x5e>
   msel = (PLLReg >> 16) & 0xFF;
1a00184a:	f3c4 4207 	ubfx	r2, r4, #16, #8
   nsel = (PLLReg >> 12) & 0x3;
1a00184e:	f3c4 3301 	ubfx	r3, r4, #12, #2
   psel = (PLLReg >> 8) & 0x3;
1a001852:	f3c4 2101 	ubfx	r1, r4, #8, #2
   fbsel = (PLLReg >> 6) & 0x1;
1a001856:	f3c4 1580 	ubfx	r5, r4, #6, #1
   m = msel + 1;
1a00185a:	3201      	adds	r2, #1
   n = nsel + 1;
1a00185c:	3301      	adds	r3, #1
   p = ptab[psel];
1a00185e:	f10d 0e08 	add.w	lr, sp, #8
1a001862:	4471      	add	r1, lr
1a001864:	f811 1c04 	ldrb.w	r1, [r1, #-4]
   if (direct || fbsel) {
1a001868:	f014 0f80 	tst.w	r4, #128	; 0x80
1a00186c:	d108      	bne.n	1a001880 <Chip_Clock_GetMainPLLHz+0x54>
1a00186e:	b93d      	cbnz	r5, 1a001880 <Chip_Clock_GetMainPLLHz+0x54>
   return (m / (2 * p)) * (freq / n);
1a001870:	0049      	lsls	r1, r1, #1
1a001872:	fbb2 f2f1 	udiv	r2, r2, r1
1a001876:	fbb0 f0f3 	udiv	r0, r0, r3
1a00187a:	fb00 f002 	mul.w	r0, r0, r2
1a00187e:	e005      	b.n	1a00188c <Chip_Clock_GetMainPLLHz+0x60>
       return m * (freq / n);
1a001880:	fbb0 f0f3 	udiv	r0, r0, r3
1a001884:	fb00 f002 	mul.w	r0, r0, r2
1a001888:	e000      	b.n	1a00188c <Chip_Clock_GetMainPLLHz+0x60>
       return 0;
1a00188a:	2000      	movs	r0, #0
}
1a00188c:	b003      	add	sp, #12
1a00188e:	bd30      	pop	{r4, r5, pc}
1a001890:	40050000 	.word	0x40050000
1a001894:	1a002d38 	.word	0x1a002d38

1a001898 <Chip_Clock_GetDivRate>:
{
1a001898:	b538      	push	{r3, r4, r5, lr}
1a00189a:	460c      	mov	r4, r1
   input = Chip_Clock_GetDividerSource(divider);
1a00189c:	4608      	mov	r0, r1
1a00189e:	f7ff ff0d 	bl	1a0016bc <Chip_Clock_GetDividerSource>
1a0018a2:	4605      	mov	r5, r0
   div = Chip_Clock_GetDividerDivisor(divider);
1a0018a4:	4620      	mov	r0, r4
1a0018a6:	f7ff ff17 	bl	1a0016d8 <Chip_Clock_GetDividerDivisor>
1a0018aa:	4604      	mov	r4, r0
   return Chip_Clock_GetClockInputHz(input) / (div + 1);
1a0018ac:	4628      	mov	r0, r5
1a0018ae:	f7ff ff21 	bl	1a0016f4 <Chip_Clock_GetClockInputHz>
1a0018b2:	3401      	adds	r4, #1
}
1a0018b4:	fbb0 f0f4 	udiv	r0, r0, r4
1a0018b8:	bd38      	pop	{r3, r4, r5, pc}
1a0018ba:	Address 0x1a0018ba is out of bounds.


1a0018bc <Chip_Clock_SetBaseClock>:
   return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
}

/* Sets a CGU Base Clock clock source */
void Chip_Clock_SetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T Input, bool autoblocken, bool powerdn)
{
1a0018bc:	b430      	push	{r4, r5}
   uint32_t reg = LPC_CGU->BASE_CLK[BaseClock];
1a0018be:	f100 0416 	add.w	r4, r0, #22
1a0018c2:	00a4      	lsls	r4, r4, #2
1a0018c4:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
1a0018c8:	f504 24a0 	add.w	r4, r4, #327680	; 0x50000
1a0018cc:	6865      	ldr	r5, [r4, #4]

   if (BaseClock < CLK_BASE_NONE) {
1a0018ce:	281b      	cmp	r0, #27
1a0018d0:	d813      	bhi.n	1a0018fa <Chip_Clock_SetBaseClock+0x3e>
       if (Input != CLKINPUT_PD) {
1a0018d2:	2911      	cmp	r1, #17
1a0018d4:	d01a      	beq.n	1a00190c <Chip_Clock_SetBaseClock+0x50>
           /* Mask off fields we plan to update */
           reg &= ~((0x1F << 24) | 1 | (1 << 11));
1a0018d6:	4c0e      	ldr	r4, [pc, #56]	; (1a001910 <Chip_Clock_SetBaseClock+0x54>)
1a0018d8:	402c      	ands	r4, r5

           if (autoblocken) {
1a0018da:	b10a      	cbz	r2, 1a0018e0 <Chip_Clock_SetBaseClock+0x24>
               reg |= (1 << 11);
1a0018dc:	f444 6400 	orr.w	r4, r4, #2048	; 0x800
           }
           if (powerdn) {
1a0018e0:	b10b      	cbz	r3, 1a0018e6 <Chip_Clock_SetBaseClock+0x2a>
               reg |= (1 << 0);
1a0018e2:	f044 0401 	orr.w	r4, r4, #1
           }

           /* Set clock source */
           reg |= (Input << 24);
1a0018e6:	ea44 6401 	orr.w	r4, r4, r1, lsl #24

           LPC_CGU->BASE_CLK[BaseClock] = reg;
1a0018ea:	3016      	adds	r0, #22
1a0018ec:	0080      	lsls	r0, r0, #2
1a0018ee:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a0018f2:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a0018f6:	6044      	str	r4, [r0, #4]
1a0018f8:	e008      	b.n	1a00190c <Chip_Clock_SetBaseClock+0x50>
       }
   }
   else {
       LPC_CGU->BASE_CLK[BaseClock] = reg | 1; /* Power down this base clock */
1a0018fa:	f045 0501 	orr.w	r5, r5, #1
1a0018fe:	3016      	adds	r0, #22
1a001900:	0080      	lsls	r0, r0, #2
1a001902:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a001906:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a00190a:	6045      	str	r5, [r0, #4]
   }
}
1a00190c:	bc30      	pop	{r4, r5}
1a00190e:	4770      	bx	lr
1a001910:	e0fff7fe 	.word	0xe0fff7fe

1a001914 <Chip_Clock_GetBaseClock>:
/* Gets a CGU Base Clock clock source */
CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
{
   uint32_t reg;

   if (BaseClock >= CLK_BASE_NONE) {
1a001914:	281b      	cmp	r0, #27
1a001916:	d901      	bls.n	1a00191c <Chip_Clock_GetBaseClock+0x8>
       return CLKINPUT_PD;
1a001918:	2011      	movs	r0, #17
1a00191a:	4770      	bx	lr
   }

   reg = LPC_CGU->BASE_CLK[BaseClock];
1a00191c:	3016      	adds	r0, #22
1a00191e:	0080      	lsls	r0, r0, #2
1a001920:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a001924:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a001928:	6840      	ldr	r0, [r0, #4]

   /* base clock is powered down? */
   if (reg & 1) {
1a00192a:	f010 0f01 	tst.w	r0, #1
1a00192e:	d001      	beq.n	1a001934 <Chip_Clock_GetBaseClock+0x20>
       return CLKINPUT_PD;
1a001930:	2011      	movs	r0, #17
   }

   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
}
1a001932:	4770      	bx	lr
   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
1a001934:	f3c0 6004 	ubfx	r0, r0, #24, #5
1a001938:	4770      	bx	lr

1a00193a <Chip_Clock_GetBaseClocktHz>:
{
1a00193a:	b508      	push	{r3, lr}
   return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
1a00193c:	f7ff ffea 	bl	1a001914 <Chip_Clock_GetBaseClock>
1a001940:	f7ff fed8 	bl	1a0016f4 <Chip_Clock_GetClockInputHz>
}
1a001944:	bd08      	pop	{r3, pc}
1a001946:	Address 0x1a001946 is out of bounds.


1a001948 <Chip_Clock_EnableOpts>:
/* Enables a peripheral clock and sets clock states */
void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div)
{
   uint32_t reg = 1;

   if (autoen) {
1a001948:	b969      	cbnz	r1, 1a001966 <Chip_Clock_EnableOpts+0x1e>
   uint32_t reg = 1;
1a00194a:	2101      	movs	r1, #1
       reg |= (1 << 1);
   }
   if (wakeupen) {
1a00194c:	b10a      	cbz	r2, 1a001952 <Chip_Clock_EnableOpts+0xa>
       reg |= (1 << 2);
1a00194e:	f041 0104 	orr.w	r1, r1, #4
   }

   /* Not all clocks support a divider, but we won't check that here. Only
      dividers of 1 and 2 are allowed. Assume 1 if not 2 */
   if (div == 2) {
1a001952:	2b02      	cmp	r3, #2
1a001954:	d009      	beq.n	1a00196a <Chip_Clock_EnableOpts+0x22>
       reg |= (1 << 5);
   }

   /* Setup peripheral clock and start running */
   if (clk >= CLK_CCU2_START) {
1a001956:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a00195a:	d209      	bcs.n	1a001970 <Chip_Clock_EnableOpts+0x28>
       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
   }
   else {
       LPC_CCU1->CLKCCU[clk].CFG = reg;
1a00195c:	3020      	adds	r0, #32
1a00195e:	4b07      	ldr	r3, [pc, #28]	; (1a00197c <Chip_Clock_EnableOpts+0x34>)
1a001960:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
1a001964:	4770      	bx	lr
       reg |= (1 << 1);
1a001966:	2103      	movs	r1, #3
1a001968:	e7f0      	b.n	1a00194c <Chip_Clock_EnableOpts+0x4>
       reg |= (1 << 5);
1a00196a:	f041 0120 	orr.w	r1, r1, #32
1a00196e:	e7f2      	b.n	1a001956 <Chip_Clock_EnableOpts+0xe>
       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
1a001970:	f5a0 7091 	sub.w	r0, r0, #290	; 0x122
1a001974:	4b02      	ldr	r3, [pc, #8]	; (1a001980 <Chip_Clock_EnableOpts+0x38>)
1a001976:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
1a00197a:	4770      	bx	lr
1a00197c:	40051000 	.word	0x40051000
1a001980:	40052000 	.word	0x40052000

1a001984 <Chip_Clock_GetRate>:
   LPC_CCU2->PM = 0;
}

/* Returns a peripheral clock rate */
uint32_t Chip_Clock_GetRate(CHIP_CCU_CLK_T clk)
{
1a001984:	b510      	push	{r4, lr}
   CHIP_CGU_BASE_CLK_T baseclk;
   uint32_t reg, div, rate;

   /* Get CCU config register for clock */
   if (clk >= CLK_CCU2_START) {
1a001986:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a00198a:	d309      	bcc.n	1a0019a0 <Chip_Clock_GetRate+0x1c>
       reg = LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG;
1a00198c:	f5a0 7391 	sub.w	r3, r0, #290	; 0x122
1a001990:	4a0d      	ldr	r2, [pc, #52]	; (1a0019c8 <Chip_Clock_GetRate+0x44>)
1a001992:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
   else {
       reg = LPC_CCU1->CLKCCU[clk].CFG;
   }

   /* Is the clock enabled? */
   if (reg & 1) {
1a001996:	f014 0f01 	tst.w	r4, #1
1a00199a:	d107      	bne.n	1a0019ac <Chip_Clock_GetRate+0x28>

       }
       rate = rate / div;
   }
   else {
       rate = 0;
1a00199c:	2000      	movs	r0, #0
   }

   return rate;
}
1a00199e:	bd10      	pop	{r4, pc}
       reg = LPC_CCU1->CLKCCU[clk].CFG;
1a0019a0:	f100 0320 	add.w	r3, r0, #32
1a0019a4:	4a09      	ldr	r2, [pc, #36]	; (1a0019cc <Chip_Clock_GetRate+0x48>)
1a0019a6:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
1a0019aa:	e7f4      	b.n	1a001996 <Chip_Clock_GetRate+0x12>
       baseclk = Chip_Clock_FindBaseClock(clk);
1a0019ac:	f7ff fe3a 	bl	1a001624 <Chip_Clock_FindBaseClock>
       rate = Chip_Clock_GetBaseClocktHz(baseclk);
1a0019b0:	f7ff ffc3 	bl	1a00193a <Chip_Clock_GetBaseClocktHz>
       if (((reg >> 5) & 0x7) == 0) {
1a0019b4:	f014 0fe0 	tst.w	r4, #224	; 0xe0
1a0019b8:	d103      	bne.n	1a0019c2 <Chip_Clock_GetRate+0x3e>
           div = 1;
1a0019ba:	2301      	movs	r3, #1
       rate = rate / div;
1a0019bc:	fbb0 f0f3 	udiv	r0, r0, r3
1a0019c0:	bd10      	pop	{r4, pc}
           div = 2;/* No other dividers supported */
1a0019c2:	2302      	movs	r3, #2
1a0019c4:	e7fa      	b.n	1a0019bc <Chip_Clock_GetRate+0x38>
1a0019c6:	bf00      	nop
1a0019c8:	40052000 	.word	0x40052000
1a0019cc:	40051000 	.word	0x40051000

1a0019d0 <fpuInit>:
 * Public functions
 ****************************************************************************/

/* Early initialization of the FPU */
void fpuInit(void)
{
1a0019d0:	b084      	sub	sp, #16
   volatile uint32_t Cpacr;
   volatile uint32_t Mvfr0;
   volatile uint32_t Mvfr1;
   char vfpPresent = 0;

   Mvfr0 = *regMvfr0;
1a0019d2:	4b0f      	ldr	r3, [pc, #60]	; (1a001a10 <fpuInit+0x40>)
1a0019d4:	681b      	ldr	r3, [r3, #0]
1a0019d6:	9302      	str	r3, [sp, #8]
   Mvfr1 = *regMvfr1;
1a0019d8:	4b0e      	ldr	r3, [pc, #56]	; (1a001a14 <fpuInit+0x44>)
1a0019da:	681b      	ldr	r3, [r3, #0]
1a0019dc:	9301      	str	r3, [sp, #4]

   vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
1a0019de:	9a02      	ldr	r2, [sp, #8]
1a0019e0:	4b0d      	ldr	r3, [pc, #52]	; (1a001a18 <fpuInit+0x48>)
1a0019e2:	429a      	cmp	r2, r3
1a0019e4:	d00c      	beq.n	1a001a00 <fpuInit+0x30>
1a0019e6:	2300      	movs	r3, #0

   if (vfpPresent) {
1a0019e8:	b143      	cbz	r3, 1a0019fc <fpuInit+0x2c>
       Cpacr = *regCpacr;
1a0019ea:	4a0c      	ldr	r2, [pc, #48]	; (1a001a1c <fpuInit+0x4c>)
1a0019ec:	6813      	ldr	r3, [r2, #0]
1a0019ee:	9303      	str	r3, [sp, #12]
       Cpacr |= (0xF << 20);
1a0019f0:	9b03      	ldr	r3, [sp, #12]
1a0019f2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
1a0019f6:	9303      	str	r3, [sp, #12]
       *regCpacr = Cpacr;  // enable CP10 and CP11 for full access
1a0019f8:	9b03      	ldr	r3, [sp, #12]
1a0019fa:	6013      	str	r3, [r2, #0]
   }
#endif /* __FPU_PRESENT != 0 */
}
1a0019fc:	b004      	add	sp, #16
1a0019fe:	4770      	bx	lr
   vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
1a001a00:	9a01      	ldr	r2, [sp, #4]
1a001a02:	4b07      	ldr	r3, [pc, #28]	; (1a001a20 <fpuInit+0x50>)
1a001a04:	429a      	cmp	r2, r3
1a001a06:	d001      	beq.n	1a001a0c <fpuInit+0x3c>
1a001a08:	2300      	movs	r3, #0
1a001a0a:	e7ed      	b.n	1a0019e8 <fpuInit+0x18>
1a001a0c:	2301      	movs	r3, #1
1a001a0e:	e7eb      	b.n	1a0019e8 <fpuInit+0x18>
1a001a10:	e000ef40 	.word	0xe000ef40
1a001a14:	e000ef44 	.word	0xe000ef44
1a001a18:	10110021 	.word	0x10110021
1a001a1c:	e000ed88 	.word	0xe000ed88
1a001a20:	11000011 	.word	0x11000011

1a001a24 <Chip_GPIO_Init>:
 * Public functions
 ****************************************************************************/

/* Initialize GPIO block */
void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
{
1a001a24:	4770      	bx	lr

1a001a26 <Chip_GPIO_SetDir>:
}

/* Set Direction for a GPIO port */
void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
{
   if (out) {
1a001a26:	b943      	cbnz	r3, 1a001a3a <Chip_GPIO_SetDir+0x14>
       pGPIO->DIR[portNum] |= bitValue;
   }
   else {
       pGPIO->DIR[portNum] &= ~bitValue;
1a001a28:	f501 6100 	add.w	r1, r1, #2048	; 0x800
1a001a2c:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
1a001a30:	ea23 0202 	bic.w	r2, r3, r2
1a001a34:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
1a001a38:	4770      	bx	lr
       pGPIO->DIR[portNum] |= bitValue;
1a001a3a:	f501 6100 	add.w	r1, r1, #2048	; 0x800
1a001a3e:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
1a001a42:	431a      	orrs	r2, r3
1a001a44:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
1a001a48:	4770      	bx	lr
1a001a4a:	Address 0x1a001a4a is out of bounds.


1a001a4c <Chip_SetupCoreClock>:
/*****************************************************************************
 * Public functions
 ****************************************************************************/
/* Setup Chip Core clock */
void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase)
{
1a001a4c:	b570      	push	{r4, r5, r6, lr}
1a001a4e:	b092      	sub	sp, #72	; 0x48
1a001a50:	4605      	mov	r5, r0
1a001a52:	460e      	mov	r6, r1
1a001a54:	4614      	mov	r4, r2
   int i;
   volatile uint32_t delay = 5500;
1a001a56:	f241 537c 	movw	r3, #5500	; 0x157c
1a001a5a:	9311      	str	r3, [sp, #68]	; 0x44
   uint32_t direct = 0;
   PLL_PARAM_T ppll;

   if (clkin == CLKIN_CRYSTAL) {
1a001a5c:	2806      	cmp	r0, #6
1a001a5e:	d044      	beq.n	1a001aea <Chip_SetupCoreClock+0x9e>
       /* Switch main system clocking to crystal */
       Chip_Clock_EnableCrystal();
   }
   Chip_Clock_SetBaseClock(CLK_BASE_MX, clkin, true, false);
1a001a60:	2300      	movs	r3, #0
1a001a62:	2201      	movs	r2, #1
1a001a64:	4629      	mov	r1, r5
1a001a66:	2004      	movs	r0, #4
1a001a68:	f7ff ff28 	bl	1a0018bc <Chip_Clock_SetBaseClock>
 * Saves power if the main PLL is not needed.
 */
__STATIC_INLINE void Chip_Clock_DisableMainPLL(void)
{
   /* power down main PLL */
   LPC_CGU->PLL1_CTRL |= 1;
1a001a6c:	4a4a      	ldr	r2, [pc, #296]	; (1a001b98 <Chip_SetupCoreClock+0x14c>)
1a001a6e:	6c53      	ldr	r3, [r2, #68]	; 0x44
1a001a70:	f043 0301 	orr.w	r3, r3, #1
1a001a74:	6453      	str	r3, [r2, #68]	; 0x44
   Chip_Clock_DisableMainPLL(); /* Disable PLL */

   /* Calculate the PLL Parameters */
   ppll.srcin = clkin;
1a001a76:	f88d 5028 	strb.w	r5, [sp, #40]	; 0x28
   Chip_Clock_CalcMainPLLValue(core_freq, &ppll);
1a001a7a:	a909      	add	r1, sp, #36	; 0x24
1a001a7c:	4630      	mov	r0, r6
1a001a7e:	f7ff fe95 	bl	1a0017ac <Chip_Clock_CalcMainPLLValue>

   if (core_freq > 110000000UL) {
1a001a82:	4b46      	ldr	r3, [pc, #280]	; (1a001b9c <Chip_SetupCoreClock+0x150>)
1a001a84:	429e      	cmp	r6, r3
1a001a86:	d938      	bls.n	1a001afa <Chip_SetupCoreClock+0xae>
       if (!(ppll.ctrl & (1 << 7)) || ppll.psel) {
1a001a88:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a001a8a:	f013 0f80 	tst.w	r3, #128	; 0x80
1a001a8e:	d001      	beq.n	1a001a94 <Chip_SetupCoreClock+0x48>
1a001a90:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a001a92:	b36a      	cbz	r2, 1a001af0 <Chip_SetupCoreClock+0xa4>
           PLL_PARAM_T lpll;
           /* Calculate the PLL Parameters */
           lpll.srcin = clkin;
1a001a94:	f88d 5008 	strb.w	r5, [sp, #8]
           Chip_Clock_CalcMainPLLValue(110000000UL, &lpll);
1a001a98:	a901      	add	r1, sp, #4
1a001a9a:	4840      	ldr	r0, [pc, #256]	; (1a001b9c <Chip_SetupCoreClock+0x150>)
1a001a9c:	f7ff fe86 	bl	1a0017ac <Chip_Clock_CalcMainPLLValue>
 * Make sure the main PLL is enabled.
 */
__STATIC_INLINE void Chip_Clock_SetupMainPLL(const PLL_PARAM_T *ppll)
{
   /* power up main PLL */
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a001aa0:	f89d 2008 	ldrb.w	r2, [sp, #8]
1a001aa4:	9b01      	ldr	r3, [sp, #4]
1a001aa6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a001aaa:	9a05      	ldr	r2, [sp, #20]
1a001aac:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a001ab0:	9a03      	ldr	r2, [sp, #12]
1a001ab2:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a001ab6:	9a04      	ldr	r2, [sp, #16]
1a001ab8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a001abc:	4a36      	ldr	r2, [pc, #216]	; (1a001b98 <Chip_SetupCoreClock+0x14c>)
1a001abe:	6453      	str	r3, [r2, #68]	; 0x44
 * @note   The main PLL should be locked prior to using it as a clock input for a base clock.
 */
__STATIC_INLINE int Chip_Clock_MainPLLLocked(void)
{
   /* Return true if locked */
   return (LPC_CGU->PLL1_STAT & 1) != 0;
1a001ac0:	4b35      	ldr	r3, [pc, #212]	; (1a001b98 <Chip_SetupCoreClock+0x14c>)
1a001ac2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
           Chip_Clock_SetupMainPLL(&lpll);
           /* Wait for the PLL to lock */
           while(!Chip_Clock_MainPLLLocked()) {}
1a001ac4:	f013 0f01 	tst.w	r3, #1
1a001ac8:	d0fa      	beq.n	1a001ac0 <Chip_SetupCoreClock+0x74>
           Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
1a001aca:	2300      	movs	r3, #0
1a001acc:	2201      	movs	r2, #1
1a001ace:	2109      	movs	r1, #9
1a001ad0:	2004      	movs	r0, #4
1a001ad2:	f7ff fef3 	bl	1a0018bc <Chip_Clock_SetBaseClock>
           while(delay --){}
1a001ad6:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a001ad8:	1e5a      	subs	r2, r3, #1
1a001ada:	9211      	str	r2, [sp, #68]	; 0x44
1a001adc:	2b00      	cmp	r3, #0
1a001ade:	d1fa      	bne.n	1a001ad6 <Chip_SetupCoreClock+0x8a>
           delay = 5500;
1a001ae0:	f241 537c 	movw	r3, #5500	; 0x157c
1a001ae4:	9311      	str	r3, [sp, #68]	; 0x44
   uint32_t direct = 0;
1a001ae6:	2500      	movs	r5, #0
       if (!(ppll.ctrl & (1 << 7)) || ppll.psel) {
1a001ae8:	e008      	b.n	1a001afc <Chip_SetupCoreClock+0xb0>
       Chip_Clock_EnableCrystal();
1a001aea:	f7ff fdc1 	bl	1a001670 <Chip_Clock_EnableCrystal>
1a001aee:	e7b7      	b.n	1a001a60 <Chip_SetupCoreClock+0x14>
       } else {
           direct = 1;
           ppll.ctrl &= ~(1 << 7);
1a001af0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1a001af4:	9309      	str	r3, [sp, #36]	; 0x24
           direct = 1;
1a001af6:	2501      	movs	r5, #1
1a001af8:	e000      	b.n	1a001afc <Chip_SetupCoreClock+0xb0>
   uint32_t direct = 0;
1a001afa:	2500      	movs	r5, #0
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a001afc:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
1a001b00:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a001b02:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a001b06:	9a0d      	ldr	r2, [sp, #52]	; 0x34
1a001b08:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a001b0c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
1a001b0e:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a001b12:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a001b14:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a001b18:	4a1f      	ldr	r2, [pc, #124]	; (1a001b98 <Chip_SetupCoreClock+0x14c>)
1a001b1a:	6453      	str	r3, [r2, #68]	; 0x44
   return (LPC_CGU->PLL1_STAT & 1) != 0;
1a001b1c:	4b1e      	ldr	r3, [pc, #120]	; (1a001b98 <Chip_SetupCoreClock+0x14c>)
1a001b1e:	6c1b      	ldr	r3, [r3, #64]	; 0x40

   /* Setup and start the PLL */
   Chip_Clock_SetupMainPLL(&ppll);

   /* Wait for the PLL to lock */
   while(!Chip_Clock_MainPLLLocked()) {}
1a001b20:	f013 0f01 	tst.w	r3, #1
1a001b24:	d0fa      	beq.n	1a001b1c <Chip_SetupCoreClock+0xd0>

   /* Set core clock base as PLL1 */
   Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
1a001b26:	2300      	movs	r3, #0
1a001b28:	2201      	movs	r2, #1
1a001b2a:	2109      	movs	r1, #9
1a001b2c:	2004      	movs	r0, #4
1a001b2e:	f7ff fec5 	bl	1a0018bc <Chip_Clock_SetBaseClock>

   while(delay --){} /* Wait for approx 50 uSec */
1a001b32:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a001b34:	1e5a      	subs	r2, r3, #1
1a001b36:	9211      	str	r2, [sp, #68]	; 0x44
1a001b38:	2b00      	cmp	r3, #0
1a001b3a:	d1fa      	bne.n	1a001b32 <Chip_SetupCoreClock+0xe6>
   if (direct) {
1a001b3c:	b1d5      	cbz	r5, 1a001b74 <Chip_SetupCoreClock+0x128>
       delay = 5500;
1a001b3e:	f241 537c 	movw	r3, #5500	; 0x157c
1a001b42:	9311      	str	r3, [sp, #68]	; 0x44
       ppll.ctrl |= 1 << 7;
1a001b44:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a001b46:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1a001b4a:	9309      	str	r3, [sp, #36]	; 0x24
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a001b4c:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
1a001b50:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a001b54:	9a0d      	ldr	r2, [sp, #52]	; 0x34
1a001b56:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a001b5a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
1a001b5c:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a001b60:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a001b62:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a001b66:	4a0c      	ldr	r2, [pc, #48]	; (1a001b98 <Chip_SetupCoreClock+0x14c>)
1a001b68:	6453      	str	r3, [r2, #68]	; 0x44
       Chip_Clock_SetupMainPLL(&ppll); /* Set DIRECT to operate at full frequency */
       while(delay --){} /* Wait for approx 50 uSec */
1a001b6a:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a001b6c:	1e5a      	subs	r2, r3, #1
1a001b6e:	9211      	str	r2, [sp, #68]	; 0x44
1a001b70:	2b00      	cmp	r3, #0
1a001b72:	d1fa      	bne.n	1a001b6a <Chip_SetupCoreClock+0x11e>
   }

   if (setbase) {
1a001b74:	b174      	cbz	r4, 1a001b94 <Chip_SetupCoreClock+0x148>
1a001b76:	2400      	movs	r4, #0
1a001b78:	e00a      	b.n	1a001b90 <Chip_SetupCoreClock+0x144>
       /* Setup system base clocks and initial states. This won't enable and
          disable individual clocks, but sets up the base clock sources for
          each individual peripheral clock. */
       for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
           Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
1a001b7a:	4809      	ldr	r0, [pc, #36]	; (1a001ba0 <Chip_SetupCoreClock+0x154>)
1a001b7c:	eb00 0184 	add.w	r1, r0, r4, lsl #2
1a001b80:	78cb      	ldrb	r3, [r1, #3]
1a001b82:	788a      	ldrb	r2, [r1, #2]
1a001b84:	7849      	ldrb	r1, [r1, #1]
1a001b86:	f810 0024 	ldrb.w	r0, [r0, r4, lsl #2]
1a001b8a:	f7ff fe97 	bl	1a0018bc <Chip_Clock_SetBaseClock>
       for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a001b8e:	3401      	adds	r4, #1
1a001b90:	2c11      	cmp	r4, #17
1a001b92:	d9f2      	bls.n	1a001b7a <Chip_SetupCoreClock+0x12e>
                                   InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
       }
   }
}
1a001b94:	b012      	add	sp, #72	; 0x48
1a001b96:	bd70      	pop	{r4, r5, r6, pc}
1a001b98:	40050000 	.word	0x40050000
1a001b9c:	068e7780 	.word	0x068e7780
1a001ba0:	1a002db0 	.word	0x1a002db0

1a001ba4 <Chip_UART_GetIndex>:

/* Returns clock index for the peripheral block */
static int Chip_UART_GetIndex(LPC_USART_T *pUART)
{
   uint32_t base = (uint32_t) pUART;
   switch(base) {
1a001ba4:	4b09      	ldr	r3, [pc, #36]	; (1a001bcc <Chip_UART_GetIndex+0x28>)
1a001ba6:	4298      	cmp	r0, r3
1a001ba8:	d009      	beq.n	1a001bbe <Chip_UART_GetIndex+0x1a>
1a001baa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
1a001bae:	4298      	cmp	r0, r3
1a001bb0:	d007      	beq.n	1a001bc2 <Chip_UART_GetIndex+0x1e>
1a001bb2:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
1a001bb6:	4298      	cmp	r0, r3
1a001bb8:	d005      	beq.n	1a001bc6 <Chip_UART_GetIndex+0x22>
       case LPC_USART0_BASE:
           return 0;
1a001bba:	2000      	movs	r0, #0
1a001bbc:	4770      	bx	lr
       case LPC_UART1_BASE:
           return 1;
       case LPC_USART2_BASE:
           return 2;
1a001bbe:	2002      	movs	r0, #2
1a001bc0:	4770      	bx	lr
       case LPC_USART3_BASE:
           return 3;
1a001bc2:	2003      	movs	r0, #3
1a001bc4:	4770      	bx	lr
           return 1;
1a001bc6:	2001      	movs	r0, #1
       default:
           return 0; /* Should never come here */
   }
}
1a001bc8:	4770      	bx	lr
1a001bca:	bf00      	nop
1a001bcc:	400c1000 	.word	0x400c1000

1a001bd0 <Chip_UART_Init>:
 * Public functions
 ****************************************************************************/

/* Initializes the pUART peripheral */
void Chip_UART_Init(LPC_USART_T *pUART)
{
1a001bd0:	b530      	push	{r4, r5, lr}
1a001bd2:	b083      	sub	sp, #12
1a001bd4:	4604      	mov	r4, r0
    volatile uint32_t tmp;

   /* Enable UART clocking. UART base clock(s) must already be enabled */
   Chip_Clock_EnableOpts(UART_PClock[Chip_UART_GetIndex(pUART)], true, true, 1);
1a001bd6:	f7ff ffe5 	bl	1a001ba4 <Chip_UART_GetIndex>
1a001bda:	2301      	movs	r3, #1
1a001bdc:	461a      	mov	r2, r3
1a001bde:	4619      	mov	r1, r3
1a001be0:	4d0e      	ldr	r5, [pc, #56]	; (1a001c1c <Chip_UART_Init+0x4c>)
1a001be2:	f835 0010 	ldrh.w	r0, [r5, r0, lsl #1]
1a001be6:	f7ff feaf 	bl	1a001948 <Chip_Clock_EnableOpts>
 *         with a RX trip level of 8 characters, use something like
 *         (UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2)
 */
STATIC INLINE void Chip_UART_SetupFIFOS(LPC_USART_T *pUART, uint32_t fcr)
{
   pUART->FCR = fcr;
1a001bea:	2307      	movs	r3, #7
1a001bec:	60a3      	str	r3, [r4, #8]
    pUART->TER2 = 0;
1a001bee:	2300      	movs	r3, #0
1a001bf0:	65e3      	str	r3, [r4, #92]	; 0x5c

    /* Disable Tx */
    Chip_UART_TXDisable(pUART);

    /* Disable interrupts */
   pUART->IER = 0;
1a001bf2:	6063      	str	r3, [r4, #4]
   /* Set LCR to default state */
   pUART->LCR = 0;
1a001bf4:	60e3      	str	r3, [r4, #12]
   /* Set ACR to default state */
   pUART->ACR = 0;
1a001bf6:	6223      	str	r3, [r4, #32]
    /* Set RS485 control to default state */
   pUART->RS485CTRL = 0;
1a001bf8:	64e3      	str	r3, [r4, #76]	; 0x4c
   /* Set RS485 delay timer to default state */
   pUART->RS485DLY = 0;
1a001bfa:	6563      	str	r3, [r4, #84]	; 0x54
   /* Set RS485 addr match to default state */
   pUART->RS485ADRMATCH = 0;
1a001bfc:	6523      	str	r3, [r4, #80]	; 0x50

    /* Clear MCR */
    if (pUART == LPC_UART1) {
1a001bfe:	4b08      	ldr	r3, [pc, #32]	; (1a001c20 <Chip_UART_Init+0x50>)
1a001c00:	429c      	cmp	r4, r3
1a001c02:	d005      	beq.n	1a001c10 <Chip_UART_Init+0x40>
 *         stop bit, and even (enabled) parity would be
 *         (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
   pUART->LCR = config;
1a001c04:	2303      	movs	r3, #3
1a001c06:	60e3      	str	r3, [r4, #12]

   /* Default 8N1, with DLAB disabled */
   Chip_UART_ConfigData(pUART, (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS));

   /* Disable fractional divider */
   pUART->FDR = 0x10;
1a001c08:	2310      	movs	r3, #16
1a001c0a:	62a3      	str	r3, [r4, #40]	; 0x28
}
1a001c0c:	b003      	add	sp, #12
1a001c0e:	bd30      	pop	{r4, r5, pc}
       pUART->MCR = 0;
1a001c10:	2300      	movs	r3, #0
1a001c12:	6123      	str	r3, [r4, #16]
       tmp = pUART->MSR;
1a001c14:	69a3      	ldr	r3, [r4, #24]
1a001c16:	9301      	str	r3, [sp, #4]
1a001c18:	e7f4      	b.n	1a001c04 <Chip_UART_Init+0x34>
1a001c1a:	bf00      	nop
1a001c1c:	1a002e00 	.word	0x1a002e00
1a001c20:	40082000 	.word	0x40082000

1a001c24 <Chip_UART_SetBaud>:
   return readBytes;
}

/* Determines and sets best dividers to get a target bit rate */
uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
{
1a001c24:	b538      	push	{r3, r4, r5, lr}
1a001c26:	4605      	mov	r5, r0
1a001c28:	460c      	mov	r4, r1
   uint32_t div, divh, divl, clkin;

   /* Determine UART clock in rate without FDR */
   clkin = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
1a001c2a:	f7ff ffbb 	bl	1a001ba4 <Chip_UART_GetIndex>
1a001c2e:	4b0c      	ldr	r3, [pc, #48]	; (1a001c60 <Chip_UART_SetBaud+0x3c>)
1a001c30:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1a001c34:	f7ff fea6 	bl	1a001984 <Chip_Clock_GetRate>
   div = clkin / (baudrate * 16);
1a001c38:	0123      	lsls	r3, r4, #4
1a001c3a:	fbb0 f3f3 	udiv	r3, r0, r3
1a001c3e:	b2d9      	uxtb	r1, r3
 * @param  pUART   : Pointer to selected UART peripheral
 * @return Nothing
 */
STATIC INLINE void Chip_UART_EnableDivisorAccess(LPC_USART_T *pUART)
{
   pUART->LCR |= UART_LCR_DLAB_EN;
1a001c40:	68ea      	ldr	r2, [r5, #12]
1a001c42:	f042 0280 	orr.w	r2, r2, #128	; 0x80
1a001c46:	60ea      	str	r2, [r5, #12]
 *         order to access the USART Divisor Latches. This function
 *         doesn't alter the DLAB state.
 */
STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
{
   pUART->DLL = (uint32_t) dll;
1a001c48:	6029      	str	r1, [r5, #0]
1a001c4a:	f3c3 2207 	ubfx	r2, r3, #8, #8
   pUART->DLM = (uint32_t) dlm;
1a001c4e:	606a      	str	r2, [r5, #4]
   pUART->LCR &= ~UART_LCR_DLAB_EN;
1a001c50:	68ea      	ldr	r2, [r5, #12]
1a001c52:	f022 0280 	bic.w	r2, r2, #128	; 0x80
1a001c56:	60ea      	str	r2, [r5, #12]
   Chip_UART_DisableDivisorAccess(pUART);

   /* Fractional FDR alreadt setup for 1 in UART init */

   return clkin / div;
}
1a001c58:	fbb0 f0f3 	udiv	r0, r0, r3
1a001c5c:	bd38      	pop	{r3, r4, r5, pc}
1a001c5e:	bf00      	nop
1a001c60:	1a002df8 	.word	0x1a002df8

1a001c64 <Chip_UART_SetBaudFDR>:
    Chip_UART_ABIntHandler(pUART);
}

/* Determines and sets best dividers to get a target baud rate */
uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud)
{
1a001c64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1a001c68:	b083      	sub	sp, #12
1a001c6a:	4683      	mov	fp, r0
1a001c6c:	4688      	mov	r8, r1
   uint32_t sdiv = 0, sm = 1, sd = 0;
   uint32_t pclk, m, d;
   uint32_t odiff = -1UL; /* old best diff */

   /* Get base clock for the corresponding UART */
   pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
1a001c6e:	f7ff ff99 	bl	1a001ba4 <Chip_UART_GetIndex>
1a001c72:	4b35      	ldr	r3, [pc, #212]	; (1a001d48 <Chip_UART_SetBaudFDR+0xe4>)
1a001c74:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1a001c78:	f7ff fe84 	bl	1a001984 <Chip_Clock_GetRate>
1a001c7c:	4606      	mov	r6, r0
   uint32_t odiff = -1UL; /* old best diff */
1a001c7e:	f04f 37ff 	mov.w	r7, #4294967295

   /* Loop through all possible fractional divider values */
   for (m = 1; odiff && m < 16; m++) {
1a001c82:	2401      	movs	r4, #1
   uint32_t sdiv = 0, sm = 1, sd = 0;
1a001c84:	2300      	movs	r3, #0
1a001c86:	9301      	str	r3, [sp, #4]
1a001c88:	46a2      	mov	sl, r4
1a001c8a:	4699      	mov	r9, r3
   for (m = 1; odiff && m < 16; m++) {
1a001c8c:	e02a      	b.n	1a001ce4 <Chip_UART_SetBaudFDR+0x80>
           /* Upper 32-bit of dval has div */
           div = (uint32_t) (dval >> 32);

           /* Closer to next div */
           if ((int)diff < 0) {
               diff = -diff;
1a001c8e:	4243      	negs	r3, r0
               div ++;
1a001c90:	1c4a      	adds	r2, r1, #1
1a001c92:	e017      	b.n	1a001cc4 <Chip_UART_SetBaudFDR+0x60>
           sd = d;
           sm = m;
           odiff = diff;

           /* On perfect match, break loop */
           if(!diff) {
1a001c94:	b30b      	cbz	r3, 1a001cda <Chip_UART_SetBaudFDR+0x76>
           odiff = diff;
1a001c96:	461f      	mov	r7, r3
           sd = d;
1a001c98:	9501      	str	r5, [sp, #4]
           sm = m;
1a001c9a:	46a2      	mov	sl, r4
           sdiv = div;
1a001c9c:	4691      	mov	r9, r2
       for (d = 0; d < m; d++) {
1a001c9e:	3501      	adds	r5, #1
1a001ca0:	42ac      	cmp	r4, r5
1a001ca2:	d91e      	bls.n	1a001ce2 <Chip_UART_SetBaudFDR+0x7e>
           uint64_t dval = (((uint64_t) pclk << 28) * m) / (baud * (m + d));
1a001ca4:	0933      	lsrs	r3, r6, #4
1a001ca6:	0730      	lsls	r0, r6, #28
1a001ca8:	fba4 0100 	umull	r0, r1, r4, r0
1a001cac:	fb04 1103 	mla	r1, r4, r3, r1
1a001cb0:	1962      	adds	r2, r4, r5
1a001cb2:	fb08 f202 	mul.w	r2, r8, r2
1a001cb6:	2300      	movs	r3, #0
1a001cb8:	f000 fc6a 	bl	1a002590 <__aeabi_uldivmod>
           diff = (uint32_t) dval;
1a001cbc:	4603      	mov	r3, r0
           div = (uint32_t) (dval >> 32);
1a001cbe:	460a      	mov	r2, r1
           if ((int)diff < 0) {
1a001cc0:	2800      	cmp	r0, #0
1a001cc2:	dbe4      	blt.n	1a001c8e <Chip_UART_SetBaudFDR+0x2a>
           if (odiff < diff || !div || (div >> 16) || (div < 3 && d)) {
1a001cc4:	429f      	cmp	r7, r3
1a001cc6:	d3ea      	bcc.n	1a001c9e <Chip_UART_SetBaudFDR+0x3a>
1a001cc8:	2a00      	cmp	r2, #0
1a001cca:	d0e8      	beq.n	1a001c9e <Chip_UART_SetBaudFDR+0x3a>
1a001ccc:	0c11      	lsrs	r1, r2, #16
1a001cce:	d1e6      	bne.n	1a001c9e <Chip_UART_SetBaudFDR+0x3a>
1a001cd0:	2a02      	cmp	r2, #2
1a001cd2:	d8df      	bhi.n	1a001c94 <Chip_UART_SetBaudFDR+0x30>
1a001cd4:	2d00      	cmp	r5, #0
1a001cd6:	d1e2      	bne.n	1a001c9e <Chip_UART_SetBaudFDR+0x3a>
1a001cd8:	e7dc      	b.n	1a001c94 <Chip_UART_SetBaudFDR+0x30>
           odiff = diff;
1a001cda:	461f      	mov	r7, r3
           sd = d;
1a001cdc:	9501      	str	r5, [sp, #4]
           sm = m;
1a001cde:	46a2      	mov	sl, r4
           sdiv = div;
1a001ce0:	4691      	mov	r9, r2
   for (m = 1; odiff && m < 16; m++) {
1a001ce2:	3401      	adds	r4, #1
1a001ce4:	b11f      	cbz	r7, 1a001cee <Chip_UART_SetBaudFDR+0x8a>
1a001ce6:	2c0f      	cmp	r4, #15
1a001ce8:	d801      	bhi.n	1a001cee <Chip_UART_SetBaudFDR+0x8a>
1a001cea:	2500      	movs	r5, #0
1a001cec:	e7d8      	b.n	1a001ca0 <Chip_UART_SetBaudFDR+0x3c>
           }
       }
   }

   /* Return 0 if a vaild divisor is not possible */
   if (!sdiv) {
1a001cee:	f1b9 0f00 	cmp.w	r9, #0
1a001cf2:	d024      	beq.n	1a001d3e <Chip_UART_SetBaudFDR+0xda>
   pUART->LCR |= UART_LCR_DLAB_EN;
1a001cf4:	f8db 300c 	ldr.w	r3, [fp, #12]
1a001cf8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1a001cfc:	f8cb 300c 	str.w	r3, [fp, #12]
1a001d00:	fa5f f389 	uxtb.w	r3, r9
   pUART->DLL = (uint32_t) dll;
1a001d04:	f8cb 3000 	str.w	r3, [fp]
1a001d08:	f3c9 2307 	ubfx	r3, r9, #8, #8
   pUART->DLM = (uint32_t) dlm;
1a001d0c:	f8cb 3004 	str.w	r3, [fp, #4]
   pUART->LCR &= ~UART_LCR_DLAB_EN;
1a001d10:	f8db 300c 	ldr.w	r3, [fp, #12]
1a001d14:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1a001d18:	f8cb 300c 	str.w	r3, [fp, #12]
   Chip_UART_EnableDivisorAccess(pUART);
   Chip_UART_SetDivisorLatches(pUART, UART_LOAD_DLL(sdiv), UART_LOAD_DLM(sdiv));
   Chip_UART_DisableDivisorAccess(pUART);

   /* Set best fractional divider */
   pUART->FDR = (UART_FDR_MULVAL(sm) | UART_FDR_DIVADDVAL(sd));
1a001d1c:	ea4f 130a 	mov.w	r3, sl, lsl #4
1a001d20:	b2db      	uxtb	r3, r3
1a001d22:	9901      	ldr	r1, [sp, #4]
1a001d24:	f001 020f 	and.w	r2, r1, #15
1a001d28:	4313      	orrs	r3, r2
1a001d2a:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28

   /* Return actual baud rate */
   return (pclk >> 4) * sm / (sdiv * (sm + sd));
1a001d2e:	0933      	lsrs	r3, r6, #4
1a001d30:	fb03 f30a 	mul.w	r3, r3, sl
1a001d34:	448a      	add	sl, r1
1a001d36:	fb0a f909 	mul.w	r9, sl, r9
1a001d3a:	fbb3 f9f9 	udiv	r9, r3, r9
}
1a001d3e:	4648      	mov	r0, r9
1a001d40:	b003      	add	sp, #12
1a001d42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1a001d46:	bf00      	nop
1a001d48:	1a002df8 	.word	0x1a002df8

1a001d4c <Board_LED_Init>:

static void Board_LED_Init()
{
   uint32_t idx;

   for (idx = 0; idx < (sizeof(gpioLEDBits) / sizeof(io_port_t)); ++idx) {
1a001d4c:	2200      	movs	r2, #0
1a001d4e:	2a05      	cmp	r2, #5
1a001d50:	d819      	bhi.n	1a001d86 <Board_LED_Init+0x3a>
{
1a001d52:	b470      	push	{r4, r5, r6}
       /* Set pin direction and init to off */
       Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, gpioLEDBits[idx].port, gpioLEDBits[idx].pin);
1a001d54:	490c      	ldr	r1, [pc, #48]	; (1a001d88 <Board_LED_Init+0x3c>)
1a001d56:	f811 5012 	ldrb.w	r5, [r1, r2, lsl #1]
1a001d5a:	eb01 0142 	add.w	r1, r1, r2, lsl #1
1a001d5e:	784c      	ldrb	r4, [r1, #1]
 * @param  pin     : GPIO pin to set direction on as output
 * @return Nothing
 */
STATIC INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
   pGPIO->DIR[port] |= 1UL << pin;
1a001d60:	4b0a      	ldr	r3, [pc, #40]	; (1a001d8c <Board_LED_Init+0x40>)
1a001d62:	f505 6600 	add.w	r6, r5, #2048	; 0x800
1a001d66:	f853 1026 	ldr.w	r1, [r3, r6, lsl #2]
1a001d6a:	2001      	movs	r0, #1
1a001d6c:	40a0      	lsls	r0, r4
1a001d6e:	4301      	orrs	r1, r0
1a001d70:	f843 1026 	str.w	r1, [r3, r6, lsl #2]
   pGPIO->B[port][pin] = setting;
1a001d74:	eb03 1345 	add.w	r3, r3, r5, lsl #5
1a001d78:	2100      	movs	r1, #0
1a001d7a:	5519      	strb	r1, [r3, r4]
   for (idx = 0; idx < (sizeof(gpioLEDBits) / sizeof(io_port_t)); ++idx) {
1a001d7c:	3201      	adds	r2, #1
1a001d7e:	2a05      	cmp	r2, #5
1a001d80:	d9e8      	bls.n	1a001d54 <Board_LED_Init+0x8>
       Chip_GPIO_SetPinState(LPC_GPIO_PORT, gpioLEDBits[idx].port, gpioLEDBits[idx].pin, (bool) false);
   }
}
1a001d82:	bc70      	pop	{r4, r5, r6}
1a001d84:	4770      	bx	lr
1a001d86:	4770      	bx	lr
1a001d88:	1a002e10 	.word	0x1a002e10
1a001d8c:	400f4000 	.word	0x400f4000

1a001d90 <Board_UART_Init>:
 * @note   Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
 * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
 */
STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
{
   LPC_SCU->SFSP[port][pin] = modefunc;
1a001d90:	4b03      	ldr	r3, [pc, #12]	; (1a001da0 <Board_UART_Init+0x10>)
1a001d92:	2212      	movs	r2, #18
1a001d94:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
1a001d98:	22d1      	movs	r2, #209	; 0xd1
1a001d9a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
1a001d9e:	4770      	bx	lr
1a001da0:	40086000 	.word	0x40086000

1a001da4 <Board_Debug_Init>:
{
1a001da4:	b510      	push	{r4, lr}
   Board_UART_Init(DEBUG_UART);
1a001da6:	4c08      	ldr	r4, [pc, #32]	; (1a001dc8 <Board_Debug_Init+0x24>)
1a001da8:	4620      	mov	r0, r4
1a001daa:	f7ff fff1 	bl	1a001d90 <Board_UART_Init>
   Chip_UART_Init(DEBUG_UART);
1a001dae:	4620      	mov	r0, r4
1a001db0:	f7ff ff0e 	bl	1a001bd0 <Chip_UART_Init>
   Chip_UART_SetBaudFDR(DEBUG_UART, 115200);
1a001db4:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
1a001db8:	4620      	mov	r0, r4
1a001dba:	f7ff ff53 	bl	1a001c64 <Chip_UART_SetBaudFDR>
   pUART->LCR = config;
1a001dbe:	2303      	movs	r3, #3
1a001dc0:	60e3      	str	r3, [r4, #12]
    pUART->TER2 = UART_TER2_TXEN;
1a001dc2:	2301      	movs	r3, #1
1a001dc4:	65e3      	str	r3, [r4, #92]	; 0x5c
1a001dc6:	bd10      	pop	{r4, pc}
1a001dc8:	400c1000 	.word	0x400c1000

1a001dcc <Board_Init>:
}

/* Set up and initialize all required blocks and functions related to the
   board hardware */
void Board_Init(void)
{
1a001dcc:	b508      	push	{r3, lr}
   /* Sets up DEBUG UART */
   DEBUGINIT();
1a001dce:	f7ff ffe9 	bl	1a001da4 <Board_Debug_Init>

   /* Initializes GPIO */
   Chip_GPIO_Init(LPC_GPIO_PORT);
1a001dd2:	4806      	ldr	r0, [pc, #24]	; (1a001dec <Board_Init+0x20>)
1a001dd4:	f7ff fe26 	bl	1a001a24 <Chip_GPIO_Init>

   /* Initialize LEDs */
   Board_LED_Init();
1a001dd8:	f7ff ffb8 	bl	1a001d4c <Board_LED_Init>
 * RMII PHY, and must be called before calling any Ethernet
 * functions.
 */
STATIC INLINE void Chip_ENET_RMIIEnable(LPC_ENET_T *pENET)
{
   LPC_CREG->CREG6 |= 0x4;
1a001ddc:	4a04      	ldr	r2, [pc, #16]	; (1a001df0 <Board_Init+0x24>)
1a001dde:	f8d2 312c 	ldr.w	r3, [r2, #300]	; 0x12c
1a001de2:	f043 0304 	orr.w	r3, r3, #4
1a001de6:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
1a001dea:	bd08      	pop	{r3, pc}
1a001dec:	400f4000 	.word	0x400f4000
1a001df0:	40043000 	.word	0x40043000

1a001df4 <Board_SetupMuxing>:
 * @return Nothing
 */
STATIC INLINE void Chip_SCU_SetPinMuxing(const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
{
   uint32_t ix;
   for (ix = 0; ix < arrayLength; ix++ ) {
1a001df4:	2300      	movs	r3, #0
1a001df6:	2b17      	cmp	r3, #23
1a001df8:	d812      	bhi.n	1a001e20 <Board_SetupMuxing+0x2c>
 * Public functions
 ****************************************************************************/

/* Sets up system pin muxing */
void Board_SetupMuxing(void)
{
1a001dfa:	b410      	push	{r4}
       Chip_SCU_PinMuxSet(pinArray[ix].pingrp, pinArray[ix].pinnum, pinArray[ix].modefunc);
1a001dfc:	4a09      	ldr	r2, [pc, #36]	; (1a001e24 <Board_SetupMuxing+0x30>)
1a001dfe:	eb02 0183 	add.w	r1, r2, r3, lsl #2
1a001e02:	f812 4023 	ldrb.w	r4, [r2, r3, lsl #2]
1a001e06:	784a      	ldrb	r2, [r1, #1]
1a001e08:	8848      	ldrh	r0, [r1, #2]
   LPC_SCU->SFSP[port][pin] = modefunc;
1a001e0a:	eb02 1244 	add.w	r2, r2, r4, lsl #5
1a001e0e:	4906      	ldr	r1, [pc, #24]	; (1a001e28 <Board_SetupMuxing+0x34>)
1a001e10:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
   for (ix = 0; ix < arrayLength; ix++ ) {
1a001e14:	3301      	adds	r3, #1
1a001e16:	2b17      	cmp	r3, #23
1a001e18:	d9f0      	bls.n	1a001dfc <Board_SetupMuxing+0x8>
   /* Setup system level pin muxing */
   Chip_SCU_SetPinMuxing(pinmuxing, sizeof(pinmuxing) / sizeof(PINMUX_GRP_T));
}
1a001e1a:	f85d 4b04 	ldr.w	r4, [sp], #4
1a001e1e:	4770      	bx	lr
1a001e20:	4770      	bx	lr
1a001e22:	bf00      	nop
1a001e24:	1a002e28 	.word	0x1a002e28
1a001e28:	40086000 	.word	0x40086000

1a001e2c <Board_SetupClocking>:

/* Set up and initialize clocking prior to call to main */
void Board_SetupClocking(void)
{
1a001e2c:	b510      	push	{r4, lr}
 */
STATIC INLINE void Chip_CREG_SetFlashAcceleration(uint32_t Hz)
{
   uint32_t FAValue = Hz / 21510000;

   LPC_CREG->FLASHCFGA = (LPC_CREG->FLASHCFGA & (~(0xF << 12))) | (FAValue << 12);
1a001e2e:	4a17      	ldr	r2, [pc, #92]	; (1a001e8c <Board_SetupClocking+0x60>)
1a001e30:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
1a001e34:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
1a001e38:	f443 4310 	orr.w	r3, r3, #36864	; 0x9000
1a001e3c:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
   LPC_CREG->FLASHCFGB = (LPC_CREG->FLASHCFGB & (~(0xF << 12))) | (FAValue << 12);
1a001e40:	f8d2 3124 	ldr.w	r3, [r2, #292]	; 0x124
1a001e44:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
1a001e48:	f443 4310 	orr.w	r3, r3, #36864	; 0x9000
1a001e4c:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124

   /* Enable Flash acceleration and setup wait states */
   Chip_CREG_SetFlashAcceleration(MAX_CLOCK_FREQ);

   /* Setup System core frequency to MAX_CLOCK_FREQ */
   Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);
1a001e50:	2201      	movs	r2, #1
1a001e52:	490f      	ldr	r1, [pc, #60]	; (1a001e90 <Board_SetupClocking+0x64>)
1a001e54:	2006      	movs	r0, #6
1a001e56:	f7ff fdf9 	bl	1a001a4c <Chip_SetupCoreClock>

   /* Setup system base clocks and initial states. This won't enable and
      disable individual clocks, but sets up the base clock sources for
      each individual peripheral clock. */
   for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a001e5a:	2400      	movs	r4, #0
1a001e5c:	e00a      	b.n	1a001e74 <Board_SetupClocking+0x48>
       Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
1a001e5e:	480d      	ldr	r0, [pc, #52]	; (1a001e94 <Board_SetupClocking+0x68>)
1a001e60:	eb00 0184 	add.w	r1, r0, r4, lsl #2
1a001e64:	78cb      	ldrb	r3, [r1, #3]
1a001e66:	788a      	ldrb	r2, [r1, #2]
1a001e68:	7849      	ldrb	r1, [r1, #1]
1a001e6a:	f810 0024 	ldrb.w	r0, [r0, r4, lsl #2]
1a001e6e:	f7ff fd25 	bl	1a0018bc <Chip_Clock_SetBaseClock>
   for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a001e72:	3401      	adds	r4, #1
1a001e74:	2c02      	cmp	r4, #2
1a001e76:	d9f2      	bls.n	1a001e5e <Board_SetupClocking+0x32>
                               InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
   }

   /* Reset and enable 32Khz oscillator */
   LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));
1a001e78:	4b04      	ldr	r3, [pc, #16]	; (1a001e8c <Board_SetupClocking+0x60>)
1a001e7a:	685a      	ldr	r2, [r3, #4]
1a001e7c:	f022 020c 	bic.w	r2, r2, #12
1a001e80:	605a      	str	r2, [r3, #4]
   LPC_CREG->CREG0 |= (1 << 1) | (1 << 0);
1a001e82:	685a      	ldr	r2, [r3, #4]
1a001e84:	f042 0203 	orr.w	r2, r2, #3
1a001e88:	605a      	str	r2, [r3, #4]
1a001e8a:	bd10      	pop	{r4, pc}
1a001e8c:	40043000 	.word	0x40043000
1a001e90:	0c28cb00 	.word	0x0c28cb00
1a001e94:	1a002e1c 	.word	0x1a002e1c

1a001e98 <Board_SystemInit>:
}

/* Set up and initialize hardware prior to call to main */
void Board_SystemInit(void)
{
1a001e98:	b508      	push	{r3, lr}
   /* Setup system clocking and memory. This is done early to allow the
      application and tools to clear memory and use scatter loading to
      external memory. */
   Board_SetupMuxing();
1a001e9a:	f7ff ffab 	bl	1a001df4 <Board_SetupMuxing>
   Board_SetupClocking();
1a001e9e:	f7ff ffc5 	bl	1a001e2c <Board_SetupClocking>
1a001ea2:	bd08      	pop	{r3, pc}

1a001ea4 <ResetISR>:
void ResetISR(void) {
1a001ea4:	b510      	push	{r4, lr}
    __asm volatile ("cpsid i");
1a001ea6:	b672      	cpsid	i
    *(RESET_CONTROL + 0) = 0x10DF1000;
1a001ea8:	4a16      	ldr	r2, [pc, #88]	; (1a001f04 <ResetISR+0x60>)
1a001eaa:	4b17      	ldr	r3, [pc, #92]	; (1a001f08 <ResetISR+0x64>)
1a001eac:	601a      	str	r2, [r3, #0]
    *(RESET_CONTROL + 1) = 0x01DFF7FF;
1a001eae:	4a17      	ldr	r2, [pc, #92]	; (1a001f0c <ResetISR+0x68>)
1a001eb0:	3304      	adds	r3, #4
1a001eb2:	601a      	str	r2, [r3, #0]
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
1a001eb4:	2300      	movs	r3, #0
1a001eb6:	e005      	b.n	1a001ec4 <ResetISR+0x20>
        *(NVIC_ICPR + irqpendloop) = 0xFFFFFFFF;
1a001eb8:	f04f 31ff 	mov.w	r1, #4294967295
1a001ebc:	4a14      	ldr	r2, [pc, #80]	; (1a001f10 <ResetISR+0x6c>)
1a001ebe:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
1a001ec2:	3301      	adds	r3, #1
1a001ec4:	2b07      	cmp	r3, #7
1a001ec6:	d9f7      	bls.n	1a001eb8 <ResetISR+0x14>
    __asm volatile ("cpsie i");
1a001ec8:	b662      	cpsie	i
    SystemInit();
1a001eca:	f000 f829 	bl	1a001f20 <SystemInit>
    SectionTableAddr = &__data_section_table;
1a001ece:	4b11      	ldr	r3, [pc, #68]	; (1a001f14 <ResetISR+0x70>)
    while (SectionTableAddr < &__data_section_table_end) {
1a001ed0:	e007      	b.n	1a001ee2 <ResetISR+0x3e>
        SectionLen = *SectionTableAddr++;
1a001ed2:	f103 040c 	add.w	r4, r3, #12
        data_init(LoadAddr, ExeAddr, SectionLen);
1a001ed6:	689a      	ldr	r2, [r3, #8]
1a001ed8:	6859      	ldr	r1, [r3, #4]
1a001eda:	6818      	ldr	r0, [r3, #0]
1a001edc:	f7fe f956 	bl	1a00018c <data_init>
        SectionLen = *SectionTableAddr++;
1a001ee0:	4623      	mov	r3, r4
    while (SectionTableAddr < &__data_section_table_end) {
1a001ee2:	4a0d      	ldr	r2, [pc, #52]	; (1a001f18 <ResetISR+0x74>)
1a001ee4:	4293      	cmp	r3, r2
1a001ee6:	d3f4      	bcc.n	1a001ed2 <ResetISR+0x2e>
1a001ee8:	e006      	b.n	1a001ef8 <ResetISR+0x54>
        ExeAddr = *SectionTableAddr++;
1a001eea:	461c      	mov	r4, r3
        bss_init(ExeAddr, SectionLen);
1a001eec:	6859      	ldr	r1, [r3, #4]
1a001eee:	f854 0b08 	ldr.w	r0, [r4], #8
1a001ef2:	f7fe f95a 	bl	1a0001aa <bss_init>
        SectionLen = *SectionTableAddr++;
1a001ef6:	4623      	mov	r3, r4
    while (SectionTableAddr < &__bss_section_table_end) {
1a001ef8:	4a08      	ldr	r2, [pc, #32]	; (1a001f1c <ResetISR+0x78>)
1a001efa:	4293      	cmp	r3, r2
1a001efc:	d3f5      	bcc.n	1a001eea <ResetISR+0x46>
    main();
1a001efe:	f7fe fa05 	bl	1a00030c <main>
1a001f02:	e7fe      	b.n	1a001f02 <ResetISR+0x5e>
1a001f04:	10df1000 	.word	0x10df1000
1a001f08:	40053100 	.word	0x40053100
1a001f0c:	01dff7ff 	.word	0x01dff7ff
1a001f10:	e000e280 	.word	0xe000e280
1a001f14:	1a000114 	.word	0x1a000114
1a001f18:	1a000150 	.word	0x1a000150
1a001f1c:	1a000178 	.word	0x1a000178

1a001f20 <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
1a001f20:	b508      	push	{r3, lr}

   *pSCB_VTOR = (unsigned int) &__Vectors;
#endif

#if defined(__FPU_PRESENT) && __FPU_PRESENT == 1
   fpuInit();
1a001f22:	f7ff fd55 	bl	1a0019d0 <fpuInit>
#if defined(NO_BOARD_LIB)
   /* Chip specific SystemInit */
   Chip_SystemInit();
#else
   /* Board specific SystemInit */
   Board_SystemInit();
1a001f26:	f7ff ffb7 	bl	1a001e98 <Board_SystemInit>
1a001f2a:	bd08      	pop	{r3, pc}

1a001f2c <boardConfig>:
/*==================[internal functions definition]==========================*/

/*==================[external functions definition]==========================*/

/* Set up and initialize board hardware */
void boardConfig(void) {
1a001f2c:	b508      	push	{r3, lr}

   /* Read clock settings and update SystemCoreClock variable */
   SystemCoreClockUpdate();
1a001f2e:	f7ff fa9f 	bl	1a001470 <SystemCoreClockUpdate>

   Board_Init(); // From Board module (modules/lpc4337_m4/board)
1a001f32:	f7ff ff4b 	bl	1a001dcc <Board_Init>

   /* Inicializar el conteo de Ticks con resoluciÃ³n de 1ms, sin tickHook */
   tickConfig( 1, 0 );
1a001f36:	2200      	movs	r2, #0
1a001f38:	2001      	movs	r0, #1
1a001f3a:	2100      	movs	r1, #0
1a001f3c:	f000 f9d4 	bl	1a0022e8 <tickConfig>

   /* Inicializar GPIOs */
   gpioConfig( 0, GPIO_ENABLE );
1a001f40:	2105      	movs	r1, #5
1a001f42:	2000      	movs	r0, #0
1a001f44:	f000 f8b6 	bl	1a0020b4 <gpioConfig>

   /* ConfiguraciÃ³n de pines de entrada para Teclas de la EDU-CIAA-NXP */
   gpioConfig( TEC1, GPIO_INPUT );
1a001f48:	2100      	movs	r1, #0
1a001f4a:	2024      	movs	r0, #36	; 0x24
1a001f4c:	f000 f8b2 	bl	1a0020b4 <gpioConfig>
   gpioConfig( TEC2, GPIO_INPUT );
1a001f50:	2100      	movs	r1, #0
1a001f52:	2025      	movs	r0, #37	; 0x25
1a001f54:	f000 f8ae 	bl	1a0020b4 <gpioConfig>
   gpioConfig( TEC3, GPIO_INPUT );
1a001f58:	2100      	movs	r1, #0
1a001f5a:	2026      	movs	r0, #38	; 0x26
1a001f5c:	f000 f8aa 	bl	1a0020b4 <gpioConfig>
   gpioConfig( TEC4, GPIO_INPUT );
1a001f60:	2100      	movs	r1, #0
1a001f62:	2027      	movs	r0, #39	; 0x27
1a001f64:	f000 f8a6 	bl	1a0020b4 <gpioConfig>

   /* ConfiguraciÃ³n de pines de salida para Leds de la EDU-CIAA-NXP */
   gpioConfig( LEDR, GPIO_OUTPUT );
1a001f68:	2101      	movs	r1, #1
1a001f6a:	2028      	movs	r0, #40	; 0x28
1a001f6c:	f000 f8a2 	bl	1a0020b4 <gpioConfig>
   gpioConfig( LEDG, GPIO_OUTPUT );
1a001f70:	2101      	movs	r1, #1
1a001f72:	2029      	movs	r0, #41	; 0x29
1a001f74:	f000 f89e 	bl	1a0020b4 <gpioConfig>
   gpioConfig( LEDB, GPIO_OUTPUT );
1a001f78:	2101      	movs	r1, #1
1a001f7a:	202a      	movs	r0, #42	; 0x2a
1a001f7c:	f000 f89a 	bl	1a0020b4 <gpioConfig>
   gpioConfig( LED1, GPIO_OUTPUT );
1a001f80:	2101      	movs	r1, #1
1a001f82:	202b      	movs	r0, #43	; 0x2b
1a001f84:	f000 f896 	bl	1a0020b4 <gpioConfig>
   gpioConfig( LED2, GPIO_OUTPUT );
1a001f88:	2101      	movs	r1, #1
1a001f8a:	202c      	movs	r0, #44	; 0x2c
1a001f8c:	f000 f892 	bl	1a0020b4 <gpioConfig>
   gpioConfig( LED3, GPIO_OUTPUT );
1a001f90:	2101      	movs	r1, #1
1a001f92:	202d      	movs	r0, #45	; 0x2d
1a001f94:	f000 f88e 	bl	1a0020b4 <gpioConfig>


   /* ConfiguraciÃ³n de pines de entrada de la CIAA-NXP */
   gpioConfig( DI0, GPIO_INPUT );
1a001f98:	2100      	movs	r1, #0
1a001f9a:	202e      	movs	r0, #46	; 0x2e
1a001f9c:	f000 f88a 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DI1, GPIO_INPUT );
1a001fa0:	2100      	movs	r1, #0
1a001fa2:	202f      	movs	r0, #47	; 0x2f
1a001fa4:	f000 f886 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DI2, GPIO_INPUT );
1a001fa8:	2100      	movs	r1, #0
1a001faa:	2030      	movs	r0, #48	; 0x30
1a001fac:	f000 f882 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DI3, GPIO_INPUT );
1a001fb0:	2100      	movs	r1, #0
1a001fb2:	2031      	movs	r0, #49	; 0x31
1a001fb4:	f000 f87e 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DI4, GPIO_INPUT );
1a001fb8:	2100      	movs	r1, #0
1a001fba:	2032      	movs	r0, #50	; 0x32
1a001fbc:	f000 f87a 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DI5, GPIO_INPUT );
1a001fc0:	2100      	movs	r1, #0
1a001fc2:	2033      	movs	r0, #51	; 0x33
1a001fc4:	f000 f876 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DI6, GPIO_INPUT );
1a001fc8:	2100      	movs	r1, #0
1a001fca:	2034      	movs	r0, #52	; 0x34
1a001fcc:	f000 f872 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DI7, GPIO_INPUT );
1a001fd0:	2100      	movs	r1, #0
1a001fd2:	2035      	movs	r0, #53	; 0x35
1a001fd4:	f000 f86e 	bl	1a0020b4 <gpioConfig>

   /* ConfiguraciÃ³n de pines de salida de la CIAA-NXP */
   gpioConfig( DO0, GPIO_OUTPUT );
1a001fd8:	2101      	movs	r1, #1
1a001fda:	2036      	movs	r0, #54	; 0x36
1a001fdc:	f000 f86a 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DO1, GPIO_OUTPUT );
1a001fe0:	2101      	movs	r1, #1
1a001fe2:	2037      	movs	r0, #55	; 0x37
1a001fe4:	f000 f866 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DO2, GPIO_OUTPUT );
1a001fe8:	2101      	movs	r1, #1
1a001fea:	2038      	movs	r0, #56	; 0x38
1a001fec:	f000 f862 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DO3, GPIO_OUTPUT );
1a001ff0:	2101      	movs	r1, #1
1a001ff2:	2039      	movs	r0, #57	; 0x39
1a001ff4:	f000 f85e 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DO4, GPIO_OUTPUT );
1a001ff8:	2101      	movs	r1, #1
1a001ffa:	203a      	movs	r0, #58	; 0x3a
1a001ffc:	f000 f85a 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DO5, GPIO_OUTPUT );
1a002000:	2101      	movs	r1, #1
1a002002:	203b      	movs	r0, #59	; 0x3b
1a002004:	f000 f856 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DO6, GPIO_OUTPUT );
1a002008:	2101      	movs	r1, #1
1a00200a:	203c      	movs	r0, #60	; 0x3c
1a00200c:	f000 f852 	bl	1a0020b4 <gpioConfig>
   gpioConfig( DO7, GPIO_OUTPUT );
1a002010:	2101      	movs	r1, #1
1a002012:	203d      	movs	r0, #61	; 0x3d
1a002014:	f000 f84e 	bl	1a0020b4 <gpioConfig>
1a002018:	bd08      	pop	{r3, pc}

1a00201a <sAPI_NullFuncPtr>:
 * param:  void * - Not used
 * return: bool_t - Return always true
 */
bool_t sAPI_NullFuncPtr(void *ptr){
   return 1;
}
1a00201a:	2001      	movs	r0, #1
1a00201c:	4770      	bx	lr
1a00201e:	Address 0x1a00201e is out of bounds.


1a002020 <delayConfig>:
 }


/* ---- Non Blocking Delay ---- */

void delayConfig( delay_t * delay, tick_t duration ){
1a002020:	b510      	push	{r4, lr}
1a002022:	4604      	mov	r4, r0
1a002024:	4610      	mov	r0, r2
1a002026:	4619      	mov	r1, r3
   delay->duration = duration/tickRateMS;
1a002028:	4b04      	ldr	r3, [pc, #16]	; (1a00203c <delayConfig+0x1c>)
1a00202a:	e9d3 2300 	ldrd	r2, r3, [r3]
1a00202e:	f000 faaf 	bl	1a002590 <__aeabi_uldivmod>
1a002032:	e9c4 0102 	strd	r0, r1, [r4, #8]
   delay->running = 0;
1a002036:	2300      	movs	r3, #0
1a002038:	7423      	strb	r3, [r4, #16]
1a00203a:	bd10      	pop	{r4, pc}
1a00203c:	10000190 	.word	0x10000190

1a002040 <delayRead>:
}

bool_t delayRead( delay_t * delay ){
1a002040:	b538      	push	{r3, r4, r5, lr}
1a002042:	4604      	mov	r4, r0

   bool_t timeArrived = 0;

   if( !delay->running ){
1a002044:	7c05      	ldrb	r5, [r0, #16]
1a002046:	b185      	cbz	r5, 1a00206a <delayRead+0x2a>
      delay->startTime = tickRead();
      delay->running = 1;
   }
   else{
      if ( (tickRead() - delay->startTime) >= delay->duration ){
1a002048:	f000 f98a 	bl	1a002360 <tickRead>
1a00204c:	e9d4 2300 	ldrd	r2, r3, [r4]
1a002050:	1a80      	subs	r0, r0, r2
1a002052:	eb61 0103 	sbc.w	r1, r1, r3
1a002056:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
1a00205a:	4299      	cmp	r1, r3
1a00205c:	bf08      	it	eq
1a00205e:	4290      	cmpeq	r0, r2
1a002060:	d30b      	bcc.n	1a00207a <delayRead+0x3a>
         timeArrived = 1;
         delay->running = 0;
1a002062:	2300      	movs	r3, #0
1a002064:	7423      	strb	r3, [r4, #16]
         timeArrived = 1;
1a002066:	2501      	movs	r5, #1
1a002068:	e005      	b.n	1a002076 <delayRead+0x36>
      delay->startTime = tickRead();
1a00206a:	f000 f979 	bl	1a002360 <tickRead>
1a00206e:	e9c4 0100 	strd	r0, r1, [r4]
      delay->running = 1;
1a002072:	2301      	movs	r3, #1
1a002074:	7423      	strb	r3, [r4, #16]
      }
   }

   return timeArrived;
}
1a002076:	4628      	mov	r0, r5
1a002078:	bd38      	pop	{r3, r4, r5, pc}
   bool_t timeArrived = 0;
1a00207a:	2500      	movs	r5, #0
1a00207c:	e7fb      	b.n	1a002076 <delayRead+0x36>
1a00207e:	Address 0x1a00207e is out of bounds.


1a002080 <gpioObtainPinConfig>:
/*==================[internal functions definition]==========================*/

static void gpioObtainPinConfig( gpioMap_t pin,
                                int8_t *pinNamePort, int8_t *pinNamePin,
																int8_t *func, int8_t *gpioPort,
																int8_t *gpioPin ){
1a002080:	b430      	push	{r4, r5}

   *pinNamePort = gpioPinsConfig[pin].pinName.port;
1a002082:	4d0b      	ldr	r5, [pc, #44]	; (1a0020b0 <gpioObtainPinConfig+0x30>)
1a002084:	eb00 0080 	add.w	r0, r0, r0, lsl #2
1a002088:	182c      	adds	r4, r5, r0
1a00208a:	5628      	ldrsb	r0, [r5, r0]
1a00208c:	7008      	strb	r0, [r1, #0]
   *pinNamePin  = gpioPinsConfig[pin].pinName.pin;
1a00208e:	f994 1001 	ldrsb.w	r1, [r4, #1]
1a002092:	7011      	strb	r1, [r2, #0]
   *func        = gpioPinsConfig[pin].func;
1a002094:	f994 2002 	ldrsb.w	r2, [r4, #2]
1a002098:	701a      	strb	r2, [r3, #0]
   *gpioPort    = gpioPinsConfig[pin].gpio.port;
1a00209a:	f994 2003 	ldrsb.w	r2, [r4, #3]
1a00209e:	9b02      	ldr	r3, [sp, #8]
1a0020a0:	701a      	strb	r2, [r3, #0]
   *gpioPin     = gpioPinsConfig[pin].gpio.pin;
1a0020a2:	f994 2004 	ldrsb.w	r2, [r4, #4]
1a0020a6:	9b03      	ldr	r3, [sp, #12]
1a0020a8:	701a      	strb	r2, [r3, #0]
}
1a0020aa:	bc30      	pop	{r4, r5}
1a0020ac:	4770      	bx	lr
1a0020ae:	bf00      	nop
1a0020b0:	1a002e88 	.word	0x1a002e88

1a0020b4 <gpioConfig>:

/*==================[external functions definition]==========================*/

bool_t gpioConfig( gpioMap_t pin, gpioConfig_t config ){
1a0020b4:	b530      	push	{r4, r5, lr}
1a0020b6:	b085      	sub	sp, #20
1a0020b8:	460c      	mov	r4, r1

   bool_t ret_val     = 1;

   int8_t pinNamePort = 0;
1a0020ba:	2300      	movs	r3, #0
1a0020bc:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a0020c0:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a0020c4:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a0020c8:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a0020cc:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a0020d0:	f10d 030b 	add.w	r3, sp, #11
1a0020d4:	9301      	str	r3, [sp, #4]
1a0020d6:	ab03      	add	r3, sp, #12
1a0020d8:	9300      	str	r3, [sp, #0]
1a0020da:	f10d 030d 	add.w	r3, sp, #13
1a0020de:	f10d 020e 	add.w	r2, sp, #14
1a0020e2:	f10d 010f 	add.w	r1, sp, #15
1a0020e6:	f7ff ffcb 	bl	1a002080 <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   switch(config){
1a0020ea:	2c05      	cmp	r4, #5
1a0020ec:	f200 8096 	bhi.w	1a00221c <gpioConfig+0x168>
1a0020f0:	e8df f004 	tbb	[pc, r4]
1a0020f4:	3d237109 	.word	0x3d237109
1a0020f8:	0357      	.short	0x0357

      case GPIO_ENABLE:
		   /* Initializes GPIO */
		   Chip_GPIO_Init(LPC_GPIO_PORT);
1a0020fa:	4849      	ldr	r0, [pc, #292]	; (1a002220 <gpioConfig+0x16c>)
1a0020fc:	f7ff fc92 	bl	1a001a24 <Chip_GPIO_Init>
   bool_t ret_val     = 1;
1a002100:	2001      	movs	r0, #1
      break;
   }

   return ret_val;

}
1a002102:	b005      	add	sp, #20
1a002104:	bd30      	pop	{r4, r5, pc}
         Chip_SCU_PinMux(
1a002106:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a00210a:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a00210e:	f89d 200d 	ldrb.w	r2, [sp, #13]
   LPC_SCU->SFSP[port][pin] = modefunc;
1a002112:	f042 02d0 	orr.w	r2, r2, #208	; 0xd0
1a002116:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a00211a:	4942      	ldr	r1, [pc, #264]	; (1a002224 <gpioConfig+0x170>)
1a00211c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a002120:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a002124:	2401      	movs	r4, #1
1a002126:	2300      	movs	r3, #0
1a002128:	fa04 f202 	lsl.w	r2, r4, r2
1a00212c:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a002130:	483b      	ldr	r0, [pc, #236]	; (1a002220 <gpioConfig+0x16c>)
1a002132:	f7ff fc78 	bl	1a001a26 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a002136:	4620      	mov	r0, r4
      break;
1a002138:	e7e3      	b.n	1a002102 <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a00213a:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a00213e:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a002142:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a002146:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
1a00214a:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a00214e:	4935      	ldr	r1, [pc, #212]	; (1a002224 <gpioConfig+0x170>)
1a002150:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a002154:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a002158:	2401      	movs	r4, #1
1a00215a:	2300      	movs	r3, #0
1a00215c:	fa04 f202 	lsl.w	r2, r4, r2
1a002160:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a002164:	482e      	ldr	r0, [pc, #184]	; (1a002220 <gpioConfig+0x16c>)
1a002166:	f7ff fc5e 	bl	1a001a26 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a00216a:	4620      	mov	r0, r4
      break;
1a00216c:	e7c9      	b.n	1a002102 <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a00216e:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a002172:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a002176:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a00217a:	f042 02d8 	orr.w	r2, r2, #216	; 0xd8
1a00217e:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a002182:	4928      	ldr	r1, [pc, #160]	; (1a002224 <gpioConfig+0x170>)
1a002184:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a002188:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a00218c:	2401      	movs	r4, #1
1a00218e:	2300      	movs	r3, #0
1a002190:	fa04 f202 	lsl.w	r2, r4, r2
1a002194:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a002198:	4821      	ldr	r0, [pc, #132]	; (1a002220 <gpioConfig+0x16c>)
1a00219a:	f7ff fc44 	bl	1a001a26 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a00219e:	4620      	mov	r0, r4
      break;
1a0021a0:	e7af      	b.n	1a002102 <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a0021a2:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a0021a6:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a0021aa:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a0021ae:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
1a0021b2:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a0021b6:	491b      	ldr	r1, [pc, #108]	; (1a002224 <gpioConfig+0x170>)
1a0021b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a0021bc:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a0021c0:	2401      	movs	r4, #1
1a0021c2:	2300      	movs	r3, #0
1a0021c4:	fa04 f202 	lsl.w	r2, r4, r2
1a0021c8:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a0021cc:	4814      	ldr	r0, [pc, #80]	; (1a002220 <gpioConfig+0x16c>)
1a0021ce:	f7ff fc2a 	bl	1a001a26 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a0021d2:	4620      	mov	r0, r4
      break;
1a0021d4:	e795      	b.n	1a002102 <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a0021d6:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a0021da:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a0021de:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a0021e2:	f042 02d0 	orr.w	r2, r2, #208	; 0xd0
1a0021e6:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a0021ea:	490e      	ldr	r1, [pc, #56]	; (1a002224 <gpioConfig+0x170>)
1a0021ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_OUTPUT );
1a0021f0:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a0021f4:	2401      	movs	r4, #1
1a0021f6:	4d0a      	ldr	r5, [pc, #40]	; (1a002220 <gpioConfig+0x16c>)
1a0021f8:	4623      	mov	r3, r4
1a0021fa:	fa04 f202 	lsl.w	r2, r4, r2
1a0021fe:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a002202:	4628      	mov	r0, r5
1a002204:	f7ff fc0f 	bl	1a001a26 <Chip_GPIO_SetDir>
         Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, 0);
1a002208:	f89d 200c 	ldrb.w	r2, [sp, #12]
1a00220c:	f89d 300b 	ldrb.w	r3, [sp, #11]
1a002210:	eb05 1542 	add.w	r5, r5, r2, lsl #5
1a002214:	2200      	movs	r2, #0
1a002216:	54ea      	strb	r2, [r5, r3]
   bool_t ret_val     = 1;
1a002218:	4620      	mov	r0, r4
1a00221a:	e772      	b.n	1a002102 <gpioConfig+0x4e>
         ret_val = 0;
1a00221c:	2000      	movs	r0, #0
1a00221e:	e770      	b.n	1a002102 <gpioConfig+0x4e>
1a002220:	400f4000 	.word	0x400f4000
1a002224:	40086000 	.word	0x40086000

1a002228 <gpioWrite>:


bool_t gpioWrite( gpioMap_t pin, bool_t value ){
1a002228:	b510      	push	{r4, lr}
1a00222a:	b084      	sub	sp, #16
1a00222c:	460c      	mov	r4, r1

   bool_t ret_val     = 1;

   int8_t pinNamePort = 0;
1a00222e:	2300      	movs	r3, #0
1a002230:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a002234:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a002238:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a00223c:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a002240:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a002244:	f10d 030b 	add.w	r3, sp, #11
1a002248:	9301      	str	r3, [sp, #4]
1a00224a:	ab03      	add	r3, sp, #12
1a00224c:	9300      	str	r3, [sp, #0]
1a00224e:	f10d 030d 	add.w	r3, sp, #13
1a002252:	f10d 020e 	add.w	r2, sp, #14
1a002256:	f10d 010f 	add.w	r1, sp, #15
1a00225a:	f7ff ff11 	bl	1a002080 <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, value);
1a00225e:	f89d 300c 	ldrb.w	r3, [sp, #12]
1a002262:	f89d 200b 	ldrb.w	r2, [sp, #11]
1a002266:	3400      	adds	r4, #0
1a002268:	bf18      	it	ne
1a00226a:	2401      	movne	r4, #1
1a00226c:	015b      	lsls	r3, r3, #5
1a00226e:	f103 2340 	add.w	r3, r3, #1073758208	; 0x40004000
1a002272:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
1a002276:	549c      	strb	r4, [r3, r2]

   return ret_val;
}
1a002278:	2001      	movs	r0, #1
1a00227a:	b004      	add	sp, #16
1a00227c:	bd10      	pop	{r4, pc}

1a00227e <gpioRead>:

   return gpioWrite( pin, !gpioRead(pin) );
}


bool_t gpioRead( gpioMap_t pin ){
1a00227e:	b500      	push	{lr}
1a002280:	b085      	sub	sp, #20

   bool_t ret_val     = OFF;

   int8_t pinNamePort = 0;
1a002282:	2300      	movs	r3, #0
1a002284:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a002288:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a00228c:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a002290:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a002294:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a002298:	f10d 030b 	add.w	r3, sp, #11
1a00229c:	9301      	str	r3, [sp, #4]
1a00229e:	ab03      	add	r3, sp, #12
1a0022a0:	9300      	str	r3, [sp, #0]
1a0022a2:	f10d 030d 	add.w	r3, sp, #13
1a0022a6:	f10d 020e 	add.w	r2, sp, #14
1a0022aa:	f10d 010f 	add.w	r1, sp, #15
1a0022ae:	f7ff fee7 	bl	1a002080 <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   ret_val = (bool_t) Chip_GPIO_ReadPortBit( LPC_GPIO_PORT, gpioPort, gpioPin );
1a0022b2:	f99d 300c 	ldrsb.w	r3, [sp, #12]
1a0022b6:	f89d 200b 	ldrb.w	r2, [sp, #11]
   return (bool) pGPIO->B[port][pin];
1a0022ba:	015b      	lsls	r3, r3, #5
1a0022bc:	f103 2340 	add.w	r3, r3, #1073758208	; 0x40004000
1a0022c0:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
1a0022c4:	5c98      	ldrb	r0, [r3, r2]

   return ret_val;
}
1a0022c6:	3000      	adds	r0, #0
1a0022c8:	bf18      	it	ne
1a0022ca:	2001      	movne	r0, #1
1a0022cc:	b005      	add	sp, #20
1a0022ce:	f85d fb04 	ldr.w	pc, [sp], #4

1a0022d2 <gpioToggle>:
bool_t gpioToggle( gpioMap_t pin ){
1a0022d2:	b510      	push	{r4, lr}
1a0022d4:	4604      	mov	r4, r0
   return gpioWrite( pin, !gpioRead(pin) );
1a0022d6:	f7ff ffd2 	bl	1a00227e <gpioRead>
1a0022da:	fab0 f180 	clz	r1, r0
1a0022de:	0949      	lsrs	r1, r1, #5
1a0022e0:	4620      	mov	r0, r4
1a0022e2:	f7ff ffa1 	bl	1a002228 <gpioWrite>
}
1a0022e6:	bd10      	pop	{r4, pc}

1a0022e8 <tickConfig>:
/*==================[internal functions definition]==========================*/

/*==================[external functions definition]==========================*/

/* Tick rate configuration 1 to 50 ms */
bool_t tickConfig(tick_t tickRateMSvalue, sAPI_FuncPtr_t tickHook ) {
1a0022e8:	b508      	push	{r3, lr}

   bool_t ret_val = 1;
   tick_t tickRateHz = 0;

   if( tickHook ){
1a0022ea:	b112      	cbz	r2, 1a0022f2 <tickConfig+0xa>
1a0022ec:	4613      	mov	r3, r2
      tickHookFunction = tickHook;
1a0022ee:	4a17      	ldr	r2, [pc, #92]	; (1a00234c <tickConfig+0x64>)
1a0022f0:	6013      	str	r3, [r2, #0]
   }

   if( (tickRateMSvalue >= 1) && (tickRateMSvalue <= 50) ){
1a0022f2:	f110 32ff 	adds.w	r2, r0, #4294967295
1a0022f6:	f141 33ff 	adc.w	r3, r1, #4294967295
1a0022fa:	2b00      	cmp	r3, #0
1a0022fc:	bf08      	it	eq
1a0022fe:	2a32      	cmpeq	r2, #50	; 0x32
1a002300:	d220      	bcs.n	1a002344 <tickConfig+0x5c>
1a002302:	4602      	mov	r2, r0
1a002304:	460b      	mov	r3, r1

		tickRateMS = tickRateMSvalue;
1a002306:	4912      	ldr	r1, [pc, #72]	; (1a002350 <tickConfig+0x68>)
1a002308:	e9c1 2300 	strd	r2, r3, [r1]
      tickRateHz = 1000 => 1000 ticks per second =>  1 ms tick
      tickRateHz =  200 =>  200 ticks per second =>  5 ms tick
      tickRateHz =  100 =>  100 ticks per second => 10 ms tick
      tickRateHz =   20 =>   20 ticks per second => 50 ms tick
      */
      tickRateHz = 1000 / tickRateMSvalue;
1a00230c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
1a002310:	2100      	movs	r1, #0
1a002312:	f000 f93d 	bl	1a002590 <__aeabi_uldivmod>

      /* Init SysTick interrupt, tickRateHz ticks per second */
      SysTick_Config( SystemCoreClock / tickRateHz);
1a002316:	4602      	mov	r2, r0
1a002318:	460b      	mov	r3, r1
1a00231a:	490e      	ldr	r1, [pc, #56]	; (1a002354 <tickConfig+0x6c>)
1a00231c:	6808      	ldr	r0, [r1, #0]
1a00231e:	2100      	movs	r1, #0
1a002320:	f000 f936 	bl	1a002590 <__aeabi_uldivmod>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
1a002324:	3801      	subs	r0, #1
1a002326:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
1a00232a:	d20d      	bcs.n	1a002348 <tickConfig+0x60>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
1a00232c:	4b0a      	ldr	r3, [pc, #40]	; (1a002358 <tickConfig+0x70>)
1a00232e:	6058      	str	r0, [r3, #4]
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
1a002330:	21e0      	movs	r1, #224	; 0xe0
1a002332:	4a0a      	ldr	r2, [pc, #40]	; (1a00235c <tickConfig+0x74>)
1a002334:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
1a002338:	2200      	movs	r2, #0
1a00233a:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
1a00233c:	2207      	movs	r2, #7
1a00233e:	601a      	str	r2, [r3, #0]
   bool_t ret_val = 1;
1a002340:	2001      	movs	r0, #1
1a002342:	bd08      	pop	{r3, pc}
   }
   else{
      /* Error, tickRateMS variable not in range (1 <= tickRateMS <= 50) */
      ret_val = 0;
1a002344:	2000      	movs	r0, #0
1a002346:	bd08      	pop	{r3, pc}
   bool_t ret_val = 1;
1a002348:	2001      	movs	r0, #1
   }

   return ret_val;
}
1a00234a:	bd08      	pop	{r3, pc}
1a00234c:	10000010 	.word	0x10000010
1a002350:	10000190 	.word	0x10000190
1a002354:	10000180 	.word	0x10000180
1a002358:	e000e010 	.word	0xe000e010
1a00235c:	e000ed00 	.word	0xe000ed00

1a002360 <tickRead>:


/* Read Tick Counter */
tick_t tickRead( void ) {
   return tickCounter;
}
1a002360:	4b01      	ldr	r3, [pc, #4]	; (1a002368 <tickRead+0x8>)
1a002362:	e9d3 0100 	ldrd	r0, r1, [r3]
1a002366:	4770      	bx	lr
1a002368:	10000188 	.word	0x10000188

1a00236c <SysTick_Handler>:
/*==================[ISR external functions definition]======================*/

//__attribute__ ((section(".after_vectors")))

/* SysTick Timer ISR Handler */
void SysTick_Handler(void) {
1a00236c:	b508      	push	{r3, lr}
   tickCounter++;
1a00236e:	4906      	ldr	r1, [pc, #24]	; (1a002388 <SysTick_Handler+0x1c>)
1a002370:	e9d1 2300 	ldrd	r2, r3, [r1]
1a002374:	3201      	adds	r2, #1
1a002376:	f143 0300 	adc.w	r3, r3, #0
1a00237a:	e9c1 2300 	strd	r2, r3, [r1]

	/* Execute Tick Hook function */
	(* tickHookFunction )( 0 );
1a00237e:	4b03      	ldr	r3, [pc, #12]	; (1a00238c <SysTick_Handler+0x20>)
1a002380:	681b      	ldr	r3, [r3, #0]
1a002382:	2000      	movs	r0, #0
1a002384:	4798      	blx	r3
1a002386:	bd08      	pop	{r3, pc}
1a002388:	10000188 	.word	0x10000188
1a00238c:	10000010 	.word	0x10000010

1a002390 <errorOcurred>:
/*==================[internal functions definition]==========================*/

/* Causes:
 * User forgot to initialize the functions for the compare match interrupt on Timer_init call
 */
static void errorOcurred(void){
1a002390:	e7fe      	b.n	1a002390 <errorOcurred>

1a002392 <doNothing>:
   while(1);
}

static void doNothing(void){
1a002392:	4770      	bx	lr

1a002394 <TIMER0_IRQHandler>:
/*==================[ISR external functions definition]======================*/
/*
 * @Brief:   Executes the functions passed by parameter in the Timer_init,
 *   at the chosen frequencies
 */
void TIMER0_IRQHandler(void){
1a002394:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a002396:	2400      	movs	r4, #0
1a002398:	e001      	b.n	1a00239e <TIMER0_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a00239a:	3401      	adds	r4, #1
1a00239c:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a00239e:	2c03      	cmp	r4, #3
1a0023a0:	d812      	bhi.n	1a0023c8 <TIMER0_IRQHandler+0x34>
      if( Chip_TIMER_MatchPending(LPC_TIMER0, compareMatchNumber) ){
1a0023a2:	b265      	sxtb	r5, r4
 * @note   Determine if the match interrupt for the passed timer and match
 * counter is pending.
 */
STATIC INLINE bool Chip_TIMER_MatchPending(LPC_TIMER_T *pTMR, int8_t matchnum)
{
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a0023a4:	4b09      	ldr	r3, [pc, #36]	; (1a0023cc <TIMER0_IRQHandler+0x38>)
1a0023a6:	681a      	ldr	r2, [r3, #0]
1a0023a8:	f004 010f 	and.w	r1, r4, #15
1a0023ac:	2301      	movs	r3, #1
1a0023ae:	408b      	lsls	r3, r1
1a0023b0:	421a      	tst	r2, r3
1a0023b2:	d0f2      	beq.n	1a00239a <TIMER0_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER0].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a0023b4:	4b06      	ldr	r3, [pc, #24]	; (1a0023d0 <TIMER0_IRQHandler+0x3c>)
1a0023b6:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
1a0023ba:	4798      	blx	r3
 * @return Nothing
 * @note   Clears a pending timer match interrupt.
 */
STATIC INLINE void Chip_TIMER_ClearMatch(LPC_TIMER_T *pTMR, int8_t matchnum)
{
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a0023bc:	2301      	movs	r3, #1
1a0023be:	fa03 f505 	lsl.w	r5, r3, r5
1a0023c2:	4b02      	ldr	r3, [pc, #8]	; (1a0023cc <TIMER0_IRQHandler+0x38>)
1a0023c4:	601d      	str	r5, [r3, #0]
1a0023c6:	e7e8      	b.n	1a00239a <TIMER0_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER0, compareMatchNumber);
      }
   }
}
1a0023c8:	bd38      	pop	{r3, r4, r5, pc}
1a0023ca:	bf00      	nop
1a0023cc:	40084000 	.word	0x40084000
1a0023d0:	10000014 	.word	0x10000014

1a0023d4 <TIMER1_IRQHandler>:

void TIMER1_IRQHandler( void ){
1a0023d4:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a0023d6:	2400      	movs	r4, #0
1a0023d8:	e001      	b.n	1a0023de <TIMER1_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a0023da:	3401      	adds	r4, #1
1a0023dc:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a0023de:	2c03      	cmp	r4, #3
1a0023e0:	d813      	bhi.n	1a00240a <TIMER1_IRQHandler+0x36>
      if( Chip_TIMER_MatchPending(LPC_TIMER1, compareMatchNumber) ){
1a0023e2:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a0023e4:	4b09      	ldr	r3, [pc, #36]	; (1a00240c <TIMER1_IRQHandler+0x38>)
1a0023e6:	681a      	ldr	r2, [r3, #0]
1a0023e8:	f004 010f 	and.w	r1, r4, #15
1a0023ec:	2301      	movs	r3, #1
1a0023ee:	408b      	lsls	r3, r1
1a0023f0:	421a      	tst	r2, r3
1a0023f2:	d0f2      	beq.n	1a0023da <TIMER1_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER1].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a0023f4:	1d23      	adds	r3, r4, #4
1a0023f6:	4a06      	ldr	r2, [pc, #24]	; (1a002410 <TIMER1_IRQHandler+0x3c>)
1a0023f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a0023fc:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a0023fe:	2301      	movs	r3, #1
1a002400:	fa03 f505 	lsl.w	r5, r3, r5
1a002404:	4b01      	ldr	r3, [pc, #4]	; (1a00240c <TIMER1_IRQHandler+0x38>)
1a002406:	601d      	str	r5, [r3, #0]
1a002408:	e7e7      	b.n	1a0023da <TIMER1_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER1, compareMatchNumber);
      }
   }
}
1a00240a:	bd38      	pop	{r3, r4, r5, pc}
1a00240c:	40085000 	.word	0x40085000
1a002410:	10000014 	.word	0x10000014

1a002414 <TIMER2_IRQHandler>:

void TIMER2_IRQHandler( void ){
1a002414:	b538      	push	{r3, r4, r5, lr}
   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a002416:	2400      	movs	r4, #0
1a002418:	e001      	b.n	1a00241e <TIMER2_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a00241a:	3401      	adds	r4, #1
1a00241c:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a00241e:	2c03      	cmp	r4, #3
1a002420:	d814      	bhi.n	1a00244c <TIMER2_IRQHandler+0x38>
      if( Chip_TIMER_MatchPending(LPC_TIMER2, compareMatchNumber) ){
1a002422:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a002424:	4b0a      	ldr	r3, [pc, #40]	; (1a002450 <TIMER2_IRQHandler+0x3c>)
1a002426:	681a      	ldr	r2, [r3, #0]
1a002428:	f004 010f 	and.w	r1, r4, #15
1a00242c:	2301      	movs	r3, #1
1a00242e:	408b      	lsls	r3, r1
1a002430:	421a      	tst	r2, r3
1a002432:	d0f2      	beq.n	1a00241a <TIMER2_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER2].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a002434:	f104 0308 	add.w	r3, r4, #8
1a002438:	4a06      	ldr	r2, [pc, #24]	; (1a002454 <TIMER2_IRQHandler+0x40>)
1a00243a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a00243e:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a002440:	2301      	movs	r3, #1
1a002442:	fa03 f505 	lsl.w	r5, r3, r5
1a002446:	4b02      	ldr	r3, [pc, #8]	; (1a002450 <TIMER2_IRQHandler+0x3c>)
1a002448:	601d      	str	r5, [r3, #0]
1a00244a:	e7e6      	b.n	1a00241a <TIMER2_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER2, compareMatchNumber);
      }
   }
}
1a00244c:	bd38      	pop	{r3, r4, r5, pc}
1a00244e:	bf00      	nop
1a002450:	400c3000 	.word	0x400c3000
1a002454:	10000014 	.word	0x10000014

1a002458 <TIMER3_IRQHandler>:

/*fixme __attribute__ ((section(".after_vectors")))*/
void TIMER3_IRQHandler( void ){
1a002458:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a00245a:	2400      	movs	r4, #0
1a00245c:	e001      	b.n	1a002462 <TIMER3_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a00245e:	3401      	adds	r4, #1
1a002460:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a002462:	2c03      	cmp	r4, #3
1a002464:	d814      	bhi.n	1a002490 <TIMER3_IRQHandler+0x38>
      if (Chip_TIMER_MatchPending(LPC_TIMER3, compareMatchNumber)){
1a002466:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a002468:	4b0a      	ldr	r3, [pc, #40]	; (1a002494 <TIMER3_IRQHandler+0x3c>)
1a00246a:	681a      	ldr	r2, [r3, #0]
1a00246c:	f004 010f 	and.w	r1, r4, #15
1a002470:	2301      	movs	r3, #1
1a002472:	408b      	lsls	r3, r1
1a002474:	421a      	tst	r2, r3
1a002476:	d0f2      	beq.n	1a00245e <TIMER3_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER3].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a002478:	f104 030c 	add.w	r3, r4, #12
1a00247c:	4a06      	ldr	r2, [pc, #24]	; (1a002498 <TIMER3_IRQHandler+0x40>)
1a00247e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a002482:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a002484:	2301      	movs	r3, #1
1a002486:	fa03 f505 	lsl.w	r5, r3, r5
1a00248a:	4b02      	ldr	r3, [pc, #8]	; (1a002494 <TIMER3_IRQHandler+0x3c>)
1a00248c:	601d      	str	r5, [r3, #0]
1a00248e:	e7e6      	b.n	1a00245e <TIMER3_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER3, compareMatchNumber);
      }
   }
}
1a002490:	bd38      	pop	{r3, r4, r5, pc}
1a002492:	bf00      	nop
1a002494:	400c4000 	.word	0x400c4000
1a002498:	10000014 	.word	0x10000014

1a00249c <uartConfig>:
void uartConfig( uartMap_t uart, uint32_t baudRate ){
1a00249c:	b538      	push	{r3, r4, r5, lr}
1a00249e:	460c      	mov	r4, r1
   switch(uart){
1a0024a0:	b110      	cbz	r0, 1a0024a8 <uartConfig+0xc>
1a0024a2:	2801      	cmp	r0, #1
1a0024a4:	d013      	beq.n	1a0024ce <uartConfig+0x32>
1a0024a6:	bd38      	pop	{r3, r4, r5, pc}
      Chip_UART_Init(UART_USB_LPC);
1a0024a8:	4d12      	ldr	r5, [pc, #72]	; (1a0024f4 <uartConfig+0x58>)
1a0024aa:	4628      	mov	r0, r5
1a0024ac:	f7ff fb90 	bl	1a001bd0 <Chip_UART_Init>
      Chip_UART_SetBaud(UART_USB_LPC, baudRate);  /* Set Baud rate */
1a0024b0:	4621      	mov	r1, r4
1a0024b2:	4628      	mov	r0, r5
1a0024b4:	f7ff fbb6 	bl	1a001c24 <Chip_UART_SetBaud>
   pUART->FCR = fcr;
1a0024b8:	2301      	movs	r3, #1
1a0024ba:	60ab      	str	r3, [r5, #8]
    pUART->TER2 = UART_TER2_TXEN;
1a0024bc:	65eb      	str	r3, [r5, #92]	; 0x5c
1a0024be:	4b0e      	ldr	r3, [pc, #56]	; (1a0024f8 <uartConfig+0x5c>)
1a0024c0:	221e      	movs	r2, #30
1a0024c2:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
1a0024c6:	22d6      	movs	r2, #214	; 0xd6
1a0024c8:	f8c3 2388 	str.w	r2, [r3, #904]	; 0x388
1a0024cc:	bd38      	pop	{r3, r4, r5, pc}
      Chip_UART_Init(UART_232_LPC);
1a0024ce:	4d0b      	ldr	r5, [pc, #44]	; (1a0024fc <uartConfig+0x60>)
1a0024d0:	4628      	mov	r0, r5
1a0024d2:	f7ff fb7d 	bl	1a001bd0 <Chip_UART_Init>
      Chip_UART_SetBaud(UART_232_LPC, baudRate);  /* Set Baud rate */
1a0024d6:	4621      	mov	r1, r4
1a0024d8:	4628      	mov	r0, r5
1a0024da:	f7ff fba3 	bl	1a001c24 <Chip_UART_SetBaud>
   pUART->FCR = fcr;
1a0024de:	2301      	movs	r3, #1
1a0024e0:	60ab      	str	r3, [r5, #8]
    pUART->TER2 = UART_TER2_TXEN;
1a0024e2:	65eb      	str	r3, [r5, #92]	; 0x5c
1a0024e4:	4b04      	ldr	r3, [pc, #16]	; (1a0024f8 <uartConfig+0x5c>)
1a0024e6:	221a      	movs	r2, #26
1a0024e8:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
1a0024ec:	22d2      	movs	r2, #210	; 0xd2
1a0024ee:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
1a0024f2:	bd38      	pop	{r3, r4, r5, pc}
1a0024f4:	400c1000 	.word	0x400c1000
1a0024f8:	40086000 	.word	0x40086000
1a0024fc:	400c2000 	.word	0x400c2000

1a002500 <uartReadByte>:
   switch(uart){
1a002500:	b118      	cbz	r0, 1a00250a <uartReadByte+0xa>
1a002502:	2801      	cmp	r0, #1
1a002504:	d00b      	beq.n	1a00251e <uartReadByte+0x1e>
   bool_t retVal = TRUE;
1a002506:	2001      	movs	r0, #1
1a002508:	4770      	bx	lr
 * @note   Mask bits of the returned status value with UART_LSR_*
 *         definitions for specific statuses.
 */
STATIC INLINE uint32_t Chip_UART_ReadLineStatus(LPC_USART_T *pUART)
{
   return pUART->LSR;
1a00250a:	4b0c      	ldr	r3, [pc, #48]	; (1a00253c <uartReadByte+0x3c>)
1a00250c:	695b      	ldr	r3, [r3, #20]
      if ( Chip_UART_ReadLineStatus(UART_USB_LPC) & UART_LSR_RDR ) {
1a00250e:	f013 0f01 	tst.w	r3, #1
1a002512:	d00e      	beq.n	1a002532 <uartReadByte+0x32>
   return (uint8_t) (pUART->RBR & UART_RBR_MASKBIT);
1a002514:	4b09      	ldr	r3, [pc, #36]	; (1a00253c <uartReadByte+0x3c>)
1a002516:	681b      	ldr	r3, [r3, #0]
         *receivedByte = Chip_UART_ReadByte(UART_USB_LPC);
1a002518:	700b      	strb	r3, [r1, #0]
   bool_t retVal = TRUE;
1a00251a:	2001      	movs	r0, #1
1a00251c:	4770      	bx	lr
   return pUART->LSR;
1a00251e:	4b08      	ldr	r3, [pc, #32]	; (1a002540 <uartReadByte+0x40>)
1a002520:	695b      	ldr	r3, [r3, #20]
      if ( Chip_UART_ReadLineStatus(UART_232_LPC) & UART_LSR_RDR ) {
1a002522:	f013 0f01 	tst.w	r3, #1
1a002526:	d006      	beq.n	1a002536 <uartReadByte+0x36>
   return (uint8_t) (pUART->RBR & UART_RBR_MASKBIT);
1a002528:	4b05      	ldr	r3, [pc, #20]	; (1a002540 <uartReadByte+0x40>)
1a00252a:	681b      	ldr	r3, [r3, #0]
         *receivedByte = Chip_UART_ReadByte(UART_232_LPC);
1a00252c:	700b      	strb	r3, [r1, #0]
   bool_t retVal = TRUE;
1a00252e:	2001      	movs	r0, #1
1a002530:	4770      	bx	lr
         retVal = FALSE;
1a002532:	2000      	movs	r0, #0
1a002534:	4770      	bx	lr
         retVal = FALSE;
1a002536:	2000      	movs	r0, #0
}
1a002538:	4770      	bx	lr
1a00253a:	bf00      	nop
1a00253c:	400c1000 	.word	0x400c1000
1a002540:	400c2000 	.word	0x400c2000

1a002544 <uartWriteByte>:
   switch(uart){
1a002544:	b110      	cbz	r0, 1a00254c <uartWriteByte+0x8>
1a002546:	2801      	cmp	r0, #1
1a002548:	d008      	beq.n	1a00255c <uartWriteByte+0x18>
1a00254a:	4770      	bx	lr
   return pUART->LSR;
1a00254c:	4b07      	ldr	r3, [pc, #28]	; (1a00256c <uartWriteByte+0x28>)
1a00254e:	695b      	ldr	r3, [r3, #20]
      while ((Chip_UART_ReadLineStatus(UART_USB_LPC) & UART_LSR_THRE) == 0) {}   // Wait for space in FIFO
1a002550:	f013 0f20 	tst.w	r3, #32
1a002554:	d0fa      	beq.n	1a00254c <uartWriteByte+0x8>
   pUART->THR = (uint32_t) data;
1a002556:	4b05      	ldr	r3, [pc, #20]	; (1a00256c <uartWriteByte+0x28>)
1a002558:	6019      	str	r1, [r3, #0]
1a00255a:	4770      	bx	lr
   return pUART->LSR;
1a00255c:	4b04      	ldr	r3, [pc, #16]	; (1a002570 <uartWriteByte+0x2c>)
1a00255e:	695b      	ldr	r3, [r3, #20]
      while ((Chip_UART_ReadLineStatus(UART_232_LPC) & UART_LSR_THRE) == 0) {}   // Wait for space in FIFO
1a002560:	f013 0f20 	tst.w	r3, #32
1a002564:	d0fa      	beq.n	1a00255c <uartWriteByte+0x18>
   pUART->THR = (uint32_t) data;
1a002566:	4b02      	ldr	r3, [pc, #8]	; (1a002570 <uartWriteByte+0x2c>)
1a002568:	6019      	str	r1, [r3, #0]
1a00256a:	4770      	bx	lr
1a00256c:	400c1000 	.word	0x400c1000
1a002570:	400c2000 	.word	0x400c2000

1a002574 <uartWriteString>:
void uartWriteString( uartMap_t uart, char* str ){
1a002574:	b538      	push	{r3, r4, r5, lr}
1a002576:	4605      	mov	r5, r0
1a002578:	460c      	mov	r4, r1
   while(*str != 0){
1a00257a:	e003      	b.n	1a002584 <uartWriteString+0x10>
	  uartWriteByte( uart, (uint8_t)*str );
1a00257c:	4628      	mov	r0, r5
1a00257e:	f7ff ffe1 	bl	1a002544 <uartWriteByte>
	  str++;
1a002582:	3401      	adds	r4, #1
   while(*str != 0){
1a002584:	7821      	ldrb	r1, [r4, #0]
1a002586:	2900      	cmp	r1, #0
1a002588:	d1f8      	bne.n	1a00257c <uartWriteString+0x8>
}
1a00258a:	bd38      	pop	{r3, r4, r5, pc}

1a00258c <UART2_IRQHandler>:
}

/* 0x2a 0x000000A8 - Handler for ISR UART2 (IRQ 26) */
void UART2_IRQHandler(void){
1a00258c:	4770      	bx	lr

1a00258e <UART3_IRQHandler>:
}

/* 0x2b 0x000000AC - Handler for ISR UART3 (IRQ 27) */
void UART3_IRQHandler(void){
1a00258e:	4770      	bx	lr

1a002590 <__aeabi_uldivmod>:
1a002590:	b953      	cbnz	r3, 1a0025a8 <__aeabi_uldivmod+0x18>
1a002592:	b94a      	cbnz	r2, 1a0025a8 <__aeabi_uldivmod+0x18>
1a002594:	2900      	cmp	r1, #0
1a002596:	bf08      	it	eq
1a002598:	2800      	cmpeq	r0, #0
1a00259a:	bf1c      	itt	ne
1a00259c:	f04f 31ff 	movne.w	r1, #4294967295
1a0025a0:	f04f 30ff 	movne.w	r0, #4294967295
1a0025a4:	f000 b97a 	b.w	1a00289c <__aeabi_idiv0>
1a0025a8:	f1ad 0c08 	sub.w	ip, sp, #8
1a0025ac:	e96d ce04 	strd	ip, lr, [sp, #-16]!
1a0025b0:	f000 f806 	bl	1a0025c0 <__udivmoddi4>
1a0025b4:	f8dd e004 	ldr.w	lr, [sp, #4]
1a0025b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
1a0025bc:	b004      	add	sp, #16
1a0025be:	4770      	bx	lr

1a0025c0 <__udivmoddi4>:
1a0025c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
1a0025c4:	468c      	mov	ip, r1
1a0025c6:	460d      	mov	r5, r1
1a0025c8:	4604      	mov	r4, r0
1a0025ca:	9e08      	ldr	r6, [sp, #32]
1a0025cc:	2b00      	cmp	r3, #0
1a0025ce:	d151      	bne.n	1a002674 <__udivmoddi4+0xb4>
1a0025d0:	428a      	cmp	r2, r1
1a0025d2:	4617      	mov	r7, r2
1a0025d4:	d96d      	bls.n	1a0026b2 <__udivmoddi4+0xf2>
1a0025d6:	fab2 fe82 	clz	lr, r2
1a0025da:	f1be 0f00 	cmp.w	lr, #0
1a0025de:	d00b      	beq.n	1a0025f8 <__udivmoddi4+0x38>
1a0025e0:	f1ce 0c20 	rsb	ip, lr, #32
1a0025e4:	fa01 f50e 	lsl.w	r5, r1, lr
1a0025e8:	fa20 fc0c 	lsr.w	ip, r0, ip
1a0025ec:	fa02 f70e 	lsl.w	r7, r2, lr
1a0025f0:	ea4c 0c05 	orr.w	ip, ip, r5
1a0025f4:	fa00 f40e 	lsl.w	r4, r0, lr
1a0025f8:	ea4f 4a17 	mov.w	sl, r7, lsr #16
1a0025fc:	0c25      	lsrs	r5, r4, #16
1a0025fe:	fbbc f8fa 	udiv	r8, ip, sl
1a002602:	fa1f f987 	uxth.w	r9, r7
1a002606:	fb0a cc18 	mls	ip, sl, r8, ip
1a00260a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
1a00260e:	fb08 f309 	mul.w	r3, r8, r9
1a002612:	42ab      	cmp	r3, r5
1a002614:	d90a      	bls.n	1a00262c <__udivmoddi4+0x6c>
1a002616:	19ed      	adds	r5, r5, r7
1a002618:	f108 32ff 	add.w	r2, r8, #4294967295
1a00261c:	f080 8123 	bcs.w	1a002866 <__udivmoddi4+0x2a6>
1a002620:	42ab      	cmp	r3, r5
1a002622:	f240 8120 	bls.w	1a002866 <__udivmoddi4+0x2a6>
1a002626:	f1a8 0802 	sub.w	r8, r8, #2
1a00262a:	443d      	add	r5, r7
1a00262c:	1aed      	subs	r5, r5, r3
1a00262e:	b2a4      	uxth	r4, r4
1a002630:	fbb5 f0fa 	udiv	r0, r5, sl
1a002634:	fb0a 5510 	mls	r5, sl, r0, r5
1a002638:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
1a00263c:	fb00 f909 	mul.w	r9, r0, r9
1a002640:	45a1      	cmp	r9, r4
1a002642:	d909      	bls.n	1a002658 <__udivmoddi4+0x98>
1a002644:	19e4      	adds	r4, r4, r7
1a002646:	f100 33ff 	add.w	r3, r0, #4294967295
1a00264a:	f080 810a 	bcs.w	1a002862 <__udivmoddi4+0x2a2>
1a00264e:	45a1      	cmp	r9, r4
1a002650:	f240 8107 	bls.w	1a002862 <__udivmoddi4+0x2a2>
1a002654:	3802      	subs	r0, #2
1a002656:	443c      	add	r4, r7
1a002658:	eba4 0409 	sub.w	r4, r4, r9
1a00265c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
1a002660:	2100      	movs	r1, #0
1a002662:	2e00      	cmp	r6, #0
1a002664:	d061      	beq.n	1a00272a <__udivmoddi4+0x16a>
1a002666:	fa24 f40e 	lsr.w	r4, r4, lr
1a00266a:	2300      	movs	r3, #0
1a00266c:	6034      	str	r4, [r6, #0]
1a00266e:	6073      	str	r3, [r6, #4]
1a002670:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a002674:	428b      	cmp	r3, r1
1a002676:	d907      	bls.n	1a002688 <__udivmoddi4+0xc8>
1a002678:	2e00      	cmp	r6, #0
1a00267a:	d054      	beq.n	1a002726 <__udivmoddi4+0x166>
1a00267c:	2100      	movs	r1, #0
1a00267e:	e886 0021 	stmia.w	r6, {r0, r5}
1a002682:	4608      	mov	r0, r1
1a002684:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a002688:	fab3 f183 	clz	r1, r3
1a00268c:	2900      	cmp	r1, #0
1a00268e:	f040 808e 	bne.w	1a0027ae <__udivmoddi4+0x1ee>
1a002692:	42ab      	cmp	r3, r5
1a002694:	d302      	bcc.n	1a00269c <__udivmoddi4+0xdc>
1a002696:	4282      	cmp	r2, r0
1a002698:	f200 80fa 	bhi.w	1a002890 <__udivmoddi4+0x2d0>
1a00269c:	1a84      	subs	r4, r0, r2
1a00269e:	eb65 0503 	sbc.w	r5, r5, r3
1a0026a2:	2001      	movs	r0, #1
1a0026a4:	46ac      	mov	ip, r5
1a0026a6:	2e00      	cmp	r6, #0
1a0026a8:	d03f      	beq.n	1a00272a <__udivmoddi4+0x16a>
1a0026aa:	e886 1010 	stmia.w	r6, {r4, ip}
1a0026ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a0026b2:	b912      	cbnz	r2, 1a0026ba <__udivmoddi4+0xfa>
1a0026b4:	2701      	movs	r7, #1
1a0026b6:	fbb7 f7f2 	udiv	r7, r7, r2
1a0026ba:	fab7 fe87 	clz	lr, r7
1a0026be:	f1be 0f00 	cmp.w	lr, #0
1a0026c2:	d134      	bne.n	1a00272e <__udivmoddi4+0x16e>
1a0026c4:	1beb      	subs	r3, r5, r7
1a0026c6:	0c3a      	lsrs	r2, r7, #16
1a0026c8:	fa1f fc87 	uxth.w	ip, r7
1a0026cc:	2101      	movs	r1, #1
1a0026ce:	fbb3 f8f2 	udiv	r8, r3, r2
1a0026d2:	0c25      	lsrs	r5, r4, #16
1a0026d4:	fb02 3318 	mls	r3, r2, r8, r3
1a0026d8:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
1a0026dc:	fb0c f308 	mul.w	r3, ip, r8
1a0026e0:	42ab      	cmp	r3, r5
1a0026e2:	d907      	bls.n	1a0026f4 <__udivmoddi4+0x134>
1a0026e4:	19ed      	adds	r5, r5, r7
1a0026e6:	f108 30ff 	add.w	r0, r8, #4294967295
1a0026ea:	d202      	bcs.n	1a0026f2 <__udivmoddi4+0x132>
1a0026ec:	42ab      	cmp	r3, r5
1a0026ee:	f200 80d1 	bhi.w	1a002894 <__udivmoddi4+0x2d4>
1a0026f2:	4680      	mov	r8, r0
1a0026f4:	1aed      	subs	r5, r5, r3
1a0026f6:	b2a3      	uxth	r3, r4
1a0026f8:	fbb5 f0f2 	udiv	r0, r5, r2
1a0026fc:	fb02 5510 	mls	r5, r2, r0, r5
1a002700:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
1a002704:	fb0c fc00 	mul.w	ip, ip, r0
1a002708:	45a4      	cmp	ip, r4
1a00270a:	d907      	bls.n	1a00271c <__udivmoddi4+0x15c>
1a00270c:	19e4      	adds	r4, r4, r7
1a00270e:	f100 33ff 	add.w	r3, r0, #4294967295
1a002712:	d202      	bcs.n	1a00271a <__udivmoddi4+0x15a>
1a002714:	45a4      	cmp	ip, r4
1a002716:	f200 80b8 	bhi.w	1a00288a <__udivmoddi4+0x2ca>
1a00271a:	4618      	mov	r0, r3
1a00271c:	eba4 040c 	sub.w	r4, r4, ip
1a002720:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
1a002724:	e79d      	b.n	1a002662 <__udivmoddi4+0xa2>
1a002726:	4631      	mov	r1, r6
1a002728:	4630      	mov	r0, r6
1a00272a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a00272e:	f1ce 0420 	rsb	r4, lr, #32
1a002732:	fa05 f30e 	lsl.w	r3, r5, lr
1a002736:	fa07 f70e 	lsl.w	r7, r7, lr
1a00273a:	fa20 f804 	lsr.w	r8, r0, r4
1a00273e:	0c3a      	lsrs	r2, r7, #16
1a002740:	fa25 f404 	lsr.w	r4, r5, r4
1a002744:	ea48 0803 	orr.w	r8, r8, r3
1a002748:	fbb4 f1f2 	udiv	r1, r4, r2
1a00274c:	ea4f 4518 	mov.w	r5, r8, lsr #16
1a002750:	fb02 4411 	mls	r4, r2, r1, r4
1a002754:	fa1f fc87 	uxth.w	ip, r7
1a002758:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
1a00275c:	fb01 f30c 	mul.w	r3, r1, ip
1a002760:	42ab      	cmp	r3, r5
1a002762:	fa00 f40e 	lsl.w	r4, r0, lr
1a002766:	d909      	bls.n	1a00277c <__udivmoddi4+0x1bc>
1a002768:	19ed      	adds	r5, r5, r7
1a00276a:	f101 30ff 	add.w	r0, r1, #4294967295
1a00276e:	f080 808a 	bcs.w	1a002886 <__udivmoddi4+0x2c6>
1a002772:	42ab      	cmp	r3, r5
1a002774:	f240 8087 	bls.w	1a002886 <__udivmoddi4+0x2c6>
1a002778:	3902      	subs	r1, #2
1a00277a:	443d      	add	r5, r7
1a00277c:	1aeb      	subs	r3, r5, r3
1a00277e:	fa1f f588 	uxth.w	r5, r8
1a002782:	fbb3 f0f2 	udiv	r0, r3, r2
1a002786:	fb02 3310 	mls	r3, r2, r0, r3
1a00278a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
1a00278e:	fb00 f30c 	mul.w	r3, r0, ip
1a002792:	42ab      	cmp	r3, r5
1a002794:	d907      	bls.n	1a0027a6 <__udivmoddi4+0x1e6>
1a002796:	19ed      	adds	r5, r5, r7
1a002798:	f100 38ff 	add.w	r8, r0, #4294967295
1a00279c:	d26f      	bcs.n	1a00287e <__udivmoddi4+0x2be>
1a00279e:	42ab      	cmp	r3, r5
1a0027a0:	d96d      	bls.n	1a00287e <__udivmoddi4+0x2be>
1a0027a2:	3802      	subs	r0, #2
1a0027a4:	443d      	add	r5, r7
1a0027a6:	1aeb      	subs	r3, r5, r3
1a0027a8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
1a0027ac:	e78f      	b.n	1a0026ce <__udivmoddi4+0x10e>
1a0027ae:	f1c1 0720 	rsb	r7, r1, #32
1a0027b2:	fa22 f807 	lsr.w	r8, r2, r7
1a0027b6:	408b      	lsls	r3, r1
1a0027b8:	fa05 f401 	lsl.w	r4, r5, r1
1a0027bc:	ea48 0303 	orr.w	r3, r8, r3
1a0027c0:	fa20 fe07 	lsr.w	lr, r0, r7
1a0027c4:	ea4f 4c13 	mov.w	ip, r3, lsr #16
1a0027c8:	40fd      	lsrs	r5, r7
1a0027ca:	ea4e 0e04 	orr.w	lr, lr, r4
1a0027ce:	fbb5 f9fc 	udiv	r9, r5, ip
1a0027d2:	ea4f 441e 	mov.w	r4, lr, lsr #16
1a0027d6:	fb0c 5519 	mls	r5, ip, r9, r5
1a0027da:	fa1f f883 	uxth.w	r8, r3
1a0027de:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
1a0027e2:	fb09 f408 	mul.w	r4, r9, r8
1a0027e6:	42ac      	cmp	r4, r5
1a0027e8:	fa02 f201 	lsl.w	r2, r2, r1
1a0027ec:	fa00 fa01 	lsl.w	sl, r0, r1
1a0027f0:	d908      	bls.n	1a002804 <__udivmoddi4+0x244>
1a0027f2:	18ed      	adds	r5, r5, r3
1a0027f4:	f109 30ff 	add.w	r0, r9, #4294967295
1a0027f8:	d243      	bcs.n	1a002882 <__udivmoddi4+0x2c2>
1a0027fa:	42ac      	cmp	r4, r5
1a0027fc:	d941      	bls.n	1a002882 <__udivmoddi4+0x2c2>
1a0027fe:	f1a9 0902 	sub.w	r9, r9, #2
1a002802:	441d      	add	r5, r3
1a002804:	1b2d      	subs	r5, r5, r4
1a002806:	fa1f fe8e 	uxth.w	lr, lr
1a00280a:	fbb5 f0fc 	udiv	r0, r5, ip
1a00280e:	fb0c 5510 	mls	r5, ip, r0, r5
1a002812:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
1a002816:	fb00 f808 	mul.w	r8, r0, r8
1a00281a:	45a0      	cmp	r8, r4
1a00281c:	d907      	bls.n	1a00282e <__udivmoddi4+0x26e>
1a00281e:	18e4      	adds	r4, r4, r3
1a002820:	f100 35ff 	add.w	r5, r0, #4294967295
1a002824:	d229      	bcs.n	1a00287a <__udivmoddi4+0x2ba>
1a002826:	45a0      	cmp	r8, r4
1a002828:	d927      	bls.n	1a00287a <__udivmoddi4+0x2ba>
1a00282a:	3802      	subs	r0, #2
1a00282c:	441c      	add	r4, r3
1a00282e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
1a002832:	eba4 0408 	sub.w	r4, r4, r8
1a002836:	fba0 8902 	umull	r8, r9, r0, r2
1a00283a:	454c      	cmp	r4, r9
1a00283c:	46c6      	mov	lr, r8
1a00283e:	464d      	mov	r5, r9
1a002840:	d315      	bcc.n	1a00286e <__udivmoddi4+0x2ae>
1a002842:	d012      	beq.n	1a00286a <__udivmoddi4+0x2aa>
1a002844:	b156      	cbz	r6, 1a00285c <__udivmoddi4+0x29c>
1a002846:	ebba 030e 	subs.w	r3, sl, lr
1a00284a:	eb64 0405 	sbc.w	r4, r4, r5
1a00284e:	fa04 f707 	lsl.w	r7, r4, r7
1a002852:	40cb      	lsrs	r3, r1
1a002854:	431f      	orrs	r7, r3
1a002856:	40cc      	lsrs	r4, r1
1a002858:	6037      	str	r7, [r6, #0]
1a00285a:	6074      	str	r4, [r6, #4]
1a00285c:	2100      	movs	r1, #0
1a00285e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a002862:	4618      	mov	r0, r3
1a002864:	e6f8      	b.n	1a002658 <__udivmoddi4+0x98>
1a002866:	4690      	mov	r8, r2
1a002868:	e6e0      	b.n	1a00262c <__udivmoddi4+0x6c>
1a00286a:	45c2      	cmp	sl, r8
1a00286c:	d2ea      	bcs.n	1a002844 <__udivmoddi4+0x284>
1a00286e:	ebb8 0e02 	subs.w	lr, r8, r2
1a002872:	eb69 0503 	sbc.w	r5, r9, r3
1a002876:	3801      	subs	r0, #1
1a002878:	e7e4      	b.n	1a002844 <__udivmoddi4+0x284>
1a00287a:	4628      	mov	r0, r5
1a00287c:	e7d7      	b.n	1a00282e <__udivmoddi4+0x26e>
1a00287e:	4640      	mov	r0, r8
1a002880:	e791      	b.n	1a0027a6 <__udivmoddi4+0x1e6>
1a002882:	4681      	mov	r9, r0
1a002884:	e7be      	b.n	1a002804 <__udivmoddi4+0x244>
1a002886:	4601      	mov	r1, r0
1a002888:	e778      	b.n	1a00277c <__udivmoddi4+0x1bc>
1a00288a:	3802      	subs	r0, #2
1a00288c:	443c      	add	r4, r7
1a00288e:	e745      	b.n	1a00271c <__udivmoddi4+0x15c>
1a002890:	4608      	mov	r0, r1
1a002892:	e708      	b.n	1a0026a6 <__udivmoddi4+0xe6>
1a002894:	f1a8 0802 	sub.w	r8, r8, #2
1a002898:	443d      	add	r5, r7
1a00289a:	e72b      	b.n	1a0026f4 <__udivmoddi4+0x134>

1a00289c <__aeabi_idiv0>:
1a00289c:	4770      	bx	lr
1a00289e:	bf00      	nop

1a0028a0 <memset>:
1a0028a0:	4402      	add	r2, r0
1a0028a2:	4603      	mov	r3, r0
1a0028a4:	4293      	cmp	r3, r2
1a0028a6:	d100      	bne.n	1a0028aa <memset+0xa>
1a0028a8:	4770      	bx	lr
1a0028aa:	f803 1b01 	strb.w	r1, [r3], #1
1a0028ae:	e7f9      	b.n	1a0028a4 <memset+0x4>

1a0028b0 <pinesColumna>:
1a0028b0:	0405 0203                                   ....

1a0028b4 <pinesFila>:
1a0028b4:	0809 0607                                   ....

1a0028b8 <pinesTeclado>:
1a0028b8:	0001 0002 0003 0041 0004 0005 0006 0042     ......A.......B.
1a0028c8:	0007 0008 0009 0043 002a 0000 0023 0044     ......C.*...#.D.
1a0028d8:	5b1b 4a32 5b1b 0048 7542 5b66 5d30 203d     .[2J.[H.Buf[0]= 
1a0028e8:	0000 0000 7542 5b66 5d31 203d 0000 0000     ....Buf[1]= ....
1a0028f8:	7542 5b66 5d32 203d 0000 0000 7542 5b66     Buf[2]= ....Buf[
1a002908:	5d33 203d 0000 0000 7542 5b66 5d34 203d     3]= ....Buf[4]= 
1a002918:	0000 0000 7542 5b66 5d35 203d 0000 0000     ....Buf[5]= ....
1a002928:	7542 5b66 5d36 203d 0000 0000 7542 5b66     Buf[6]= ....Buf[
1a002938:	5d37 203d 0000 0000 7542 5b66 5d38 203d     7]= ....Buf[8]= 
1a002948:	0000 0000 7542 5b66 5d39 203d 0000 0000     ....Buf[9]= ....
1a002958:	7345 6174 6f64 6420 6c65 4120 6373 6e65     Estado del Ascen
1a002968:	6f73 3a72 0020 0000 6e45 5020 616c 746e     sor: ...En Plant
1a002978:	2061 6142 616a 7920 0020 0000 7553 6962     a Baja y ...Subi
1a002988:	6e65 6f64 7920 0020 6142 616a 646e 206f     endo y .Bajando 
1a002998:	2079 0000 6150 6172 6f64 7920 0020 0000     y ..Parado y ...
1a0029a8:	6559 646e 206f 2061 6c50 6e61 6174 4220     Yendo a Planta B
1a0029b8:	6a61 2061 2079 0000 6f4d 6f64 4320 6e6f     aja y ..Modo Con
1a0029c8:	6966 7567 6172 6963 6e6f 7920 0020 0000     figuracion y ...
1a0029d8:	7550 7265 6174 2073 6543 7272 6461 7361     Puertas Cerradas
1a0029e8:	0a0d 0000 6241 6972 6e65 6f64 5020 6575     ....Abriendo Pue
1a0029f8:	7472 7361 0a0d 0000 7550 7265 6174 2073     rtas....Puertas 
1a002a08:	6241 6569 7472 7361 0a0d 0000 6e49 6574     Abiertas....Inte
1a002a18:	746e 6461 206f 6543 7272 7261 5020 6575     ntado Cerrar Pue
1a002a28:	7472 7361 0a0d 0000 6543 7272 6e61 6f64     rtas....Cerrando
1a002a38:	5020 6575 7472 7361 0a0d 0000 6c41 7261      Puertas....Alar
1a002a48:	616d 5020 6575 7472 7361 4120 6962 7265     ma Puertas Abier
1a002a58:	6174 0d73 000a 0000 6950 6564 6e20 6575     tas.....Pide nue
1a002a68:	6f76 7020 7369 206f 203d 4953 0a0d 0000     vo piso = SI....
1a002a78:	6950 6564 6e20 6575 6f76 7020 7369 206f     Pide nuevo piso 
1a002a88:	203d 4f4e 0a0d 0000 6950 6f73 4420 7365     = NO....Piso Des
1a002a98:	6974 6f6e 3d20 0020 6950 6f73 4120 7463     tino = .Piso Act
1a002aa8:	6175 206c 203d ff00 797a 7778 7576 7374     ual = ..zyxwvuts
1a002ab8:	7172 6f70 6d6e 6b6c 696a 6768 6566 6364     rqponmlkjihgfedc
1a002ac8:	6162 3839 3637 3435 3233 3031 3231 3433     ba98765432101234
1a002ad8:	3635 3837 6139 6362 6564 6766 6968 6b6a     56789abcdefghijk
1a002ae8:	6d6c 6f6e 7170 7372 7574 7776 7978 007a     lmnopqrstuvwxyz.

1a002af8 <numeroadisplayB>:
1a002af8:	063f 4f5b 6d66 077d 6f7f 7c5f 5e58 717b     ?.[Ofm}..o_|X^{q
1a002b08:	3977 7679 381e 3e73 4080 ff00               w9yv.8s>.@..

1a002b14 <quedisplayB>:
1a002b14:	1110 1412                                   ....

1a002b18 <segmentosdisplayB>:
1a002b18:	0f20 0e1f 0d1e 0c1d 6c45 6769 2061 6e75      .......Eliga un
1a002b28:	2061 6564 6c20 7361 7320 6769 6975 6e65     a de las siguien
1a002b38:	6574 2073 706f 6963 6e6f 7365 6120 6320     tes opciones a c
1a002b48:	6e6f 6966 7567 6172 3a72 0a0d 0000 0000     onfigurar:......
1a002b58:	2931 4320 6e6f 6966 7567 6172 2072 6576     1) Configurar ve
1a002b68:	6f6c 6963 6164 2064 6e65 7274 2065 6970     locidad entre pi
1a002b78:	6f73 7920 7020 7369 206f 7328 6765 3a29     so y piso (seg):
1a002b88:	2020 0000 2932 4320 6e6f 6966 7567 6172       ..2) Configura
1a002b98:	2072 6576 6f6c 6963 6164 2064 6564 6120     r velocidad de a
1a002ba8:	6570 7472 7275 2061 206f 6563 7272 6461     pertura o cerrad
1a002bb8:	206f 6564 7020 6575 7472 7361 2820 6573     o de puertas (se
1a002bc8:	2967 203a 0020 0000 2933 4320 6e6f 6966     g):  ...3) Confi
1a002bd8:	7567 6172 2072 6163 746e 6469 6461 6d20     gurar cantidad m
1a002be8:	7861 6d69 2061 6564 7020 7369 736f 2820     axima de pisos (
1a002bf8:	2031 2061 3032 3a29 2020 0000 2934 4320     1 a 20):  ..4) C
1a002c08:	6e6f 6966 7567 6172 2072 6163 746e 6469     onfigurar cantid
1a002c18:	6461 6d20 7861 6d69 2061 6564 7320 6275     ad maxima de sub
1a002c28:	7573 6c65 736f 2820 2030 2061 2935 203a     suelos (0 a 5): 
1a002c38:	0020 0000 2935 5320 6c61 7269 6420 6c65      ...5) Salir del
1a002c48:	6d20 646f 206f 6f63 666e 6769 7275 6361      modo configurac
1a002c58:	6f69 2e6e 0a0d 0000 6e49 7267 7365 2065     ion.....Ingrese 
1a002c68:	616c 7620 6c65 636f 6469 6461 6520 746e     la velocidad ent
1a002c78:	6572 7020 7369 206f 2079 6970 6f73 6520     re piso y piso e
1a002c88:	206e 6573 7567 646e 736f 0d3a 000a 0000     n segundos:.....
1a002c98:	6e49 7267 7365 2065 616c 7620 6c65 636f     Ingrese la veloc
1a002ca8:	6469 6461 6420 2065 7061 7265 7574 6172     idad de apertura
1a002cb8:	6f20 6320 7265 6172 6f64 6420 2065 7570      o cerrado de pu
1a002cc8:	7265 6174 2073 6e65 7320 6765 6e75 6f64     ertas en segundo
1a002cd8:	3a73 0a0d 0000 0000 6e49 7267 7365 2065     s:......Ingrese 
1a002ce8:	616c 6320 6e61 6974 6164 2064 6564 7020     la cantidad de p
1a002cf8:	7369 736f 2820 2031 2061 3032 3a29 0a0d     isos (1 a 20):..
1a002d08:	0000 0000 6e49 7267 7365 2065 616c 6320     ....Ingrese la c
1a002d18:	6e61 6974 6164 2064 6564 7320 6275 7573     antidad de subsu
1a002d28:	6c65 736f 2820 2030 2061 2935 0d3a 000a     elos (0 a 5):...
1a002d38:	0201 0804 0f03 0f0f 00ff 0000               ............

1a002d44 <periph_to_base>:
1a002d44:	0000 0005 000a 0020 0024 0009 0040 0040     ...... .$...@.@.
1a002d54:	0005 0060 00a6 0004 00c0 00c3 0002 00e0     ..`.............
1a002d64:	00e0 0001 0100 0100 0003 0120 0120 0006     .......... . ...
1a002d74:	0140 0140 000c 0142 0142 0019 0162 0162     @.@...B.B...b.b.
1a002d84:	0013 0182 0182 0012 01a2 01a2 0011 01c2     ................
1a002d94:	01c2 0010 01e2 01e2 000f 0202 0202 000e     ................
1a002da4:	0222 0222 000d 0223 0223 001c               "."...#.#...

1a002db0 <InitClkStates>:
1a002db0:	0100 0001 0909 0001 090a 0001 0701 0101     ................
1a002dc0:	0902 0001 0906 0001 090c 0101 090d 0001     ................
1a002dd0:	090e 0001 090f 0001 0910 0001 0911 0001     ................
1a002de0:	0912 0001 0913 0001 1114 0001 1119 0001     ................
1a002df0:	111a 0001 111b 0001                         ........

1a002df8 <UART_BClock>:
1a002df8:	01c2 01a2 0182 0162                         ......b.

1a002e00 <UART_PClock>:
1a002e00:	0081 0082 00a1 00a2                         ........

1a002e08 <ExtRateIn>:
1a002e08:	0000 0000                                   ....

1a002e0c <OscRateIn>:
1a002e0c:	1b00 00b7                                   ....

1a002e10 <gpioLEDBits>:
1a002e10:	0e00 0b01 0c01 0005 0105 0205               ............

1a002e1c <InitClkStates>:
1a002e1c:	0308 0001 0307 0001 0f01 0101               ............

1a002e28 <pinmuxing>:
1a002e28:	0a02 0040 0b02 0040 0c02 0040 0002 0044     ..@...@...@...D.
1a002e38:	0102 0044 0202 0044 0302 0052 0402 0052     ..D...D...R...R.
1a002e48:	0509 0052 0609 0057 0206 0057 0001 0050     ..R...W...W...P.
1a002e58:	0101 0050 0201 0050 0601 0050 0f01 00f3     ..P...P...P.....
1a002e68:	1001 00f7 1101 00f3 1201 00b3 1301 00f0     ................
1a002e78:	1401 00b3 0707 00b6 0000 00f2 0100 00b6     ................

1a002e88 <gpioPinsConfig>:
1a002e88:	0104 0200 0701 0005 0d03 0501 0100 0408     ................
1a002e98:	0002 0202 0304 0200 0403 0000 0002 0407     ................
1a002ea8:	0300 030c 0402 0905 0103 0504 0208 0403     ................
1a002eb8:	0305 0402 0504 0604 000c 0802 0b06 0300     ................
1a002ec8:	0607 0009 0503 0706 0504 060f 0004 0303     ................
1a002ed8:	0404 0200 0404 0005 0502 0604 0200 0406     ................
1a002ee8:	0408 0c05 0a04 0504 010e 0003 0a00 1401     ................
1a002ef8:	0000 010f 0012 0d00 1101 0000 010c 0010     ................
1a002f08:	0300 0707 0300 000f 0001 0100 0000 0000     ................
1a002f18:	0600 000a 0603 0806 0504 0610 0005 0403     ................
1a002f28:	0106 0300 0400 0409 0d05 0401 0000 010b     ................
1a002f38:	000f 0200 0001 0000 0104 0001 0800 0201     ................
1a002f48:	0000 0109 0006 0901 0002 0504 0200 0401     ................
1a002f58:	0105 0202 0504 0202 000a 0e00 0b02 0100     ................
1a002f68:	020b 000c 0c01 0004 0200 0400 0001 0102     ................
1a002f78:	0204 0200 0402 0003 0302 0307 0300 070b     ................
1a002f88:	0004 0c03 0507 0300 070d 0006 0e03 0102     ................
1a002f98:	0504 0401 0006 0602 0504 0200 0405 0004     ................
1a002fa8:	0402 0804 0504 040c 0409 0d05 0a04 0504     ................
1a002fb8:	010e 0005 0801 ffff                         ........
