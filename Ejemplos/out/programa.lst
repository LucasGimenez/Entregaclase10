
out/programa.elf:     file format elf32-littlearm
out/programa.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x1a001b81

Program Header:
0x70000001 off    0x00012a8c vaddr 0x1a002a8c paddr 0x1a002a8c align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010080 vaddr 0x10000080 paddr 0x10000080 align 2**16
         filesz 0x00000000 memsz 0x00000140 flags rw-
    LOAD off    0x00010000 vaddr 0x1a000000 paddr 0x1a000000 align 2**16
         filesz 0x00002a94 memsz 0x00002a94 flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x1a002a94 align 2**16
         filesz 0x0000007c memsz 0x0000007c flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002a8c  1a000000  1a000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000007c  10000000  1a002a94  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2    00000000  10080000  10080000  0002007c  2**2
                  CONTENTS
  3 .data_RAM3    00000000  20000000  20000000  0002007c  2**2
                  CONTENTS
  4 .data_RAM4    00000000  20008000  20008000  0002007c  2**2
                  CONTENTS
  5 .data_RAM5    00000000  2000c000  2000c000  0002007c  2**2
                  CONTENTS
  6 .bss          00000140  10000080  10000080  00010080  2**3
                  ALLOC
  7 .bss_RAM2     00000000  10080000  10080000  0002007c  2**2
                  CONTENTS
  8 .bss_RAM3     00000000  20000000  20000000  0002007c  2**2
                  CONTENTS
  9 .bss_RAM4     00000000  20008000  20008000  0002007c  2**2
                  CONTENTS
 10 .bss_RAM5     00000000  2000c000  2000c000  0002007c  2**2
                  CONTENTS
 11 .ARM.exidx    00000008  1a002a8c  1a002a8c  00012a8c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .uninit_RESERVED 00000000  10000000  10000000  0002007c  2**2
                  CONTENTS
 13 .noinit_RAM2  00000000  10080000  10080000  0002007c  2**2
                  CONTENTS
 14 .noinit_RAM3  00000000  20000000  20000000  0002007c  2**2
                  CONTENTS
 15 .noinit_RAM4  00000000  20008000  20008000  0002007c  2**2
                  CONTENTS
 16 .noinit_RAM5  00000000  2000c000  2000c000  0002007c  2**2
                  CONTENTS
 17 .noinit       00000000  100001c0  100001c0  0002007c  2**2
                  CONTENTS
 18 .debug_info   000173d2  00000000  00000000  0002007c  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 0000378f  00000000  00000000  0003744e  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_loc    000048e2  00000000  00000000  0003abdd  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_aranges 00000728  00000000  00000000  0003f4bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_ranges 00000670  00000000  00000000  0003fbe7  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_macro  0000aa2e  00000000  00000000  00040257  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_line   0000b4d5  00000000  00000000  0004ac85  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_str    0001c940  00000000  00000000  0005615a  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .comment      0000007f  00000000  00000000  00072a9a  2**0
                  CONTENTS, READONLY
 27 .ARM.attributes 00000039  00000000  00000000  00072b19  2**0
                  CONTENTS, READONLY
 28 .debug_frame  00001068  00000000  00000000  00072b54  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
1a000000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
10080000 l    d  .data_RAM2	00000000 .data_RAM2
20000000 l    d  .data_RAM3	00000000 .data_RAM3
20008000 l    d  .data_RAM4	00000000 .data_RAM4
2000c000 l    d  .data_RAM5	00000000 .data_RAM5
10000080 l    d  .bss	00000000 .bss
10080000 l    d  .bss_RAM2	00000000 .bss_RAM2
20000000 l    d  .bss_RAM3	00000000 .bss_RAM3
20008000 l    d  .bss_RAM4	00000000 .bss_RAM4
2000c000 l    d  .bss_RAM5	00000000 .bss_RAM5
1a002a8c l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
10080000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
20000000 l    d  .noinit_RAM3	00000000 .noinit_RAM3
20008000 l    d  .noinit_RAM4	00000000 .noinit_RAM4
2000c000 l    d  .noinit_RAM5	00000000 .noinit_RAM5
100001c0 l    d  .noinit	00000000 .noinit
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 cr_startup_lpc43xx.c
00000000 l    df *ABS*	00000000 sapi_uart.c
00000000 l    df *ABS*	00000000 crp.c
00000000 l    df *ABS*	00000000 Ascensor.c
00000000 l    df *ABS*	00000000 MEFAscensorPuertas.c
00000000 l    df *ABS*	00000000 MEF_tecladoMatricial.c
10000090 l     O .bss	00000018 delayAntirebote.11880
100000a8 l     O .bss	00000001 flagEstadoApretandoTecla.11881
1a002548 l     O .text	00000020 pinesTeclado
00000000 l    df *ABS*	00000000 Test.c
00000000 l    df *ABS*	00000000 driverDisplay.c
00000000 l    df *ABS*	00000000 chip_18xx_43xx.c
00000000 l    df *ABS*	00000000 clock_18xx_43xx.c
1a001160 l     F .text	000000a0 pll_calc_divs
1a001200 l     F .text	00000100 pll_get_frac
1a001300 l     F .text	0000004c Chip_Clock_FindBaseClock
1a001574 l     F .text	00000022 Chip_Clock_GetDivRate
100000c4 l     O .bss	00000008 audio_usb_pll_freq
1a002810 l     O .text	0000006c periph_to_base
00000000 l    df *ABS*	00000000 fpu_init.c
00000000 l    df *ABS*	00000000 gpio_18xx_43xx.c
00000000 l    df *ABS*	00000000 sysinit_18xx_43xx.c
1a00287c l     O .text	00000048 InitClkStates
00000000 l    df *ABS*	00000000 uart_18xx_43xx.c
1a001880 l     F .text	0000002c Chip_UART_GetIndex
1a0028c4 l     O .text	00000008 UART_BClock
1a0028cc l     O .text	00000008 UART_PClock
00000000 l    df *ABS*	00000000 board.c
1a001a28 l     F .text	00000044 Board_LED_Init
1a0028dc l     O .text	0000000c gpioLEDBits
00000000 l    df *ABS*	00000000 board_sysinit.c
1a0028e8 l     O .text	0000000c InitClkStates
1a0028f4 l     O .text	00000060 pinmuxing
00000000 l    df *ABS*	00000000 sysinit.c
00000000 l    df *ABS*	00000000 sapi_board.c
00000000 l    df *ABS*	00000000 sapi_datatypes.c
00000000 l    df *ABS*	00000000 sapi_delay.c
00000000 l    df *ABS*	00000000 sapi_gpio.c
1a001d5c l     F .text	00000034 gpioObtainPinConfig
00000000 l    df *ABS*	00000000 sapi_tick.c
00000000 l    df *ABS*	00000000 sapi_timer.c
1a00206c l     F .text	00000002 errorOcurred
1a00206e l     F .text	00000002 doNothing
1000003c l     O .data	00000040 timer_dd
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 
1a000300 l       .text	00000000 __CRP_WORD_END__
1a0002fc l       .text	00000000 __CRP_WORD_START__
1a001398 g     F .text	0000001c Chip_Clock_GetDividerSource
1a000a5c g     F .text	00000090 ingresarDigito
1a0020f0 g     F .text	00000044 TIMER2_IRQHandler
1a000184  w    F .text	00000002 DebugMon_Handler
1a00018a  w    F .text	00000002 RIT_IRQHandler
1a080000 g       *ABS*	00000000 __top_MFlashA512
1a00018a  w    F .text	00000002 ADCHS_IRQHandler
1a000114 g       .text	00000000 __section_table_start
100000ba g     O .bss	00000002 primerDigito
1a00018a  w    F .text	00000002 FLASH_EEPROM_IRQHandler
1a00018a  w    F .text	00000002 I2C0_IRQHandler
1a001702 g     F .text	00000024 Chip_GPIO_SetDir
1a0007b0 g     F .text	00000114 ActualizaMEFPuerta
1a001d1c g     F .text	0000003e delayRead
1a00017a  w    F .text	00000002 HardFault_Handler
1a000000 g       *ABS*	00000000 __vectors_start__
1a002048 g     F .text	00000024 SysTick_Handler
100000c0 g     O .bss	00000001 secuenciaB
1a001900 g     F .text	00000040 Chip_UART_SetBaud
10000170 g     O .bss	00000001 estadoMefScanTeclado
1a00018a  w    F .text	00000002 SDIO_IRQHandler
1a00018a  w    F .text	00000002 ATIMER_IRQHandler
1000019c g     O .bss	0000000a numeroEnString
1a000186  w    F .text	00000002 PendSV_Handler
1a000178  w    F .text	00000002 NMI_Handler
1a002a94 g       .ARM.exidx	00000000 __exidx_end
1a000150 g       .text	00000000 __data_section_table_end
1a00018a  w    F .text	00000002 I2C1_IRQHandler
100000e8 g     O .bss	00000018 timAbreCierraPuerta
1a000d00 g     F .text	00000200 EstadoInterno
1a00018a  w    F .text	00000002 UART1_IRQHandler
1a00018a  w    F .text	00000002 GPIO5_IRQHandler
1a00018a  w    F .text	00000002 CAN1_IRQHandler
10000010 g     O .data	0000001b numeroadisplayB
53ff5d0e g       *ABS*	00000000 __valid_user_code_checksum
1a002a94 g       .ARM.exidx	00000000 _etext
100000a9 g     O .bss	00000001 hayTeclaDisponible
1a00018a  w    F .text	00000002 USB1_IRQHandler
10000087 g     O .bss	00000001 pisoDestino
1a00018a  w    F .text	00000002 I2S0_IRQHandler
1a0008fc g     F .text	0000001c inicializarMEF_tecladoMatrical
10000080 g     O .bss	00000004 flag1DW
10000100 g     O .bss	00000018 timRetornoPB
1a002134 g     F .text	00000044 TIMER3_IRQHandler
1a001616 g     F .text	0000000c Chip_Clock_GetBaseClocktHz
1a0001bc g     F .text	00000002 UART0_IRQHandler
1a0001aa g     F .text	00000012 bss_init
1a00018a  w    F .text	00000002 SGPIO_IRQHandler
10000084 g     O .bss	00000001 flagConfiguracion
1a002228 g     F .text	00000000 .hidden __aeabi_uldivmod
100001c0 g       .noinit	00000000 _noinit
1a00220c g     F .text	00000018 uartWriteString
100001a8 g     O .bss	00000004 SystemCoreClock
1a0018ac g     F .text	00000054 Chip_UART_Init
1a00018a  w    F .text	00000002 ADC0_IRQHandler
1a001cfc g     F .text	00000020 delayConfig
100000be g     O .bss	00000001 centenasB
1a000180  w    F .text	00000002 UsageFault_Handler
100000ac g     O .bss	00000004 indice
1a001660 g     F .text	0000004c Chip_Clock_GetRate
1a00018a  w    F .text	00000002 GPIO6_IRQHandler
10000171 g     O .bss	00000001 estadoMefTecladoMatricial
100000b4 g     O .bss	00000004 indiceTeclaPresionada
100001b0 g     O .bss	00000008 tickCounter
1a001b08 g     F .text	0000006c Board_SetupClocking
20008000 g       *ABS*	00000000 __top_RamAHB32
1a000c64 g     F .text	00000068 itoa
1a002258 g     F .text	000002dc .hidden __udivmoddi4
1a0028d4 g     O .text	00000004 ExtRateIn
1a00018a  w    F .text	00000002 IntDefaultHandler
10000118 g     O .bss	00000001 estadoActualAsc
1a00018a  w    F .text	00000002 GPIO1_IRQHandler
1a001fc4 g     F .text	00000078 tickConfig
1a00018a  w    F .text	00000002 SSP0_IRQHandler
1a001d90 g     F .text	00000174 gpioConfig
100000bc g     O .bss	00000002 segundoDigito
1a002a8c g       .text	00000000 __exidx_start
1a0002fc g     O .text	00000004 CRP_WORD
10000086 g     O .bss	00000001 pisoActual
1a00018a  w    F .text	00000002 ADC1_IRQHandler
10000002 g     O .data	00000002 velPisoPiso
1a001aa8 g     F .text	00000028 Board_Init
10000004 g     O .data	00000004 pinesColumna
1a000114 g       .text	00000000 __data_section_table
1a00018a  w    F .text	00000002 RTC_IRQHandler
100001c0 g       .bss	00000000 _ebss
1a002070 g     F .text	00000040 TIMER0_IRQHandler
20010000 g       *ABS*	00000000 __top_RamAHB_ETB16
1a00018a  w    F .text	00000002 SPI_IRQHandler
10000120 g     O .bss	00000018 timPisoPiso
1a000aec g     F .text	0000004c guardarPisoSimple
1a00018a  w    F .text	00000002 LCD_IRQHandler
1a00134c g     F .text	0000004c Chip_Clock_EnableCrystal
1a001c08 g     F .text	000000ee boardConfig
1a000b38 g     F .text	00000070 guardarPisoDoble
10008000 g       *ABS*	00000000 __top_RamLoc32
1a000f48 g     F .text	0000005c SacaDigito
1a00018c g     F .text	0000001e data_init
10000088 g     O .bss	00000002 confirmar
10000138 g     O .bss	00000001 estadoActualPuerta
1a0020b0 g     F .text	00000040 TIMER1_IRQHandler
1a002224 g     F .text	00000002 UART2_IRQHandler
1a001508 g     F .text	0000006c Chip_Clock_GetMainPLLHz
1a001cf6 g     F .text	00000004 sAPI_NullFuncPtr
1a0021dc g     F .text	00000030 uartWriteByte
1a001fae g     F .text	00000016 gpioToggle
1a00018a  w    F .text	00000002 GPIO2_IRQHandler
1a0015f0 g     F .text	00000026 Chip_Clock_GetBaseClock
1a0003a8 g     F .text	00000038 InicializarMEFAsc
10000080 g       .bss	00000000 _bss
1a00018a  w    F .text	00000002 I2S1_IRQHandler
1a000300 g     F .text	0000000a IntTimer
1a001700 g     F .text	00000002 Chip_GPIO_Init
1a0028d8 g     O .text	00000004 OscRateIn
100001c0 g       .noinit	00000000 _end_noinit
10008000 g       *ABS*	00000000 _vStackTop
1a00018a  w    F .text	00000002 SSP1_IRQHandler
1a000178 g       .text	00000000 __bss_section_table_end
1a0009ac g     F .text	000000b0 ActualizaMEFScanTecla
1a002534  w    F .text	00000002 .hidden __aeabi_ldiv0
1a00018a  w    F .text	00000002 USB0_IRQHandler
1a00018a  w    F .text	00000002 GPIO3_IRQHandler
1a00018a  w    F .text	00000002 SCT_IRQHandler
1a0013b4 g     F .text	0000001c Chip_Clock_GetDividerDivisor
100000c1 g     O .bss	00000001 unidadesB
1000002c g     O .data	00000004 quedisplayB
1a000ba8 g     F .text	000000bc actualizarMEF_tecladoMatricial
1a002538 g     F .text	00000010 memset
1a00017c  w    F .text	00000002 MemManage_Handler
1a00030c g     F .text	0000009c main
1a00018a  w    F .text	00000002 WDT_IRQHandler
2000c000 g       *ABS*	00000000 __top_RamAHB16
1008a000 g       *ABS*	00000000 __top_RamLoc40
1a000182  w    F .text	00000002 SVC_Handler
1a000434 g     F .text	00000064 CargaNuevoPiso
10000140 g     O .bss	00000018 timAlarPuerta
1a0008c4 g     F .text	00000038 configurarTecladoMatricial
1a00018a  w    F .text	00000002 GPIO7_IRQHandler
1a001624 g     F .text	0000003c Chip_Clock_EnableOpts
100000b8 g     O .bss	00000002 key
1a002954 g     O .text	00000136 gpioPinsConfig
1a000498 g     F .text	00000318 ActualizarMEFAsc
1a0003e0 g     F .text	00000054 InicializarMEFPuerta
1a0013d0 g     F .text	000000b8 Chip_Clock_GetClockInputHz
1a0016ac g     F .text	00000054 fpuInit
1a001488 g     F .text	00000080 Chip_Clock_CalcMainPLLValue
1a001bfc g     F .text	0000000c SystemInit
1a00018a  w    F .text	00000002 SPIFI_IRQHandler
1a00018a  w    F .text	00000002 QEI_IRQHandler
10000174 g     O .bss	00000028 almacenarPisos
1a000150 g       .text	00000000 __bss_section_table
1a001f04 g     F .text	00000056 gpioWrite
1a001ad0 g     F .text	00000038 Board_SetupMuxing
1a001940 g     F .text	000000e8 Chip_UART_SetBaudFDR
1a00203c g     F .text	0000000c tickRead
100001b8 g     O .bss	00000008 tickRateMS
10000030 g     O .data	00000008 segmentosdisplayB
1a00018a  w    F .text	00000002 ETH_IRQHandler
10000038 g     O .data	00000004 tickHookFunction
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
10000085 g     O .bss	00000001 pideConfiguracion
1a00018a  w    F .text	00000002 CAN0_IRQHandler
1a000918 g     F .text	00000094 ScanTeclas
10000000 g       .data	00000000 _data
1a000ccc g     F .text	00000034 uartWriteMiDato
100001c0 g       .bss	00000000 _pvHeapStart
1a000178 g       .text	00000000 __section_table_end
1a002178 g     F .text	00000064 uartConfig
1a00018a  w    F .text	00000002 GINT0_IRQHandler
100000c2 g     O .bss	00000001 unidadesmilB
1a000fe4 g     F .text	00000168 PonPisoActualDisplay
1a00018a  w    F .text	00000002 DAC_IRQHandler
1a001a80 g     F .text	00000028 Board_Debug_Init
1000007c g       .data	00000000 _edata
1a00018a  w    F .text	00000002 M0SUB_IRQHandler
1000000c g     O .data	00000002 teclaPresionada
10000008 g     O .data	00000004 pinesFila
1a001728 g     F .text	00000158 Chip_SetupCoreClock
1a00018a  w    F .text	00000002 GPIO0_IRQHandler
1a000000 g     O .text	00000114 g_pfnVectors
1a001b80 g     F .text	0000007c ResetISR
1a00114c g     F .text	00000014 SystemCoreClockUpdate
1a00018a  w    F .text	00000002 DMA_IRQHandler
1a00018a  w    F .text	00000002 EVRT_IRQHandler
1b080000 g       *ABS*	00000000 __top_MFlashB512
10000158 g     O .bss	00000018 timPuertaAbierta
100000b0 g     O .bss	00000004 indiceTeclaGuardar
1a002534  w    F .text	00000002 .hidden __aeabi_idiv0
1a00017e  w    F .text	00000002 BusFault_Handler
1a002226 g     F .text	00000002 UART3_IRQHandler
1a00018a  w    F .text	00000002 MCPWM_IRQHandler
1a00018a  w    F .text	00000002 M0APP_IRQHandler
1a001f5a g     F .text	00000054 gpioRead
100000d0 g     O .bss	00000018 timSerial
1a000fa4 g     F .text	00000040 ConvierteByte
1a00018a  w    F .text	00000002 GINT1_IRQHandler
1a001a6c g     F .text	00000014 Board_UART_Init
1a000f00 g     F .text	00000048 ConfigDisplay
1a001598 g     F .text	00000058 Chip_Clock_SetBaseClock
1a00018a  w    F .text	00000002 GPIO4_IRQHandler
10000000 g     O .data	00000002 velAbreCierraPuerta
1a001b74 g     F .text	0000000c Board_SystemInit
100000bf g     O .bss	00000001 decenasB



Disassembly of section .text:

1a000000 <g_pfnVectors>:
1a000000:	00 80 00 10 81 1b 00 1a 79 01 00 1a 7b 01 00 1a     ........y...{...
1a000010:	7d 01 00 1a 7f 01 00 1a 81 01 00 1a 0e 5d ff 53     }............].S
	...
1a00002c:	83 01 00 1a 85 01 00 1a 00 00 00 00 87 01 00 1a     ................
1a00003c:	49 20 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     I ..............
1a00004c:	00 00 00 00 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00005c:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00006c:	8b 01 00 1a 71 20 00 1a b1 20 00 1a f1 20 00 1a     ....q ... ... ..
1a00007c:	35 21 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     5!..............
1a00008c:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a00009c:	8b 01 00 1a bd 01 00 1a 8b 01 00 1a 25 22 00 1a     ............%"..
1a0000ac:	27 22 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     '"..............
1a0000bc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000cc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000dc:	8b 01 00 1a 8b 01 00 1a 8b 01 00 1a 8b 01 00 1a     ................
1a0000ec:	8b 01 00 1a 00 00 00 00 8b 01 00 1a 8b 01 00 1a     ................
1a0000fc:	8b 01 00 1a 00 00 00 00 8b 01 00 1a 8b 01 00 1a     ................
1a00010c:	8b 01 00 1a 8b 01 00 1a                             ........

1a000114 <__data_section_table>:
1a000114:	1a002a94 	.word	0x1a002a94
1a000118:	10000000 	.word	0x10000000
1a00011c:	0000007c 	.word	0x0000007c
1a000120:	1a002a94 	.word	0x1a002a94
1a000124:	10080000 	.word	0x10080000
1a000128:	00000000 	.word	0x00000000
1a00012c:	1a002a94 	.word	0x1a002a94
1a000130:	20000000 	.word	0x20000000
1a000134:	00000000 	.word	0x00000000
1a000138:	1a002a94 	.word	0x1a002a94
1a00013c:	20008000 	.word	0x20008000
1a000140:	00000000 	.word	0x00000000
1a000144:	1a002a94 	.word	0x1a002a94
1a000148:	2000c000 	.word	0x2000c000
1a00014c:	00000000 	.word	0x00000000

1a000150 <__bss_section_table>:
1a000150:	10000080 	.word	0x10000080
1a000154:	00000140 	.word	0x00000140
1a000158:	10080000 	.word	0x10080000
1a00015c:	00000000 	.word	0x00000000
1a000160:	20000000 	.word	0x20000000
1a000164:	00000000 	.word	0x00000000
1a000168:	20008000 	.word	0x20008000
1a00016c:	00000000 	.word	0x00000000
1a000170:	2000c000 	.word	0x2000c000
1a000174:	00000000 	.word	0x00000000

1a000178 <NMI_Handler>:
//*****************************************************************************
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void) {
1a000178:	e7fe      	b.n	1a000178 <NMI_Handler>

1a00017a <HardFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void) {
1a00017a:	e7fe      	b.n	1a00017a <HardFault_Handler>

1a00017c <MemManage_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void MemManage_Handler(void) {
1a00017c:	e7fe      	b.n	1a00017c <MemManage_Handler>

1a00017e <BusFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void BusFault_Handler(void) {
1a00017e:	e7fe      	b.n	1a00017e <BusFault_Handler>

1a000180 <UsageFault_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void UsageFault_Handler(void) {
1a000180:	e7fe      	b.n	1a000180 <UsageFault_Handler>

1a000182 <SVC_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void) {
1a000182:	e7fe      	b.n	1a000182 <SVC_Handler>

1a000184 <DebugMon_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void DebugMon_Handler(void) {
1a000184:	e7fe      	b.n	1a000184 <DebugMon_Handler>

1a000186 <PendSV_Handler>:
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void) {
1a000186:	e7fe      	b.n	1a000186 <PendSV_Handler>
    while (1) {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void) {
1a000188:	e7fe      	b.n	1a000188 <PendSV_Handler+0x2>

1a00018a <ADC0_IRQHandler>:
// Processor ends up here if an unexpected interrupt occurs or a specific
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void) {
1a00018a:	e7fe      	b.n	1a00018a <ADC0_IRQHandler>

1a00018c <data_init>:
    for (loop = 0; loop < len; loop = loop + 4)
1a00018c:	2300      	movs	r3, #0
1a00018e:	4293      	cmp	r3, r2
1a000190:	d20a      	bcs.n	1a0001a8 <data_init+0x1c>
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
1a000192:	b410      	push	{r4}
        *pulDest++ = *pulSrc++;
1a000194:	6804      	ldr	r4, [r0, #0]
1a000196:	600c      	str	r4, [r1, #0]
    for (loop = 0; loop < len; loop = loop + 4)
1a000198:	3304      	adds	r3, #4
        *pulDest++ = *pulSrc++;
1a00019a:	3004      	adds	r0, #4
1a00019c:	3104      	adds	r1, #4
    for (loop = 0; loop < len; loop = loop + 4)
1a00019e:	4293      	cmp	r3, r2
1a0001a0:	d3f8      	bcc.n	1a000194 <data_init+0x8>
}
1a0001a2:	f85d 4b04 	ldr.w	r4, [sp], #4
1a0001a6:	4770      	bx	lr
1a0001a8:	4770      	bx	lr

1a0001aa <bss_init>:
    for (loop = 0; loop < len; loop = loop + 4)
1a0001aa:	2300      	movs	r3, #0
1a0001ac:	e003      	b.n	1a0001b6 <bss_init+0xc>
        *pulDest++ = 0;
1a0001ae:	2200      	movs	r2, #0
1a0001b0:	6002      	str	r2, [r0, #0]
    for (loop = 0; loop < len; loop = loop + 4)
1a0001b2:	3304      	adds	r3, #4
        *pulDest++ = 0;
1a0001b4:	3004      	adds	r0, #4
    for (loop = 0; loop < len; loop = loop + 4)
1a0001b6:	428b      	cmp	r3, r1
1a0001b8:	d3f9      	bcc.n	1a0001ae <bss_init+0x4>
}
1a0001ba:	4770      	bx	lr

1a0001bc <UART0_IRQHandler>:
/*==================[ISR external functions definition]======================*/

__attribute__ ((section(".after_vectors")))

/* 0x28 0x000000A0 - Handler for ISR UART0 (IRQ 24) */
void UART0_IRQHandler(void){
1a0001bc:	4770      	bx	lr
1a0001be:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001c2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001c6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ce:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001d2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001d6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001da:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001de:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ea:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ee:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001fa:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001fe:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000202:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000206:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00020a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00020e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000212:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000216:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00021a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00021e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000222:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000226:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00022a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00022e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000232:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000236:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00023a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00023e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000242:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000246:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00024a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00024e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000252:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000256:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00025a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00025e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000262:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000266:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00026a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00026e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000272:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000276:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00027a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00027e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000282:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000286:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00028a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00028e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000292:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000296:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00029a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00029e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002aa:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ae:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ba:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002be:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ce:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002da:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002de:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ea:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ee:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002fa:	Address 0x1a0002fa is out of bounds.


1a0002fc <CRP_WORD>:
1a0002fc:	ffff ffff                                   ....

1a000300 <IntTimer>:

//*************************************************************************************************
//			Interrupci贸n cada 5ms
//*************************************************************************************************
bool_t IntTimer (void *ptr)
{
1a000300:	b508      	push	{r3, lr}

PonPisoActualDisplay();
1a000302:	f000 fe6f 	bl	1a000fe4 <PonPisoActualDisplay>
	

return 1;
}
1a000306:	2001      	movs	r0, #1
1a000308:	bd08      	pop	{r3, pc}
1a00030a:	Address 0x1a00030a is out of bounds.


1a00030c <main>:


/*==================[funcion principal]======================================*/

// FUNCION PRINCIPAL, PUNTO DE ENTRADA AL PROGRAMA LUEGO DE ENCENDIDO O RESET.
int main( void ){
1a00030c:	b508      	push	{r3, lr}

// ---------- CONFIGURACIONES ------------------------------
// Inicializar y configurar la plataforma
boardConfig();   
1a00030e:	f001 fc7b 	bl	1a001c08 <boardConfig>

// Interupcion cada 5ms.
tickConfig (5, IntTimer);
1a000312:	4a21      	ldr	r2, [pc, #132]	; (1a000398 <main+0x8c>)
1a000314:	2005      	movs	r0, #5
1a000316:	2100      	movs	r1, #0
1a000318:	f001 fe54 	bl	1a001fc4 <tickConfig>

ConfigDisplay(); // Configuraci贸n de pines para el display 7 segmentos
1a00031c:	f000 fdf0 	bl	1a000f00 <ConfigDisplay>


//configurarTeclado(); // Configurar teclado matricial
inicializarMEF_tecladoMatrical();
1a000320:	f000 faec 	bl	1a0008fc <inicializarMEF_tecladoMatrical>


// Se inicializa la MEF que maneja el ascensor.
InicializarMEFAsc();
1a000324:	f000 f840 	bl	1a0003a8 <InicializarMEFAsc>

// Se inicializa la MEF que maneja la puerta del ascensor.
InicializarMEFPuerta();
1a000328:	f000 f85a 	bl	1a0003e0 <InicializarMEFPuerta>



// UART_USB a 115200 baudios.
uartConfig( UART_USB, 115200 );
1a00032c:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
1a000330:	2000      	movs	r0, #0
1a000332:	f001 ff21 	bl	1a002178 <uartConfig>
delayConfig(&timSerial, 100);   
1a000336:	2264      	movs	r2, #100	; 0x64
1a000338:	2300      	movs	r3, #0
1a00033a:	4818      	ldr	r0, [pc, #96]	; (1a00039c <main+0x90>)
1a00033c:	f001 fcde 	bl	1a001cfc <delayConfig>
// ---------- REPETIR POR SIEMPRE --------------------------
while(TRUE)
{      

// Funci贸n Actualizar MEF del Teclado.
actualizarMEF_tecladoMatricial();
1a000340:	f000 fc32 	bl	1a000ba8 <actualizarMEF_tecladoMatricial>


// Funci贸n Actualizar MEF del Ascensor.
ActualizarMEFAsc();
1a000344:	f000 f8a8 	bl	1a000498 <ActualizarMEFAsc>


// Funci贸n Actualizar MEF de las Puertas.
ActualizaMEFPuerta();
1a000348:	f000 fa32 	bl	1a0007b0 <ActualizaMEFPuerta>


if (delayRead(&timSerial))
1a00034c:	4813      	ldr	r0, [pc, #76]	; (1a00039c <main+0x90>)
1a00034e:	f001 fce5 	bl	1a001d1c <delayRead>
1a000352:	2800      	cmp	r0, #0
1a000354:	d0f4      	beq.n	1a000340 <main+0x34>
	{
	EstadoInterno();
1a000356:	f000 fcd3 	bl	1a000d00 <EstadoInterno>
	
	if (!gpioRead(TEC4))
1a00035a:	2027      	movs	r0, #39	; 0x27
1a00035c:	f001 fdfd 	bl	1a001f5a <gpioRead>
1a000360:	2800      	cmp	r0, #0
1a000362:	d1ed      	bne.n	1a000340 <main+0x34>
		{
//		pideNuevoPiso = 1;
//		pisoDestino = 5;
		almacenarPisos[0] = 6;
1a000364:	4b0e      	ldr	r3, [pc, #56]	; (1a0003a0 <main+0x94>)
1a000366:	2206      	movs	r2, #6
1a000368:	601a      	str	r2, [r3, #0]
		almacenarPisos[1] = 9;
1a00036a:	2209      	movs	r2, #9
1a00036c:	605a      	str	r2, [r3, #4]
		almacenarPisos[2] = 12;
1a00036e:	220c      	movs	r2, #12
1a000370:	609a      	str	r2, [r3, #8]
		almacenarPisos[3] = 17;
1a000372:	2211      	movs	r2, #17
1a000374:	60da      	str	r2, [r3, #12]
		almacenarPisos[4] = 20;
1a000376:	2214      	movs	r2, #20
1a000378:	611a      	str	r2, [r3, #16]
		almacenarPisos[5] = 10;
1a00037a:	220a      	movs	r2, #10
1a00037c:	615a      	str	r2, [r3, #20]
		almacenarPisos[6] = -5;
1a00037e:	f06f 0104 	mvn.w	r1, #4
1a000382:	6199      	str	r1, [r3, #24]
		almacenarPisos[7] = 5;
1a000384:	2105      	movs	r1, #5
1a000386:	61d9      	str	r1, [r3, #28]
		almacenarPisos[8] = -3;
1a000388:	f06f 0102 	mvn.w	r1, #2
1a00038c:	6219      	str	r1, [r3, #32]
		almacenarPisos[9] = 8;
1a00038e:	2108      	movs	r1, #8
1a000390:	6259      	str	r1, [r3, #36]	; 0x24
		indice = 10;
1a000392:	4b04      	ldr	r3, [pc, #16]	; (1a0003a4 <main+0x98>)
1a000394:	601a      	str	r2, [r3, #0]
1a000396:	e7d3      	b.n	1a000340 <main+0x34>
1a000398:	1a000301 	.word	0x1a000301
1a00039c:	100000d0 	.word	0x100000d0
1a0003a0:	10000174 	.word	0x10000174
1a0003a4:	100000ac 	.word	0x100000ac

1a0003a8 <InicializarMEFAsc>:

//*********************************************************************************************************************
//		Funcin inicializar MEF del ascensor
//*********************************************************************************************************************
void InicializarMEFAsc(void)
{
1a0003a8:	b508      	push	{r3, lr}
// Estado inicial.
estadoActualAsc = EN_PLANTA_BAJA;
1a0003aa:	2200      	movs	r2, #0
1a0003ac:	4b08      	ldr	r3, [pc, #32]	; (1a0003d0 <InicializarMEFAsc+0x28>)
1a0003ae:	701a      	strb	r2, [r3, #0]
gpioWrite (LED_PBDETENIDO, 1);
1a0003b0:	2101      	movs	r1, #1
1a0003b2:	202d      	movs	r0, #45	; 0x2d
1a0003b4:	f001 fda6 	bl	1a001f04 <gpioWrite>


// Se Configura el tiempo de desplazamiento del ascensor.
delayConfig(&timPisoPiso, velPisoPiso);   
1a0003b8:	4b06      	ldr	r3, [pc, #24]	; (1a0003d4 <InicializarMEFAsc+0x2c>)
1a0003ba:	881a      	ldrh	r2, [r3, #0]
1a0003bc:	2300      	movs	r3, #0
1a0003be:	4806      	ldr	r0, [pc, #24]	; (1a0003d8 <InicializarMEFAsc+0x30>)
1a0003c0:	f001 fc9c 	bl	1a001cfc <delayConfig>

// Se Configura el tiempo de espera para retornar a la PB.
//delayConfig(&timRetornoPB, TRETORNOPB);   

// Resetea flag que indica ejecucion unica de bloque dentro de estado PARADO.
Clr_AscParadoFlag;
1a0003c4:	4a05      	ldr	r2, [pc, #20]	; (1a0003dc <InicializarMEFAsc+0x34>)
1a0003c6:	6813      	ldr	r3, [r2, #0]
1a0003c8:	f023 0301 	bic.w	r3, r3, #1
1a0003cc:	6013      	str	r3, [r2, #0]
1a0003ce:	bd08      	pop	{r3, pc}
1a0003d0:	10000118 	.word	0x10000118
1a0003d4:	10000002 	.word	0x10000002
1a0003d8:	10000120 	.word	0x10000120
1a0003dc:	10000080 	.word	0x10000080

1a0003e0 <InicializarMEFPuerta>:

//*********************************************************************************************************************
//		Funcin inicializar MEF de la puerta del ascensor
//*********************************************************************************************************************
void InicializarMEFPuerta(void)
{
1a0003e0:	b508      	push	{r3, lr}
// Estado inicial.
estadoActualPuerta = PUERTA_CERRADA;
1a0003e2:	2200      	movs	r2, #0
1a0003e4:	4b0d      	ldr	r3, [pc, #52]	; (1a00041c <InicializarMEFPuerta+0x3c>)
1a0003e6:	701a      	strb	r2, [r3, #0]

// Se Configura el tiempo para el parpadeo del led de alarma indicador de puerta abierta, 0,5seg.
delayConfig(&timAlarPuerta, TALARMAPUERTA);   
1a0003e8:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
1a0003ec:	2300      	movs	r3, #0
1a0003ee:	480c      	ldr	r0, [pc, #48]	; (1a000420 <InicializarMEFPuerta+0x40>)
1a0003f0:	f001 fc84 	bl	1a001cfc <delayConfig>

// Se configura tiempo de apertura de la puerta.
delayConfig(&timAbreCierraPuerta, velAbreCierraPuerta);   
1a0003f4:	4b0b      	ldr	r3, [pc, #44]	; (1a000424 <InicializarMEFPuerta+0x44>)
1a0003f6:	881a      	ldrh	r2, [r3, #0]
1a0003f8:	2300      	movs	r3, #0
1a0003fa:	480b      	ldr	r0, [pc, #44]	; (1a000428 <InicializarMEFPuerta+0x48>)
1a0003fc:	f001 fc7e 	bl	1a001cfc <delayConfig>

// Se configura tiempo que queda la puerta abierta.
delayConfig(&timPuertaAbierta, TPUETAABIERTA);   
1a000400:	f241 3288 	movw	r2, #5000	; 0x1388
1a000404:	2300      	movs	r3, #0
1a000406:	4809      	ldr	r0, [pc, #36]	; (1a00042c <InicializarMEFPuerta+0x4c>)
1a000408:	f001 fc78 	bl	1a001cfc <delayConfig>

// Se configura tiempo que espera antes de retornar a Planta Baja.
delayConfig(&timRetornoPB, TRETORNOPB);
1a00040c:	f242 7210 	movw	r2, #10000	; 0x2710
1a000410:	2300      	movs	r3, #0
1a000412:	4807      	ldr	r0, [pc, #28]	; (1a000430 <InicializarMEFPuerta+0x50>)
1a000414:	f001 fc72 	bl	1a001cfc <delayConfig>
1a000418:	bd08      	pop	{r3, pc}
1a00041a:	bf00      	nop
1a00041c:	10000138 	.word	0x10000138
1a000420:	10000140 	.word	0x10000140
1a000424:	10000000 	.word	0x10000000
1a000428:	100000e8 	.word	0x100000e8
1a00042c:	10000158 	.word	0x10000158
1a000430:	10000100 	.word	0x10000100

1a000434 <CargaNuevoPiso>:
void CargaNuevoPiso(void)
{
uint8_t i ;

// Si indice es distinto de cero significa que hay algun piso cargado en el buffer.
if (indice && !Ask_PideNuevoPisoFlag)
1a000434:	4b13      	ldr	r3, [pc, #76]	; (1a000484 <CargaNuevoPiso+0x50>)
1a000436:	681b      	ldr	r3, [r3, #0]
1a000438:	b31b      	cbz	r3, 1a000482 <CargaNuevoPiso+0x4e>
1a00043a:	4a13      	ldr	r2, [pc, #76]	; (1a000488 <CargaNuevoPiso+0x54>)
1a00043c:	6812      	ldr	r2, [r2, #0]
1a00043e:	f012 0f10 	tst.w	r2, #16
1a000442:	d11e      	bne.n	1a000482 <CargaNuevoPiso+0x4e>
	{
	// Si el piso actual es distinto del piso destino, se lo fija como nuevo, si no solo se desplaza el buffer.
	if (pisoActual != almacenarPisos[0])
1a000444:	4a11      	ldr	r2, [pc, #68]	; (1a00048c <CargaNuevoPiso+0x58>)
1a000446:	f992 1000 	ldrsb.w	r1, [r2]
1a00044a:	4a11      	ldr	r2, [pc, #68]	; (1a000490 <CargaNuevoPiso+0x5c>)
1a00044c:	6812      	ldr	r2, [r2, #0]
1a00044e:	4291      	cmp	r1, r2
1a000450:	d006      	beq.n	1a000460 <CargaNuevoPiso+0x2c>
		{
		pisoDestino = almacenarPisos[0];
1a000452:	4910      	ldr	r1, [pc, #64]	; (1a000494 <CargaNuevoPiso+0x60>)
1a000454:	700a      	strb	r2, [r1, #0]
		Set_PideNuevoPisoFlag;
1a000456:	490c      	ldr	r1, [pc, #48]	; (1a000488 <CargaNuevoPiso+0x54>)
1a000458:	680a      	ldr	r2, [r1, #0]
1a00045a:	f042 0210 	orr.w	r2, r2, #16
1a00045e:	600a      	str	r2, [r1, #0]
		}
	indice--;
1a000460:	3b01      	subs	r3, #1
1a000462:	4a08      	ldr	r2, [pc, #32]	; (1a000484 <CargaNuevoPiso+0x50>)
1a000464:	6013      	str	r3, [r2, #0]
	for (i=0; i<9; i++)
1a000466:	2300      	movs	r3, #0
1a000468:	e006      	b.n	1a000478 <CargaNuevoPiso+0x44>
		almacenarPisos[i] = almacenarPisos[i+1];
1a00046a:	1c5a      	adds	r2, r3, #1
1a00046c:	4908      	ldr	r1, [pc, #32]	; (1a000490 <CargaNuevoPiso+0x5c>)
1a00046e:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
1a000472:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
	for (i=0; i<9; i++)
1a000476:	b2d3      	uxtb	r3, r2
1a000478:	2b08      	cmp	r3, #8
1a00047a:	d9f6      	bls.n	1a00046a <CargaNuevoPiso+0x36>
	almacenarPisos[9] = 0;
1a00047c:	2200      	movs	r2, #0
1a00047e:	4b04      	ldr	r3, [pc, #16]	; (1a000490 <CargaNuevoPiso+0x5c>)
1a000480:	625a      	str	r2, [r3, #36]	; 0x24
1a000482:	4770      	bx	lr
1a000484:	100000ac 	.word	0x100000ac
1a000488:	10000080 	.word	0x10000080
1a00048c:	10000086 	.word	0x10000086
1a000490:	10000174 	.word	0x10000174
1a000494:	10000087 	.word	0x10000087

1a000498 <ActualizarMEFAsc>:

//*********************************************************************************************************************
//		Funcin Actualizar MEF del Ascensor
//*********************************************************************************************************************
void ActualizarMEFAsc(void)
{
1a000498:	b510      	push	{r4, lr}


	

switch(estadoActualAsc)
1a00049a:	4ba8      	ldr	r3, [pc, #672]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a00049c:	781b      	ldrb	r3, [r3, #0]
1a00049e:	2b05      	cmp	r3, #5
1a0004a0:	f200 817c 	bhi.w	1a00079c <ActualizarMEFAsc+0x304>
1a0004a4:	e8df f013 	tbh	[pc, r3, lsl #1]
1a0004a8:	004d0006 	.word	0x004d0006
1a0004ac:	00ab007c 	.word	0x00ab007c
1a0004b0:	01760113 	.word	0x01760113
	{
	case EN_PLANTA_BAJA:
		// Se solicita la apertura de puertas, una sola vez.
		if (!Ask_PidioAperturaFlag)
1a0004b4:	4ba2      	ldr	r3, [pc, #648]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a0004b6:	681b      	ldr	r3, [r3, #0]
1a0004b8:	f013 0f08 	tst.w	r3, #8
1a0004bc:	d108      	bne.n	1a0004d0 <ActualizarMEFAsc+0x38>
			{
			Set_PidioAperturaFlag;
1a0004be:	4ba0      	ldr	r3, [pc, #640]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a0004c0:	681a      	ldr	r2, [r3, #0]
1a0004c2:	f042 0208 	orr.w	r2, r2, #8
1a0004c6:	601a      	str	r2, [r3, #0]
			Set_AbrePuertasFlag;
1a0004c8:	681a      	ldr	r2, [r3, #0]
1a0004ca:	f042 0202 	orr.w	r2, r2, #2
1a0004ce:	601a      	str	r2, [r3, #0]
			}
		// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
		CargaNuevoPiso();
1a0004d0:	f7ff ffb0 	bl	1a000434 <CargaNuevoPiso>
		
		if (Ask_PideNuevoPisoFlag)
1a0004d4:	4b9a      	ldr	r3, [pc, #616]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a0004d6:	681b      	ldr	r3, [r3, #0]
1a0004d8:	f013 0f10 	tst.w	r3, #16
1a0004dc:	d014      	beq.n	1a000508 <ActualizarMEFAsc+0x70>
			{
			if (estadoActualPuerta == PUERTA_ABIERTA)
1a0004de:	4b99      	ldr	r3, [pc, #612]	; (1a000744 <ActualizarMEFAsc+0x2ac>)
1a0004e0:	781b      	ldrb	r3, [r3, #0]
1a0004e2:	2b02      	cmp	r3, #2
1a0004e4:	d01a      	beq.n	1a00051c <ActualizarMEFAsc+0x84>
				Set_CierraPuertasFlag;			// Pide cerrar puertas.
			
			
			if (estadoActualPuerta == PUERTA_CERRADA)
1a0004e6:	b97b      	cbnz	r3, 1a000508 <ActualizarMEFAsc+0x70>
				{
				if (pisoActual < pisoDestino)
1a0004e8:	4b97      	ldr	r3, [pc, #604]	; (1a000748 <ActualizarMEFAsc+0x2b0>)
1a0004ea:	f993 2000 	ldrsb.w	r2, [r3]
1a0004ee:	4b97      	ldr	r3, [pc, #604]	; (1a00074c <ActualizarMEFAsc+0x2b4>)
1a0004f0:	f993 3000 	ldrsb.w	r3, [r3]
1a0004f4:	429a      	cmp	r2, r3
1a0004f6:	da17      	bge.n	1a000528 <ActualizarMEFAsc+0x90>
					{
					
					// El piso destino se encuentra arriba.
					estadoActualAsc = SUBIENDO;
1a0004f8:	2201      	movs	r2, #1
1a0004fa:	4b90      	ldr	r3, [pc, #576]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a0004fc:	701a      	strb	r2, [r3, #0]
					Clr_PidioAperturaFlag;
1a0004fe:	4a90      	ldr	r2, [pc, #576]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a000500:	6813      	ldr	r3, [r2, #0]
1a000502:	f023 0308 	bic.w	r3, r3, #8
1a000506:	6013      	str	r3, [r2, #0]
					}
				}
			}
		
		// Se consulta si pide modo Configuracion.
		if (pideConfiguracion)//COMPLETAR!!!
1a000508:	4b91      	ldr	r3, [pc, #580]	; (1a000750 <ActualizarMEFAsc+0x2b8>)
1a00050a:	f993 3000 	ldrsb.w	r3, [r3]
1a00050e:	2b00      	cmp	r3, #0
1a000510:	f000 8146 	beq.w	1a0007a0 <ActualizarMEFAsc+0x308>
			{
			estadoActualAsc = MODO_CONFIGURACION;
1a000514:	2205      	movs	r2, #5
1a000516:	4b89      	ldr	r3, [pc, #548]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a000518:	701a      	strb	r2, [r3, #0]
1a00051a:	bd10      	pop	{r4, pc}
				Set_CierraPuertasFlag;			// Pide cerrar puertas.
1a00051c:	4988      	ldr	r1, [pc, #544]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a00051e:	680a      	ldr	r2, [r1, #0]
1a000520:	f042 0204 	orr.w	r2, r2, #4
1a000524:	600a      	str	r2, [r1, #0]
1a000526:	e7de      	b.n	1a0004e6 <ActualizarMEFAsc+0x4e>
					Set_CierraPuertasFlag;
1a000528:	4b85      	ldr	r3, [pc, #532]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a00052a:	681a      	ldr	r2, [r3, #0]
1a00052c:	f042 0204 	orr.w	r2, r2, #4
1a000530:	601a      	str	r2, [r3, #0]
					estadoActualAsc = BAJANDO;
1a000532:	2102      	movs	r1, #2
1a000534:	4a81      	ldr	r2, [pc, #516]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a000536:	7011      	strb	r1, [r2, #0]
					Clr_PidioAperturaFlag;
1a000538:	681a      	ldr	r2, [r3, #0]
1a00053a:	f022 0208 	bic.w	r2, r2, #8
1a00053e:	601a      	str	r2, [r3, #0]
1a000540:	e7e2      	b.n	1a000508 <ActualizarMEFAsc+0x70>

		break;
			
	case SUBIENDO:
		// Se cerraron las puertas cambia de estado?
		if (estadoActualPuerta == PUERTA_CERRADA)
1a000542:	4b80      	ldr	r3, [pc, #512]	; (1a000744 <ActualizarMEFAsc+0x2ac>)
1a000544:	781b      	ldrb	r3, [r3, #0]
1a000546:	2b00      	cmp	r3, #0
1a000548:	f040 812a 	bne.w	1a0007a0 <ActualizarMEFAsc+0x308>
			{
			gpioWrite (LED_PBDETENIDO, 0);
1a00054c:	2100      	movs	r1, #0
1a00054e:	202d      	movs	r0, #45	; 0x2d
1a000550:	f001 fcd8 	bl	1a001f04 <gpioWrite>
			gpioWrite (LED_ASCMOVIENDO, 1);
1a000554:	2101      	movs	r1, #1
1a000556:	202a      	movs	r0, #42	; 0x2a
1a000558:	f001 fcd4 	bl	1a001f04 <gpioWrite>
	
			// SALIDA EN EL ESTADO:
			// Se hace subir el ascensor, demorara en subir lo configurado en "velPisoPiso".
			if (delayRead(&timPisoPiso))
1a00055c:	487d      	ldr	r0, [pc, #500]	; (1a000754 <ActualizarMEFAsc+0x2bc>)
1a00055e:	f001 fbdd 	bl	1a001d1c <delayRead>
1a000562:	2800      	cmp	r0, #0
1a000564:	f000 811c 	beq.w	1a0007a0 <ActualizarMEFAsc+0x308>
				{
				pisoActual = pisoActual + 1;
1a000568:	4a77      	ldr	r2, [pc, #476]	; (1a000748 <ActualizarMEFAsc+0x2b0>)
1a00056a:	7813      	ldrb	r3, [r2, #0]
1a00056c:	3301      	adds	r3, #1
1a00056e:	b25b      	sxtb	r3, r3
1a000570:	7013      	strb	r3, [r2, #0]
				//Se consulta si llego.
				if (pisoActual == pisoDestino)
1a000572:	4a76      	ldr	r2, [pc, #472]	; (1a00074c <ActualizarMEFAsc+0x2b4>)
1a000574:	f992 2000 	ldrsb.w	r2, [r2]
1a000578:	4293      	cmp	r3, r2
1a00057a:	f040 8111 	bne.w	1a0007a0 <ActualizarMEFAsc+0x308>
					{
					// CAMBIO DE ESTADO:
					estadoActualAsc = PARADO;
1a00057e:	2203      	movs	r2, #3
1a000580:	4b6e      	ldr	r3, [pc, #440]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a000582:	701a      	strb	r2, [r3, #0]
					Clr_PideNuevoPisoFlag;
1a000584:	4a6e      	ldr	r2, [pc, #440]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a000586:	6813      	ldr	r3, [r2, #0]
1a000588:	f023 0310 	bic.w	r3, r3, #16
1a00058c:	6013      	str	r3, [r2, #0]
					gpioWrite (LED_ASCMOVIENDO, 0);
1a00058e:	2100      	movs	r1, #0
1a000590:	202a      	movs	r0, #42	; 0x2a
1a000592:	f001 fcb7 	bl	1a001f04 <gpioWrite>
					gpioWrite (LED_PBDETENIDO, 1);
1a000596:	2101      	movs	r1, #1
1a000598:	202d      	movs	r0, #45	; 0x2d
1a00059a:	f001 fcb3 	bl	1a001f04 <gpioWrite>
1a00059e:	bd10      	pop	{r4, pc}
			}
		break;

	case BAJANDO:
		// Se cerraron las puertas cambia de estado?
		if (estadoActualPuerta == PUERTA_CERRADA)
1a0005a0:	4b68      	ldr	r3, [pc, #416]	; (1a000744 <ActualizarMEFAsc+0x2ac>)
1a0005a2:	781b      	ldrb	r3, [r3, #0]
1a0005a4:	2b00      	cmp	r3, #0
1a0005a6:	f040 80fb 	bne.w	1a0007a0 <ActualizarMEFAsc+0x308>
			{
			gpioWrite (LED_PBDETENIDO, 0);
1a0005aa:	2100      	movs	r1, #0
1a0005ac:	202d      	movs	r0, #45	; 0x2d
1a0005ae:	f001 fca9 	bl	1a001f04 <gpioWrite>
			gpioWrite (LED_ASCMOVIENDO, 1);
1a0005b2:	2101      	movs	r1, #1
1a0005b4:	202a      	movs	r0, #42	; 0x2a
1a0005b6:	f001 fca5 	bl	1a001f04 <gpioWrite>
		
			// SALIDA EN EL ESTADO:
			// Se hace bajar el ascensor, demorara en subir lo configurado en "velPisoPiso".
			if (delayRead(&timPisoPiso))
1a0005ba:	4866      	ldr	r0, [pc, #408]	; (1a000754 <ActualizarMEFAsc+0x2bc>)
1a0005bc:	f001 fbae 	bl	1a001d1c <delayRead>
1a0005c0:	2800      	cmp	r0, #0
1a0005c2:	f000 80ed 	beq.w	1a0007a0 <ActualizarMEFAsc+0x308>
				{
				pisoActual = pisoActual - 1;
1a0005c6:	4a60      	ldr	r2, [pc, #384]	; (1a000748 <ActualizarMEFAsc+0x2b0>)
1a0005c8:	7813      	ldrb	r3, [r2, #0]
1a0005ca:	3b01      	subs	r3, #1
1a0005cc:	b25b      	sxtb	r3, r3
1a0005ce:	7013      	strb	r3, [r2, #0]
				//Se consulta si llego.
				if (pisoActual == pisoDestino)
1a0005d0:	4a5e      	ldr	r2, [pc, #376]	; (1a00074c <ActualizarMEFAsc+0x2b4>)
1a0005d2:	f992 2000 	ldrsb.w	r2, [r2]
1a0005d6:	4293      	cmp	r3, r2
1a0005d8:	f040 80e2 	bne.w	1a0007a0 <ActualizarMEFAsc+0x308>
					{
					// CAMBIO DE ESTADO:
					estadoActualAsc = PARADO;
1a0005dc:	2203      	movs	r2, #3
1a0005de:	4b57      	ldr	r3, [pc, #348]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a0005e0:	701a      	strb	r2, [r3, #0]
					Clr_PideNuevoPisoFlag;
1a0005e2:	4a57      	ldr	r2, [pc, #348]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a0005e4:	6813      	ldr	r3, [r2, #0]
1a0005e6:	f023 0310 	bic.w	r3, r3, #16
1a0005ea:	6013      	str	r3, [r2, #0]
					gpioWrite (LED_ASCMOVIENDO, 0);
1a0005ec:	2100      	movs	r1, #0
1a0005ee:	202a      	movs	r0, #42	; 0x2a
1a0005f0:	f001 fc88 	bl	1a001f04 <gpioWrite>
					gpioWrite (LED_PBDETENIDO, 1);
1a0005f4:	2101      	movs	r1, #1
1a0005f6:	202d      	movs	r0, #45	; 0x2d
1a0005f8:	f001 fc84 	bl	1a001f04 <gpioWrite>
1a0005fc:	bd10      	pop	{r4, pc}
			}
		break;

	case PARADO:
		// AL INGRESAR AL EL ESTADO SE EJECUTA POR UNICA VEZ:
		if (!Ask_AscParadoFlag)
1a0005fe:	4b50      	ldr	r3, [pc, #320]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a000600:	681b      	ldr	r3, [r3, #0]
1a000602:	f013 0f01 	tst.w	r3, #1
1a000606:	d115      	bne.n	1a000634 <ActualizarMEFAsc+0x19c>
			{
			if (estadoActualPuerta == PUERTA_CERRADA)
1a000608:	4b4e      	ldr	r3, [pc, #312]	; (1a000744 <ActualizarMEFAsc+0x2ac>)
1a00060a:	781b      	ldrb	r3, [r3, #0]
1a00060c:	b163      	cbz	r3, 1a000628 <ActualizarMEFAsc+0x190>
				Set_AbrePuertasFlag;			// MEF ascensor solicita apertura de puertas
			else if (estadoActualPuerta == PUERTA_ABIERTA)
1a00060e:	2b02      	cmp	r3, #2
1a000610:	f040 80c6 	bne.w	1a0007a0 <ActualizarMEFAsc+0x308>
				{
				Set_CierraPuertasFlag;			// MEF ascensor solicita cierre de puertas
1a000614:	4b4a      	ldr	r3, [pc, #296]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a000616:	681a      	ldr	r2, [r3, #0]
1a000618:	f042 0204 	orr.w	r2, r2, #4
1a00061c:	601a      	str	r2, [r3, #0]
				Set_AscParadoFlag;
1a00061e:	681a      	ldr	r2, [r3, #0]
1a000620:	f042 0201 	orr.w	r2, r2, #1
1a000624:	601a      	str	r2, [r3, #0]
1a000626:	bd10      	pop	{r4, pc}
				Set_AbrePuertasFlag;			// MEF ascensor solicita apertura de puertas
1a000628:	4a45      	ldr	r2, [pc, #276]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a00062a:	6813      	ldr	r3, [r2, #0]
1a00062c:	f043 0302 	orr.w	r3, r3, #2
1a000630:	6013      	str	r3, [r2, #0]
1a000632:	bd10      	pop	{r4, pc}
				}
			}
			
		else if (estadoActualPuerta == PUERTA_CERRADA)
1a000634:	4b43      	ldr	r3, [pc, #268]	; (1a000744 <ActualizarMEFAsc+0x2ac>)
1a000636:	781b      	ldrb	r3, [r3, #0]
1a000638:	2b00      	cmp	r3, #0
1a00063a:	f040 80b1 	bne.w	1a0007a0 <ActualizarMEFAsc+0x308>
			{
			// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
			CargaNuevoPiso();
1a00063e:	f7ff fef9 	bl	1a000434 <CargaNuevoPiso>
			
			if (Ask_PideNuevoPisoFlag)
1a000642:	4b3f      	ldr	r3, [pc, #252]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a000644:	681b      	ldr	r3, [r3, #0]
1a000646:	f013 0f10 	tst.w	r3, #16
1a00064a:	d024      	beq.n	1a000696 <ActualizarMEFAsc+0x1fe>
				{
				Clr_AscParadoFlag;
1a00064c:	4a3c      	ldr	r2, [pc, #240]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a00064e:	6813      	ldr	r3, [r2, #0]
1a000650:	f023 0301 	bic.w	r3, r3, #1
1a000654:	6013      	str	r3, [r2, #0]
				if (pisoActual < pisoDestino) //COMPLETAR!!! no tendria que venir el mismo piso...
1a000656:	4b3c      	ldr	r3, [pc, #240]	; (1a000748 <ActualizarMEFAsc+0x2b0>)
1a000658:	f993 2000 	ldrsb.w	r2, [r3]
1a00065c:	4b3b      	ldr	r3, [pc, #236]	; (1a00074c <ActualizarMEFAsc+0x2b4>)
1a00065e:	f993 3000 	ldrsb.w	r3, [r3]
1a000662:	429a      	cmp	r2, r3
1a000664:	da0b      	bge.n	1a00067e <ActualizarMEFAsc+0x1e6>
					{
					// El piso se encuentra arriba.
					estadoActualAsc = SUBIENDO;
1a000666:	2401      	movs	r4, #1
1a000668:	4b34      	ldr	r3, [pc, #208]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a00066a:	701c      	strb	r4, [r3, #0]
					gpioWrite (LED_PBDETENIDO, 0);
1a00066c:	2100      	movs	r1, #0
1a00066e:	202d      	movs	r0, #45	; 0x2d
1a000670:	f001 fc48 	bl	1a001f04 <gpioWrite>
					gpioWrite (LED_ASCMOVIENDO, 1);
1a000674:	4621      	mov	r1, r4
1a000676:	202a      	movs	r0, #42	; 0x2a
1a000678:	f001 fc44 	bl	1a001f04 <gpioWrite>
1a00067c:	bd10      	pop	{r4, pc}
					}
				else	{
					// El piso se encuentra abajo.
					estadoActualAsc = BAJANDO;
1a00067e:	2202      	movs	r2, #2
1a000680:	4b2e      	ldr	r3, [pc, #184]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a000682:	701a      	strb	r2, [r3, #0]
					gpioWrite (LED_PBDETENIDO, 0);
1a000684:	2100      	movs	r1, #0
1a000686:	202d      	movs	r0, #45	; 0x2d
1a000688:	f001 fc3c 	bl	1a001f04 <gpioWrite>
					gpioWrite (LED_ASCMOVIENDO, 1);
1a00068c:	2101      	movs	r1, #1
1a00068e:	202a      	movs	r0, #42	; 0x2a
1a000690:	f001 fc38 	bl	1a001f04 <gpioWrite>
1a000694:	bd10      	pop	{r4, pc}
					}
				}
			
			//VER!!! si esta en plata baja!
			// Se consulta si hay que ir a PB por tiempo.
			else if (delayRead(&timRetornoPB))
1a000696:	4830      	ldr	r0, [pc, #192]	; (1a000758 <ActualizarMEFAsc+0x2c0>)
1a000698:	f001 fb40 	bl	1a001d1c <delayRead>
1a00069c:	2800      	cmp	r0, #0
1a00069e:	d07f      	beq.n	1a0007a0 <ActualizarMEFAsc+0x308>
				{
				Clr_AscParadoFlag;
1a0006a0:	4c27      	ldr	r4, [pc, #156]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a0006a2:	6823      	ldr	r3, [r4, #0]
1a0006a4:	f023 0301 	bic.w	r3, r3, #1
1a0006a8:	6023      	str	r3, [r4, #0]
				estadoActualAsc = YENDO_A_PLANTA_BAJA;
1a0006aa:	2204      	movs	r2, #4
1a0006ac:	4b23      	ldr	r3, [pc, #140]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a0006ae:	701a      	strb	r2, [r3, #0]
				pisoDestino = 0;
1a0006b0:	2100      	movs	r1, #0
1a0006b2:	4b26      	ldr	r3, [pc, #152]	; (1a00074c <ActualizarMEFAsc+0x2b4>)
1a0006b4:	7019      	strb	r1, [r3, #0]
				gpioWrite (LED_PBDETENIDO, 0);
1a0006b6:	202d      	movs	r0, #45	; 0x2d
1a0006b8:	f001 fc24 	bl	1a001f04 <gpioWrite>
				gpioWrite (LED_ASCMOVIENDO, 1);
1a0006bc:	2101      	movs	r1, #1
1a0006be:	202a      	movs	r0, #42	; 0x2a
1a0006c0:	f001 fc20 	bl	1a001f04 <gpioWrite>
				
				Clr_PideNuevoPisoFlag;			// SACAR!!!
1a0006c4:	6823      	ldr	r3, [r4, #0]
1a0006c6:	f023 0310 	bic.w	r3, r3, #16
1a0006ca:	6023      	str	r3, [r4, #0]
1a0006cc:	bd10      	pop	{r4, pc}
			}
		break;

	case YENDO_A_PLANTA_BAJA:
		// Consulta si hay algun piso pendiente en el buffer, si es asi lo obtiene.
		CargaNuevoPiso();
1a0006ce:	f7ff feb1 	bl	1a000434 <CargaNuevoPiso>
			
		if (Ask_PideNuevoPisoFlag)	
1a0006d2:	4b1b      	ldr	r3, [pc, #108]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a0006d4:	681b      	ldr	r3, [r3, #0]
1a0006d6:	f013 0f10 	tst.w	r3, #16
1a0006da:	d013      	beq.n	1a000704 <ActualizarMEFAsc+0x26c>
			{
			if (pisoActual < pisoDestino)
1a0006dc:	4b1a      	ldr	r3, [pc, #104]	; (1a000748 <ActualizarMEFAsc+0x2b0>)
1a0006de:	f993 2000 	ldrsb.w	r2, [r3]
1a0006e2:	4b1a      	ldr	r3, [pc, #104]	; (1a00074c <ActualizarMEFAsc+0x2b4>)
1a0006e4:	f993 3000 	ldrsb.w	r3, [r3]
1a0006e8:	429a      	cmp	r2, r3
1a0006ea:	da19      	bge.n	1a000720 <ActualizarMEFAsc+0x288>
				{
				// Ante un cambio de estado se ejecuta el cierre de las puertas.
				Set_CierraPuertasFlag;
1a0006ec:	4b14      	ldr	r3, [pc, #80]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a0006ee:	681a      	ldr	r2, [r3, #0]
1a0006f0:	f042 0204 	orr.w	r2, r2, #4
1a0006f4:	601a      	str	r2, [r3, #0]
				// El piso destino se encuentra arriba.
				estadoActualAsc = SUBIENDO;
1a0006f6:	2101      	movs	r1, #1
1a0006f8:	4a10      	ldr	r2, [pc, #64]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a0006fa:	7011      	strb	r1, [r2, #0]
				Clr_PidioAperturaFlag;
1a0006fc:	681a      	ldr	r2, [r3, #0]
1a0006fe:	f022 0208 	bic.w	r2, r2, #8
1a000702:	601a      	str	r2, [r3, #0]
				}
			}

		// SALIDA EN EL ESTADO:
		// Se hace bajar o subir el ascensor, demorara en subir lo configurado en "velPisoPiso"
		if (pisoActual > 0) //COMPLETAR!!! no tendria que venir el mismo piso...
1a000704:	4b10      	ldr	r3, [pc, #64]	; (1a000748 <ActualizarMEFAsc+0x2b0>)
1a000706:	f993 3000 	ldrsb.w	r3, [r3]
1a00070a:	2b00      	cmp	r3, #0
1a00070c:	dd26      	ble.n	1a00075c <ActualizarMEFAsc+0x2c4>
			{
			// El piso actual se encuentra arriba.
			if (delayRead(&timPisoPiso))
1a00070e:	4811      	ldr	r0, [pc, #68]	; (1a000754 <ActualizarMEFAsc+0x2bc>)
1a000710:	f001 fb04 	bl	1a001d1c <delayRead>
1a000714:	b320      	cbz	r0, 1a000760 <ActualizarMEFAsc+0x2c8>
				pisoActual = pisoActual - 1;
1a000716:	4a0c      	ldr	r2, [pc, #48]	; (1a000748 <ActualizarMEFAsc+0x2b0>)
1a000718:	7813      	ldrb	r3, [r2, #0]
1a00071a:	3b01      	subs	r3, #1
1a00071c:	7013      	strb	r3, [r2, #0]
1a00071e:	e01f      	b.n	1a000760 <ActualizarMEFAsc+0x2c8>
				Set_CierraPuertasFlag;
1a000720:	4b07      	ldr	r3, [pc, #28]	; (1a000740 <ActualizarMEFAsc+0x2a8>)
1a000722:	681a      	ldr	r2, [r3, #0]
1a000724:	f042 0204 	orr.w	r2, r2, #4
1a000728:	601a      	str	r2, [r3, #0]
				estadoActualAsc = BAJANDO;
1a00072a:	2102      	movs	r1, #2
1a00072c:	4a03      	ldr	r2, [pc, #12]	; (1a00073c <ActualizarMEFAsc+0x2a4>)
1a00072e:	7011      	strb	r1, [r2, #0]
				Clr_PidioAperturaFlag;
1a000730:	681a      	ldr	r2, [r3, #0]
1a000732:	f022 0208 	bic.w	r2, r2, #8
1a000736:	601a      	str	r2, [r3, #0]
1a000738:	e7e4      	b.n	1a000704 <ActualizarMEFAsc+0x26c>
1a00073a:	bf00      	nop
1a00073c:	10000118 	.word	0x10000118
1a000740:	10000080 	.word	0x10000080
1a000744:	10000138 	.word	0x10000138
1a000748:	10000086 	.word	0x10000086
1a00074c:	10000087 	.word	0x10000087
1a000750:	10000085 	.word	0x10000085
1a000754:	10000120 	.word	0x10000120
1a000758:	10000100 	.word	0x10000100
			}
		else if (pisoActual < 0) 
1a00075c:	2b00      	cmp	r3, #0
1a00075e:	db0f      	blt.n	1a000780 <ActualizarMEFAsc+0x2e8>

			}
		
		// CAMBIO DE ESTADO:
		// Se consulta si llego a PB
		if (pisoActual == 0)
1a000760:	4b10      	ldr	r3, [pc, #64]	; (1a0007a4 <ActualizarMEFAsc+0x30c>)
1a000762:	f993 3000 	ldrsb.w	r3, [r3]
1a000766:	b9db      	cbnz	r3, 1a0007a0 <ActualizarMEFAsc+0x308>
			{
			gpioWrite (LED_ASCMOVIENDO, 0);
1a000768:	2100      	movs	r1, #0
1a00076a:	202a      	movs	r0, #42	; 0x2a
1a00076c:	f001 fbca 	bl	1a001f04 <gpioWrite>
			estadoActualAsc = EN_PLANTA_BAJA;
1a000770:	2200      	movs	r2, #0
1a000772:	4b0d      	ldr	r3, [pc, #52]	; (1a0007a8 <ActualizarMEFAsc+0x310>)
1a000774:	701a      	strb	r2, [r3, #0]
			gpioWrite (LED_PBDETENIDO, 1);
1a000776:	2101      	movs	r1, #1
1a000778:	202d      	movs	r0, #45	; 0x2d
1a00077a:	f001 fbc3 	bl	1a001f04 <gpioWrite>
1a00077e:	bd10      	pop	{r4, pc}
			if (delayRead(&timPisoPiso))
1a000780:	480a      	ldr	r0, [pc, #40]	; (1a0007ac <ActualizarMEFAsc+0x314>)
1a000782:	f001 facb 	bl	1a001d1c <delayRead>
1a000786:	2800      	cmp	r0, #0
1a000788:	d0ea      	beq.n	1a000760 <ActualizarMEFAsc+0x2c8>
				pisoActual = pisoActual + 1;
1a00078a:	4a06      	ldr	r2, [pc, #24]	; (1a0007a4 <ActualizarMEFAsc+0x30c>)
1a00078c:	7813      	ldrb	r3, [r2, #0]
1a00078e:	3301      	adds	r3, #1
1a000790:	7013      	strb	r3, [r2, #0]
1a000792:	e7e5      	b.n	1a000760 <ActualizarMEFAsc+0x2c8>
		
		
	
		// CAMBIO DE ESTADO:
		// Se completo la configuracion.
		estadoActualAsc = EN_PLANTA_BAJA;
1a000794:	2200      	movs	r2, #0
1a000796:	4b04      	ldr	r3, [pc, #16]	; (1a0007a8 <ActualizarMEFAsc+0x310>)
1a000798:	701a      	strb	r2, [r3, #0]
		break;
1a00079a:	bd10      	pop	{r4, pc}
	
	

	default:
		// Si "estadoActualAsc" adquiere un valor invalido se configura un estado de recuperacion.
		InicializarMEFAsc();
1a00079c:	f7ff fe04 	bl	1a0003a8 <InicializarMEFAsc>
1a0007a0:	bd10      	pop	{r4, pc}
1a0007a2:	bf00      	nop
1a0007a4:	10000086 	.word	0x10000086
1a0007a8:	10000118 	.word	0x10000118
1a0007ac:	10000120 	.word	0x10000120

1a0007b0 <ActualizaMEFPuerta>:

//*********************************************************************************************************************
//		Funcin Actualizar MEF de la puerta del ascensor
//*********************************************************************************************************************
void ActualizaMEFPuerta(void)
{
1a0007b0:	b508      	push	{r3, lr}
switch(estadoActualPuerta)
1a0007b2:	4b3f      	ldr	r3, [pc, #252]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a0007b4:	781b      	ldrb	r3, [r3, #0]
1a0007b6:	2b05      	cmp	r3, #5
1a0007b8:	d877      	bhi.n	1a0008aa <ActualizaMEFPuerta+0xfa>
1a0007ba:	e8df f003 	tbb	[pc, r3]
1a0007be:	1403      	.short	0x1403
1a0007c0:	624f3f28 	.word	0x624f3f28
	{
	case PUERTA_CERRADA:
		// CAMBIO DE ESTADO:
		// MEF ascensor solicita apertura de puertas?
		if (Ask_AbrePuertasFlag)
1a0007c4:	4b3b      	ldr	r3, [pc, #236]	; (1a0008b4 <ActualizaMEFPuerta+0x104>)
1a0007c6:	681b      	ldr	r3, [r3, #0]
1a0007c8:	f013 0f02 	tst.w	r3, #2
1a0007cc:	d06f      	beq.n	1a0008ae <ActualizaMEFPuerta+0xfe>
			{
			Clr_AbrePuertasFlag;
1a0007ce:	4a39      	ldr	r2, [pc, #228]	; (1a0008b4 <ActualizaMEFPuerta+0x104>)
1a0007d0:	6813      	ldr	r3, [r2, #0]
1a0007d2:	f023 0302 	bic.w	r3, r3, #2
1a0007d6:	6013      	str	r3, [r2, #0]
			estadoActualPuerta = ABRIENDO_PUERTA;
1a0007d8:	2101      	movs	r1, #1
1a0007da:	4b35      	ldr	r3, [pc, #212]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a0007dc:	7019      	strb	r1, [r3, #0]
			gpioWrite(LED_ABRIENDOPUERTA, 1);
1a0007de:	202b      	movs	r0, #43	; 0x2b
1a0007e0:	f001 fb90 	bl	1a001f04 <gpioWrite>
1a0007e4:	bd08      	pop	{r3, pc}
		break;

	case ABRIENDO_PUERTA:
		// CAMBIO DE ESTADO:
		// Se cumplio tiempo de apertura?
		if (delayRead(&timAbreCierraPuerta))
1a0007e6:	4834      	ldr	r0, [pc, #208]	; (1a0008b8 <ActualizaMEFPuerta+0x108>)
1a0007e8:	f001 fa98 	bl	1a001d1c <delayRead>
1a0007ec:	2800      	cmp	r0, #0
1a0007ee:	d05e      	beq.n	1a0008ae <ActualizaMEFPuerta+0xfe>
			{
			estadoActualPuerta = PUERTA_ABIERTA;
1a0007f0:	2202      	movs	r2, #2
1a0007f2:	4b2f      	ldr	r3, [pc, #188]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a0007f4:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_ABRIENDOPUERTA, 0);
1a0007f6:	2100      	movs	r1, #0
1a0007f8:	202b      	movs	r0, #43	; 0x2b
1a0007fa:	f001 fb83 	bl	1a001f04 <gpioWrite>
			gpioWrite(LED_PUERTAABIERTA, 1);
1a0007fe:	2101      	movs	r1, #1
1a000800:	2029      	movs	r0, #41	; 0x29
1a000802:	f001 fb7f 	bl	1a001f04 <gpioWrite>
			delayRead(&timPuertaAbierta);
1a000806:	482d      	ldr	r0, [pc, #180]	; (1a0008bc <ActualizaMEFPuerta+0x10c>)
1a000808:	f001 fa88 	bl	1a001d1c <delayRead>
1a00080c:	bd08      	pop	{r3, pc}
		break;

	case PUERTA_ABIERTA:
		// CAMBIO DE ESTADO:
		// MEF ascensor solicita cierre de puertas y paso el tiempo que tiene que estar abierta la puerta?
		if (Ask_CierraPuertasFlag && delayRead(&timPuertaAbierta))
1a00080e:	4b29      	ldr	r3, [pc, #164]	; (1a0008b4 <ActualizaMEFPuerta+0x104>)
1a000810:	681b      	ldr	r3, [r3, #0]
1a000812:	f013 0f04 	tst.w	r3, #4
1a000816:	d04a      	beq.n	1a0008ae <ActualizaMEFPuerta+0xfe>
1a000818:	4828      	ldr	r0, [pc, #160]	; (1a0008bc <ActualizaMEFPuerta+0x10c>)
1a00081a:	f001 fa7f 	bl	1a001d1c <delayRead>
1a00081e:	2800      	cmp	r0, #0
1a000820:	d045      	beq.n	1a0008ae <ActualizaMEFPuerta+0xfe>
			{
			Clr_CierraPuertasFlag;
1a000822:	4a24      	ldr	r2, [pc, #144]	; (1a0008b4 <ActualizaMEFPuerta+0x104>)
1a000824:	6813      	ldr	r3, [r2, #0]
1a000826:	f023 0304 	bic.w	r3, r3, #4
1a00082a:	6013      	str	r3, [r2, #0]
			estadoActualPuerta = INTENTANDO_CERRAR_PUERTAS;
1a00082c:	2203      	movs	r2, #3
1a00082e:	4b20      	ldr	r3, [pc, #128]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a000830:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_PUERTAABIERTA, 0);
1a000832:	2100      	movs	r1, #0
1a000834:	2029      	movs	r0, #41	; 0x29
1a000836:	f001 fb65 	bl	1a001f04 <gpioWrite>
1a00083a:	bd08      	pop	{r3, pc}
		break;

	case INTENTANDO_CERRAR_PUERTAS:
		// CAMBIO DE ESTADO:
		// Hay gente?
		if (!gpioRead(TEC1))
1a00083c:	2024      	movs	r0, #36	; 0x24
1a00083e:	f001 fb8c 	bl	1a001f5a <gpioRead>
1a000842:	b918      	cbnz	r0, 1a00084c <ActualizaMEFPuerta+0x9c>
			estadoActualPuerta = ALARMA_PUERTA_ABIERTA;	// Hay gente.
1a000844:	2205      	movs	r2, #5
1a000846:	4b1a      	ldr	r3, [pc, #104]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a000848:	701a      	strb	r2, [r3, #0]
1a00084a:	bd08      	pop	{r3, pc}
		else	{
			estadoActualPuerta = CERRANDO_PUERTA;		// No hay gente.
1a00084c:	2204      	movs	r2, #4
1a00084e:	4b18      	ldr	r3, [pc, #96]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a000850:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_CERRANDOPUERTA, 1);
1a000852:	2101      	movs	r1, #1
1a000854:	202c      	movs	r0, #44	; 0x2c
1a000856:	f001 fb55 	bl	1a001f04 <gpioWrite>
1a00085a:	bd08      	pop	{r3, pc}
	
	
	case CERRANDO_PUERTA:
		// CAMBIO DE ESTADO:
		// Se cumplio tiempo de cierre? 
		if (delayRead(&timAbreCierraPuerta))
1a00085c:	4816      	ldr	r0, [pc, #88]	; (1a0008b8 <ActualizaMEFPuerta+0x108>)
1a00085e:	f001 fa5d 	bl	1a001d1c <delayRead>
1a000862:	b938      	cbnz	r0, 1a000874 <ActualizaMEFPuerta+0xc4>
			{
			estadoActualPuerta = PUERTA_CERRADA;
			gpioWrite(LED_CERRANDOPUERTA, 0);
			}
		// Hay gente?
		if (!gpioRead(TEC1))
1a000864:	2024      	movs	r0, #36	; 0x24
1a000866:	f001 fb78 	bl	1a001f5a <gpioRead>
1a00086a:	bb00      	cbnz	r0, 1a0008ae <ActualizaMEFPuerta+0xfe>
			estadoActualPuerta = ABRIENDO_PUERTA;	// Hay gente.
1a00086c:	2201      	movs	r2, #1
1a00086e:	4b10      	ldr	r3, [pc, #64]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a000870:	701a      	strb	r2, [r3, #0]
1a000872:	bd08      	pop	{r3, pc}
			estadoActualPuerta = PUERTA_CERRADA;
1a000874:	2100      	movs	r1, #0
1a000876:	4b0e      	ldr	r3, [pc, #56]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a000878:	7019      	strb	r1, [r3, #0]
			gpioWrite(LED_CERRANDOPUERTA, 0);
1a00087a:	202c      	movs	r0, #44	; 0x2c
1a00087c:	f001 fb42 	bl	1a001f04 <gpioWrite>
1a000880:	e7f0      	b.n	1a000864 <ActualizaMEFPuerta+0xb4>
		break;

	case ALARMA_PUERTA_ABIERTA:
		// SALIDA EN EL ESTADO:
		if (delayRead(&timAlarPuerta))
1a000882:	480f      	ldr	r0, [pc, #60]	; (1a0008c0 <ActualizaMEFPuerta+0x110>)
1a000884:	f001 fa4a 	bl	1a001d1c <delayRead>
1a000888:	b958      	cbnz	r0, 1a0008a2 <ActualizaMEFPuerta+0xf2>
			gpioToggle(LED_ALARMAPABIERTA);		// Parpadeo led que Indica alarma de puerta abierta.
	
		// CAMBIO DE ESTADO:
		// Hay gente?
		if (gpioRead(TEC1))
1a00088a:	2024      	movs	r0, #36	; 0x24
1a00088c:	f001 fb65 	bl	1a001f5a <gpioRead>
1a000890:	b168      	cbz	r0, 1a0008ae <ActualizaMEFPuerta+0xfe>
			{
			estadoActualPuerta = CERRANDO_PUERTA;	// No hay gente.
1a000892:	2204      	movs	r2, #4
1a000894:	4b06      	ldr	r3, [pc, #24]	; (1a0008b0 <ActualizaMEFPuerta+0x100>)
1a000896:	701a      	strb	r2, [r3, #0]
			gpioWrite(LED_ALARMAPABIERTA, 0);
1a000898:	2100      	movs	r1, #0
1a00089a:	2028      	movs	r0, #40	; 0x28
1a00089c:	f001 fb32 	bl	1a001f04 <gpioWrite>
1a0008a0:	bd08      	pop	{r3, pc}
			gpioToggle(LED_ALARMAPABIERTA);		// Parpadeo led que Indica alarma de puerta abierta.
1a0008a2:	2028      	movs	r0, #40	; 0x28
1a0008a4:	f001 fb83 	bl	1a001fae <gpioToggle>
1a0008a8:	e7ef      	b.n	1a00088a <ActualizaMEFPuerta+0xda>
		break;


	default:
		// Si "estadoActualPuerta" adquiere un valor invalido se configura un estado de recuperacion.
		InicializarMEFPuerta();
1a0008aa:	f7ff fd99 	bl	1a0003e0 <InicializarMEFPuerta>
1a0008ae:	bd08      	pop	{r3, pc}
1a0008b0:	10000138 	.word	0x10000138
1a0008b4:	10000080 	.word	0x10000080
1a0008b8:	100000e8 	.word	0x100000e8
1a0008bc:	10000158 	.word	0x10000158
1a0008c0:	10000140 	.word	0x10000140

1a0008c4 <configurarTecladoMatricial>:
/*==================[declaraciones de funciones internas]====================*/

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void configurarTecladoMatricial (void){
1a0008c4:	b510      	push	{r4, lr}
    
uint8_t i = 0;  // Variable para recorrer el vector de filas y columnas.
    
/* Se recorre todo el vector de filas para configurar los pines como salida.*/
    for ( i = 0; i < 4; i++){
1a0008c6:	2400      	movs	r4, #0
1a0008c8:	e006      	b.n	1a0008d8 <configurarTecladoMatricial+0x14>
        gpioConfig(pinesFila[i], GPIO_OUTPUT);
1a0008ca:	2101      	movs	r1, #1
1a0008cc:	4b09      	ldr	r3, [pc, #36]	; (1a0008f4 <configurarTecladoMatricial+0x30>)
1a0008ce:	5d18      	ldrb	r0, [r3, r4]
1a0008d0:	f001 fa5e 	bl	1a001d90 <gpioConfig>
    for ( i = 0; i < 4; i++){
1a0008d4:	3401      	adds	r4, #1
1a0008d6:	b2e4      	uxtb	r4, r4
1a0008d8:	2c03      	cmp	r4, #3
1a0008da:	d9f6      	bls.n	1a0008ca <configurarTecladoMatricial+0x6>
1a0008dc:	2400      	movs	r4, #0
1a0008de:	e006      	b.n	1a0008ee <configurarTecladoMatricial+0x2a>
    } 

/* Se recorre todo el vector de columnas para configurar los pines como entrada en PULLUP (resistencia interna).*/
    for ( i = 0; i < 4; i++){
        gpioConfig(pinesColumna[i], GPIO_INPUT_PULLUP);
1a0008e0:	2102      	movs	r1, #2
1a0008e2:	4b05      	ldr	r3, [pc, #20]	; (1a0008f8 <configurarTecladoMatricial+0x34>)
1a0008e4:	5d18      	ldrb	r0, [r3, r4]
1a0008e6:	f001 fa53 	bl	1a001d90 <gpioConfig>
    for ( i = 0; i < 4; i++){
1a0008ea:	3401      	adds	r4, #1
1a0008ec:	b2e4      	uxtb	r4, r4
1a0008ee:	2c03      	cmp	r4, #3
1a0008f0:	d9f6      	bls.n	1a0008e0 <configurarTecladoMatricial+0x1c>
    }
}
1a0008f2:	bd10      	pop	{r4, pc}
1a0008f4:	10000008 	.word	0x10000008
1a0008f8:	10000004 	.word	0x10000004

1a0008fc <inicializarMEF_tecladoMatrical>:


//*********************************************************************************************************************
//
//*********************************************************************************************************************
void inicializarMEF_tecladoMatrical(void) {
1a0008fc:	b510      	push	{r4, lr}

estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a0008fe:	2400      	movs	r4, #0
1a000900:	4b03      	ldr	r3, [pc, #12]	; (1a000910 <inicializarMEF_tecladoMatrical+0x14>)
1a000902:	701c      	strb	r4, [r3, #0]
configurarTecladoMatricial();
1a000904:	f7ff ffde 	bl	1a0008c4 <configurarTecladoMatricial>
estadoMefScanTeclado = ESCANEANDO_TECLADO;
1a000908:	4b02      	ldr	r3, [pc, #8]	; (1a000914 <inicializarMEF_tecladoMatrical+0x18>)
1a00090a:	701c      	strb	r4, [r3, #0]
1a00090c:	bd10      	pop	{r4, pc}
1a00090e:	bf00      	nop
1a000910:	10000171 	.word	0x10000171
1a000914:	10000170 	.word	0x10000170

1a000918 <ScanTeclas>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
bool_t ScanTeclas(void)
{
1a000918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

uint8_t f = 0; // Variable para recorrer los vectores de filas.
uint8_t c = 0; // Variable para recorrer los vectores de columnas.

// Lo primero que hacemos es poner todas las filas en estado "bajo".
for (f=0; f<4; f++)
1a00091a:	2400      	movs	r4, #0
1a00091c:	e006      	b.n	1a00092c <ScanTeclas+0x14>
	gpioWrite(pinesFila[f], 0);
1a00091e:	2100      	movs	r1, #0
1a000920:	4b1f      	ldr	r3, [pc, #124]	; (1a0009a0 <ScanTeclas+0x88>)
1a000922:	5d18      	ldrb	r0, [r3, r4]
1a000924:	f001 faee 	bl	1a001f04 <gpioWrite>
for (f=0; f<4; f++)
1a000928:	3401      	adds	r4, #1
1a00092a:	b2e4      	uxtb	r4, r4
1a00092c:	2c03      	cmp	r4, #3
1a00092e:	d9f6      	bls.n	1a00091e <ScanTeclas+0x6>
1a000930:	2600      	movs	r6, #0
1a000932:	e027      	b.n	1a000984 <ScanTeclas+0x6c>
	// Si leo un estado BAJO en una columna entonces puede haber una tecla presionada-
        if (!gpioRead(pinesColumna[c]))
		{
		//Se ponen todas las filas en "alto", excepto la primera que se deja en "bajo".
		for (f=1; f<4 ; f++)
			gpioWrite(pinesFila[f], 1);
1a000934:	2101      	movs	r1, #1
1a000936:	4b1a      	ldr	r3, [pc, #104]	; (1a0009a0 <ScanTeclas+0x88>)
1a000938:	5d58      	ldrb	r0, [r3, r5]
1a00093a:	f001 fae3 	bl	1a001f04 <gpioWrite>
		for (f=1; f<4 ; f++)
1a00093e:	3501      	adds	r5, #1
1a000940:	b2ed      	uxtb	r5, r5
1a000942:	2d03      	cmp	r5, #3
1a000944:	d9f6      	bls.n	1a000934 <ScanTeclas+0x1c>
1a000946:	2400      	movs	r4, #0
		// Se procede a buscar la tecla presionada, para ello se recorren las filas. Ac谩 lo que buscamos es la coordenada de la fila.
		for (f=0; f<4; f++)
1a000948:	2c03      	cmp	r4, #3
1a00094a:	d819      	bhi.n	1a000980 <ScanTeclas+0x68>
			{
			// El siguiente if es para evitar un 铆ndice negativo en el vector.
			if (f > 0)
1a00094c:	b12c      	cbz	r4, 1a00095a <ScanTeclas+0x42>
				gpioWrite(pinesFila[f-1], 1);
1a00094e:	1e63      	subs	r3, r4, #1
1a000950:	2101      	movs	r1, #1
1a000952:	4a13      	ldr	r2, [pc, #76]	; (1a0009a0 <ScanTeclas+0x88>)
1a000954:	5cd0      	ldrb	r0, [r2, r3]
1a000956:	f001 fad5 	bl	1a001f04 <gpioWrite>
			gpioWrite(pinesFila[f], 0);
1a00095a:	2100      	movs	r1, #0
1a00095c:	4b10      	ldr	r3, [pc, #64]	; (1a0009a0 <ScanTeclas+0x88>)
1a00095e:	5d18      	ldrb	r0, [r3, r4]
1a000960:	f001 fad0 	bl	1a001f04 <gpioWrite>

			//Se testea la columna actual con la fila actual, si detectamos un estado "BAJO"
			//en alguna columna, significa que hemos encontrado la coordenada de la fila 
			//correspondiente. Con esta coordenada ya podemos detectar que tecla fue presionada.
			if (!gpioRead(pinesColumna[c]))
1a000964:	4b0f      	ldr	r3, [pc, #60]	; (1a0009a4 <ScanTeclas+0x8c>)
1a000966:	5dd8      	ldrb	r0, [r3, r7]
1a000968:	f001 faf7 	bl	1a001f5a <gpioRead>
1a00096c:	b110      	cbz	r0, 1a000974 <ScanTeclas+0x5c>
		for (f=0; f<4; f++)
1a00096e:	3401      	adds	r4, #1
1a000970:	b2e4      	uxtb	r4, r4
1a000972:	e7e9      	b.n	1a000948 <ScanTeclas+0x30>
				{
				ret = 1;
				key = f * 4 + c;
1a000974:	eb06 0484 	add.w	r4, r6, r4, lsl #2
1a000978:	4b0b      	ldr	r3, [pc, #44]	; (1a0009a8 <ScanTeclas+0x90>)
1a00097a:	801c      	strh	r4, [r3, #0]
				return ret;
1a00097c:	2001      	movs	r0, #1
1a00097e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
for (c=0; c<4; c++)
1a000980:	3601      	adds	r6, #1
1a000982:	b2f6      	uxtb	r6, r6
1a000984:	2e03      	cmp	r6, #3
1a000986:	d808      	bhi.n	1a00099a <ScanTeclas+0x82>
        if (!gpioRead(pinesColumna[c]))
1a000988:	4637      	mov	r7, r6
1a00098a:	4b06      	ldr	r3, [pc, #24]	; (1a0009a4 <ScanTeclas+0x8c>)
1a00098c:	5d98      	ldrb	r0, [r3, r6]
1a00098e:	f001 fae4 	bl	1a001f5a <gpioRead>
1a000992:	2800      	cmp	r0, #0
1a000994:	d1f4      	bne.n	1a000980 <ScanTeclas+0x68>
1a000996:	2501      	movs	r5, #1
1a000998:	e7d3      	b.n	1a000942 <ScanTeclas+0x2a>
				*/
				}
			}
		}
	}
return ret;
1a00099a:	2000      	movs	r0, #0
}
1a00099c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
1a00099e:	bf00      	nop
1a0009a0:	10000008 	.word	0x10000008
1a0009a4:	10000004 	.word	0x10000004
1a0009a8:	100000b8 	.word	0x100000b8

1a0009ac <ActualizaMEFScanTecla>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void ActualizaMEFScanTecla(void)
{
1a0009ac:	b508      	push	{r3, lr}

static delay_t delayAntirebote;
static bool_t flagEstadoApretandoTecla = 0;


switch(estadoMefScanTeclado)
1a0009ae:	4b25      	ldr	r3, [pc, #148]	; (1a000a44 <ActualizaMEFScanTecla+0x98>)
1a0009b0:	781b      	ldrb	r3, [r3, #0]
1a0009b2:	2b01      	cmp	r3, #1
1a0009b4:	d011      	beq.n	1a0009da <ActualizaMEFScanTecla+0x2e>
1a0009b6:	b123      	cbz	r3, 1a0009c2 <ActualizaMEFScanTecla+0x16>
1a0009b8:	2b02      	cmp	r3, #2
1a0009ba:	d037      	beq.n	1a000a2c <ActualizaMEFScanTecla+0x80>
			}
	break;

	
	default:
	inicializarMEF_tecladoMatrical();
1a0009bc:	f7ff ff9e 	bl	1a0008fc <inicializarMEF_tecladoMatrical>
1a0009c0:	bd08      	pop	{r3, pc}
		if (ScanTeclas())
1a0009c2:	f7ff ffa9 	bl	1a000918 <ScanTeclas>
1a0009c6:	2800      	cmp	r0, #0
1a0009c8:	d0fa      	beq.n	1a0009c0 <ActualizaMEFScanTecla+0x14>
			teclaPresionada = key;
1a0009ca:	4b1f      	ldr	r3, [pc, #124]	; (1a000a48 <ActualizaMEFScanTecla+0x9c>)
1a0009cc:	881a      	ldrh	r2, [r3, #0]
1a0009ce:	4b1f      	ldr	r3, [pc, #124]	; (1a000a4c <ActualizaMEFScanTecla+0xa0>)
1a0009d0:	801a      	strh	r2, [r3, #0]
			estadoMefScanTeclado = APRETANDO_TECLA;
1a0009d2:	2201      	movs	r2, #1
1a0009d4:	4b1b      	ldr	r3, [pc, #108]	; (1a000a44 <ActualizaMEFScanTecla+0x98>)
1a0009d6:	701a      	strb	r2, [r3, #0]
1a0009d8:	bd08      	pop	{r3, pc}
		if (flagEstadoApretandoTecla == 0)
1a0009da:	4b1d      	ldr	r3, [pc, #116]	; (1a000a50 <ActualizaMEFScanTecla+0xa4>)
1a0009dc:	781b      	ldrb	r3, [r3, #0]
1a0009de:	b1ab      	cbz	r3, 1a000a0c <ActualizaMEFScanTecla+0x60>
		if (delayRead(&delayAntirebote))
1a0009e0:	481c      	ldr	r0, [pc, #112]	; (1a000a54 <ActualizaMEFScanTecla+0xa8>)
1a0009e2:	f001 f99b 	bl	1a001d1c <delayRead>
1a0009e6:	2800      	cmp	r0, #0
1a0009e8:	d0ea      	beq.n	1a0009c0 <ActualizaMEFScanTecla+0x14>
			ScanTeclas();
1a0009ea:	f7ff ff95 	bl	1a000918 <ScanTeclas>
			if (teclaPresionada == key)
1a0009ee:	4b17      	ldr	r3, [pc, #92]	; (1a000a4c <ActualizaMEFScanTecla+0xa0>)
1a0009f0:	881a      	ldrh	r2, [r3, #0]
1a0009f2:	4b15      	ldr	r3, [pc, #84]	; (1a000a48 <ActualizaMEFScanTecla+0x9c>)
1a0009f4:	881b      	ldrh	r3, [r3, #0]
1a0009f6:	429a      	cmp	r2, r3
1a0009f8:	d011      	beq.n	1a000a1e <ActualizaMEFScanTecla+0x72>
				estadoMefScanTeclado = ESCANEANDO_TECLADO;
1a0009fa:	2300      	movs	r3, #0
1a0009fc:	4a11      	ldr	r2, [pc, #68]	; (1a000a44 <ActualizaMEFScanTecla+0x98>)
1a0009fe:	7013      	strb	r3, [r2, #0]
				teclaPresionada = 0xff;
1a000a00:	21ff      	movs	r1, #255	; 0xff
1a000a02:	4a12      	ldr	r2, [pc, #72]	; (1a000a4c <ActualizaMEFScanTecla+0xa0>)
1a000a04:	8011      	strh	r1, [r2, #0]
				flagEstadoApretandoTecla = 0;
1a000a06:	4a12      	ldr	r2, [pc, #72]	; (1a000a50 <ActualizaMEFScanTecla+0xa4>)
1a000a08:	7013      	strb	r3, [r2, #0]
1a000a0a:	bd08      	pop	{r3, pc}
			flagEstadoApretandoTecla= 1;
1a000a0c:	2201      	movs	r2, #1
1a000a0e:	4b10      	ldr	r3, [pc, #64]	; (1a000a50 <ActualizaMEFScanTecla+0xa4>)
1a000a10:	701a      	strb	r2, [r3, #0]
			delayConfig(&delayAntirebote, 40);
1a000a12:	2228      	movs	r2, #40	; 0x28
1a000a14:	2300      	movs	r3, #0
1a000a16:	480f      	ldr	r0, [pc, #60]	; (1a000a54 <ActualizaMEFScanTecla+0xa8>)
1a000a18:	f001 f970 	bl	1a001cfc <delayConfig>
1a000a1c:	e7e0      	b.n	1a0009e0 <ActualizaMEFScanTecla+0x34>
				estadoMefScanTeclado = IDENTIFICAR_TECLA_Y_ESCRIBIR;
1a000a1e:	2202      	movs	r2, #2
1a000a20:	4b08      	ldr	r3, [pc, #32]	; (1a000a44 <ActualizaMEFScanTecla+0x98>)
1a000a22:	701a      	strb	r2, [r3, #0]
				flagEstadoApretandoTecla = 0;
1a000a24:	2200      	movs	r2, #0
1a000a26:	4b0a      	ldr	r3, [pc, #40]	; (1a000a50 <ActualizaMEFScanTecla+0xa4>)
1a000a28:	701a      	strb	r2, [r3, #0]
1a000a2a:	bd08      	pop	{r3, pc}
		if (!(ScanTeclas()))
1a000a2c:	f7ff ff74 	bl	1a000918 <ScanTeclas>
1a000a30:	2800      	cmp	r0, #0
1a000a32:	d1c5      	bne.n	1a0009c0 <ActualizaMEFScanTecla+0x14>
			estadoMefScanTeclado = ESCANEANDO_TECLADO;  
1a000a34:	2200      	movs	r2, #0
1a000a36:	4b03      	ldr	r3, [pc, #12]	; (1a000a44 <ActualizaMEFScanTecla+0x98>)
1a000a38:	701a      	strb	r2, [r3, #0]
			hayTeclaDisponible = 1;
1a000a3a:	2201      	movs	r2, #1
1a000a3c:	4b06      	ldr	r3, [pc, #24]	; (1a000a58 <ActualizaMEFScanTecla+0xac>)
1a000a3e:	701a      	strb	r2, [r3, #0]
1a000a40:	bd08      	pop	{r3, pc}
1a000a42:	bf00      	nop
1a000a44:	10000170 	.word	0x10000170
1a000a48:	100000b8 	.word	0x100000b8
1a000a4c:	1000000c 	.word	0x1000000c
1a000a50:	100000a8 	.word	0x100000a8
1a000a54:	10000090 	.word	0x10000090
1a000a58:	100000a9 	.word	0x100000a9

1a000a5c <ingresarDigito>:
bool_t ret = FALSE;	

/* Se testea la columna actual con la fila actual, si detectamos un estado "BAJO"
    en alguna columna, significa que hemos encontrado la coordenada de la fila 
    correspondiente. Con esta coordenada ya podemos detectar que tecla fue presionada.*/
if (hayTeclaDisponible)
1a000a5c:	4b1b      	ldr	r3, [pc, #108]	; (1a000acc <ingresarDigito+0x70>)
1a000a5e:	7818      	ldrb	r0, [r3, #0]
1a000a60:	b148      	cbz	r0, 1a000a76 <ingresarDigito+0x1a>
	{
	hayTeclaDisponible = 0;
1a000a62:	2200      	movs	r2, #0
1a000a64:	701a      	strb	r2, [r3, #0]
	ret = TRUE;
                
	/* Etapa en la cual se evalua que digito se ingreso, basicamente llevando la cuenta de las veces que se presion贸 una tecla*/
	switch (indiceTeclaPresionada)
1a000a66:	4b1a      	ldr	r3, [pc, #104]	; (1a000ad0 <ingresarDigito+0x74>)
1a000a68:	681b      	ldr	r3, [r3, #0]
1a000a6a:	2b01      	cmp	r3, #1
1a000a6c:	d00c      	beq.n	1a000a88 <ingresarDigito+0x2c>
1a000a6e:	b11b      	cbz	r3, 1a000a78 <ingresarDigito+0x1c>
1a000a70:	2b02      	cmp	r3, #2
1a000a72:	d020      	beq.n	1a000ab6 <ingresarDigito+0x5a>
	ret = TRUE;
1a000a74:	2001      	movs	r0, #1
			   indiceTeclaGuardar = 1;
		break;
		}
	}
return ret;
}    
1a000a76:	4770      	bx	lr
		case 0:  primerDigito = teclaPresionada;
1a000a78:	4b16      	ldr	r3, [pc, #88]	; (1a000ad4 <ingresarDigito+0x78>)
1a000a7a:	881a      	ldrh	r2, [r3, #0]
1a000a7c:	4b16      	ldr	r3, [pc, #88]	; (1a000ad8 <ingresarDigito+0x7c>)
1a000a7e:	801a      	strh	r2, [r3, #0]
			   indiceTeclaPresionada = 1;
1a000a80:	2001      	movs	r0, #1
1a000a82:	4b13      	ldr	r3, [pc, #76]	; (1a000ad0 <ingresarDigito+0x74>)
1a000a84:	6018      	str	r0, [r3, #0]
		break;
1a000a86:	4770      	bx	lr
		case 1:  segundoDigito = teclaPresionada;
1a000a88:	4b12      	ldr	r3, [pc, #72]	; (1a000ad4 <ingresarDigito+0x78>)
1a000a8a:	881b      	ldrh	r3, [r3, #0]
1a000a8c:	4a13      	ldr	r2, [pc, #76]	; (1a000adc <ingresarDigito+0x80>)
1a000a8e:	8013      	strh	r3, [r2, #0]
			    if ((pinesTeclado[segundoDigito] == 'A') || (pinesTeclado[segundoDigito] == 'B')) {
1a000a90:	4a13      	ldr	r2, [pc, #76]	; (1a000ae0 <ingresarDigito+0x84>)
1a000a92:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
1a000a96:	3b41      	subs	r3, #65	; 0x41
1a000a98:	b29b      	uxth	r3, r3
1a000a9a:	2b01      	cmp	r3, #1
1a000a9c:	d904      	bls.n	1a000aa8 <ingresarDigito+0x4c>
				indiceTeclaPresionada = 2;
1a000a9e:	2202      	movs	r2, #2
1a000aa0:	4b0b      	ldr	r3, [pc, #44]	; (1a000ad0 <ingresarDigito+0x74>)
1a000aa2:	601a      	str	r2, [r3, #0]
	ret = TRUE;
1a000aa4:	2001      	movs	r0, #1
1a000aa6:	4770      	bx	lr
				indiceTeclaPresionada = 0;
1a000aa8:	2300      	movs	r3, #0
1a000aaa:	4a09      	ldr	r2, [pc, #36]	; (1a000ad0 <ingresarDigito+0x74>)
1a000aac:	6013      	str	r3, [r2, #0]
				indiceTeclaGuardar = 0;
1a000aae:	4a0d      	ldr	r2, [pc, #52]	; (1a000ae4 <ingresarDigito+0x88>)
1a000ab0:	6013      	str	r3, [r2, #0]
	ret = TRUE;
1a000ab2:	2001      	movs	r0, #1
1a000ab4:	4770      	bx	lr
		case 2:  confirmar = teclaPresionada;
1a000ab6:	4b07      	ldr	r3, [pc, #28]	; (1a000ad4 <ingresarDigito+0x78>)
1a000ab8:	881a      	ldrh	r2, [r3, #0]
1a000aba:	4b0b      	ldr	r3, [pc, #44]	; (1a000ae8 <ingresarDigito+0x8c>)
1a000abc:	801a      	strh	r2, [r3, #0]
			   indiceTeclaPresionada= 0;
1a000abe:	2200      	movs	r2, #0
1a000ac0:	4b03      	ldr	r3, [pc, #12]	; (1a000ad0 <ingresarDigito+0x74>)
1a000ac2:	601a      	str	r2, [r3, #0]
			   indiceTeclaGuardar = 1;
1a000ac4:	2001      	movs	r0, #1
1a000ac6:	4b07      	ldr	r3, [pc, #28]	; (1a000ae4 <ingresarDigito+0x88>)
1a000ac8:	6018      	str	r0, [r3, #0]
		break;
1a000aca:	4770      	bx	lr
1a000acc:	100000a9 	.word	0x100000a9
1a000ad0:	100000b4 	.word	0x100000b4
1a000ad4:	1000000c 	.word	0x1000000c
1a000ad8:	100000ba 	.word	0x100000ba
1a000adc:	100000bc 	.word	0x100000bc
1a000ae0:	1a002548 	.word	0x1a002548
1a000ae4:	100000b0 	.word	0x100000b0
1a000ae8:	10000088 	.word	0x10000088

1a000aec <guardarPisoSimple>:
//*********************************************************************************************************************
//
//*********************************************************************************************************************
void guardarPisoSimple (int primerDigito) {
	/*======= Funcion que almacena el piso ingresado, de un solo digito, en el vector =======*/
	if (indice < 10) {
1a000aec:	4b0d      	ldr	r3, [pc, #52]	; (1a000b24 <guardarPisoSimple+0x38>)
1a000aee:	681b      	ldr	r3, [r3, #0]
1a000af0:	2b09      	cmp	r3, #9
1a000af2:	dc0a      	bgt.n	1a000b0a <guardarPisoSimple+0x1e>

		if (indice > 0)
1a000af4:	2b00      	cmp	r3, #0
1a000af6:	dd0e      	ble.n	1a000b16 <guardarPisoSimple+0x2a>
			almacenarPisos[indice] = pinesTeclado[primerDigito];
1a000af8:	4a0b      	ldr	r2, [pc, #44]	; (1a000b28 <guardarPisoSimple+0x3c>)
1a000afa:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
1a000afe:	4a0b      	ldr	r2, [pc, #44]	; (1a000b2c <guardarPisoSimple+0x40>)
1a000b00:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		else
			almacenarPisos[0] = pinesTeclado[primerDigito];

		indice ++;
1a000b04:	3301      	adds	r3, #1
1a000b06:	4a07      	ldr	r2, [pc, #28]	; (1a000b24 <guardarPisoSimple+0x38>)
1a000b08:	6013      	str	r3, [r2, #0]
	}

	/*======= Etapa para reinicializar las variables utilizadas y prepararlas para el proximo ingreso =======*/
	primerDigito  = 0;
	segundoDigito = 0;
1a000b0a:	2300      	movs	r3, #0
1a000b0c:	4a08      	ldr	r2, [pc, #32]	; (1a000b30 <guardarPisoSimple+0x44>)
1a000b0e:	8013      	strh	r3, [r2, #0]
	indiceTeclaGuardar = 0;
1a000b10:	4a08      	ldr	r2, [pc, #32]	; (1a000b34 <guardarPisoSimple+0x48>)
1a000b12:	6013      	str	r3, [r2, #0]
1a000b14:	4770      	bx	lr
			almacenarPisos[0] = pinesTeclado[primerDigito];
1a000b16:	4a04      	ldr	r2, [pc, #16]	; (1a000b28 <guardarPisoSimple+0x3c>)
1a000b18:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
1a000b1c:	4a03      	ldr	r2, [pc, #12]	; (1a000b2c <guardarPisoSimple+0x40>)
1a000b1e:	6011      	str	r1, [r2, #0]
1a000b20:	e7f0      	b.n	1a000b04 <guardarPisoSimple+0x18>
1a000b22:	bf00      	nop
1a000b24:	100000ac 	.word	0x100000ac
1a000b28:	1a002548 	.word	0x1a002548
1a000b2c:	10000174 	.word	0x10000174
1a000b30:	100000bc 	.word	0x100000bc
1a000b34:	100000b0 	.word	0x100000b0

1a000b38 <guardarPisoDoble>:
	/*======= Funcion que almacena el piso ingresado, de dos digitos, en el vector =======*/
	
	int carga = 0;
	
	/*======= Etapa de guardar un subsuelo (numero negativo) en el vector de almacenamiento =======*/
	if (pinesTeclado[primerDigito] == '#' && pinesTeclado[segundoDigito] <= 5)
1a000b38:	4b16      	ldr	r3, [pc, #88]	; (1a000b94 <guardarPisoDoble+0x5c>)
1a000b3a:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
1a000b3e:	2b23      	cmp	r3, #35	; 0x23
1a000b40:	d01a      	beq.n	1a000b78 <guardarPisoDoble+0x40>
		carga = 0 - pinesTeclado[segundoDigito];
	else 
		carga = (pinesTeclado[primerDigito] * 10) + pinesTeclado[segundoDigito];
1a000b42:	eb03 0383 	add.w	r3, r3, r3, lsl #2
1a000b46:	005a      	lsls	r2, r3, #1
1a000b48:	4b12      	ldr	r3, [pc, #72]	; (1a000b94 <guardarPisoDoble+0x5c>)
1a000b4a:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
1a000b4e:	4413      	add	r3, r2
	
	/*======= Etapa para verificar si se desea entrar al modo configuracion =======*/
    if (carga == 99) {
1a000b50:	2b63      	cmp	r3, #99	; 0x63
1a000b52:	d018      	beq.n	1a000b86 <guardarPisoDoble+0x4e>
    flagConfiguracion = TRUE;
    }
	
	/*======= Etapa de carga en el vector que almacena los pisos ingresados =======*/	
	if (indice < 10){
1a000b54:	4a10      	ldr	r2, [pc, #64]	; (1a000b98 <guardarPisoDoble+0x60>)
1a000b56:	6812      	ldr	r2, [r2, #0]
1a000b58:	2a09      	cmp	r2, #9
1a000b5a:	dc09      	bgt.n	1a000b70 <guardarPisoDoble+0x38>

		if (carga <= 20){
1a000b5c:	2b14      	cmp	r3, #20
1a000b5e:	dc07      	bgt.n	1a000b70 <guardarPisoDoble+0x38>

			if (indice > 0)
1a000b60:	2a00      	cmp	r2, #0
1a000b62:	dd14      	ble.n	1a000b8e <guardarPisoDoble+0x56>
				almacenarPisos[indice] = carga;
1a000b64:	490d      	ldr	r1, [pc, #52]	; (1a000b9c <guardarPisoDoble+0x64>)
1a000b66:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
			else 
				almacenarPisos[0] = carga;

			indice++;
1a000b6a:	3201      	adds	r2, #1
1a000b6c:	4b0a      	ldr	r3, [pc, #40]	; (1a000b98 <guardarPisoDoble+0x60>)
1a000b6e:	601a      	str	r2, [r3, #0]
	}
    
	/*======= Etapa para reinicializar las variables utilizadas y prepararlas para el proximo ingreso =======*/
	primerDigito  = 0;
	segundoDigito = 0;
	indiceTeclaGuardar = 0;
1a000b70:	2200      	movs	r2, #0
1a000b72:	4b0b      	ldr	r3, [pc, #44]	; (1a000ba0 <guardarPisoDoble+0x68>)
1a000b74:	601a      	str	r2, [r3, #0]
1a000b76:	4770      	bx	lr
	if (pinesTeclado[primerDigito] == '#' && pinesTeclado[segundoDigito] <= 5)
1a000b78:	4a06      	ldr	r2, [pc, #24]	; (1a000b94 <guardarPisoDoble+0x5c>)
1a000b7a:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
1a000b7e:	2a05      	cmp	r2, #5
1a000b80:	d8df      	bhi.n	1a000b42 <guardarPisoDoble+0xa>
		carga = 0 - pinesTeclado[segundoDigito];
1a000b82:	4253      	negs	r3, r2
1a000b84:	e7e4      	b.n	1a000b50 <guardarPisoDoble+0x18>
    flagConfiguracion = TRUE;
1a000b86:	2101      	movs	r1, #1
1a000b88:	4a06      	ldr	r2, [pc, #24]	; (1a000ba4 <guardarPisoDoble+0x6c>)
1a000b8a:	7011      	strb	r1, [r2, #0]
1a000b8c:	e7e2      	b.n	1a000b54 <guardarPisoDoble+0x1c>
				almacenarPisos[0] = carga;
1a000b8e:	4903      	ldr	r1, [pc, #12]	; (1a000b9c <guardarPisoDoble+0x64>)
1a000b90:	600b      	str	r3, [r1, #0]
1a000b92:	e7ea      	b.n	1a000b6a <guardarPisoDoble+0x32>
1a000b94:	1a002548 	.word	0x1a002548
1a000b98:	100000ac 	.word	0x100000ac
1a000b9c:	10000174 	.word	0x10000174
1a000ba0:	100000b0 	.word	0x100000b0
1a000ba4:	10000084 	.word	0x10000084

1a000ba8 <actualizarMEF_tecladoMatricial>:
void actualizarMEF_tecladoMatricial (void) { 
1a000ba8:	b508      	push	{r3, lr}
ActualizaMEFScanTecla();
1a000baa:	f7ff feff 	bl	1a0009ac <ActualizaMEFScanTecla>
switch (estadoMefTecladoMatricial) {
1a000bae:	4b28      	ldr	r3, [pc, #160]	; (1a000c50 <actualizarMEF_tecladoMatricial+0xa8>)
1a000bb0:	781b      	ldrb	r3, [r3, #0]
1a000bb2:	2b01      	cmp	r3, #1
1a000bb4:	d00d      	beq.n	1a000bd2 <actualizarMEF_tecladoMatricial+0x2a>
1a000bb6:	b123      	cbz	r3, 1a000bc2 <actualizarMEF_tecladoMatricial+0x1a>
1a000bb8:	2b02      	cmp	r3, #2
1a000bba:	d02b      	beq.n	1a000c14 <actualizarMEF_tecladoMatricial+0x6c>
		inicializarMEF_tecladoMatrical();
1a000bbc:	f7ff fe9e 	bl	1a0008fc <inicializarMEF_tecladoMatrical>
1a000bc0:	bd08      	pop	{r3, pc}
		if( ingresarDigito() ) {
1a000bc2:	f7ff ff4b 	bl	1a000a5c <ingresarDigito>
1a000bc6:	2800      	cmp	r0, #0
1a000bc8:	d0fa      	beq.n	1a000bc0 <actualizarMEF_tecladoMatricial+0x18>
				estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_2;
1a000bca:	2201      	movs	r2, #1
1a000bcc:	4b20      	ldr	r3, [pc, #128]	; (1a000c50 <actualizarMEF_tecladoMatricial+0xa8>)
1a000bce:	701a      	strb	r2, [r3, #0]
1a000bd0:	bd08      	pop	{r3, pc}
			if( ingresarDigito() ) {
1a000bd2:	f7ff ff43 	bl	1a000a5c <ingresarDigito>
1a000bd6:	2800      	cmp	r0, #0
1a000bd8:	d0f2      	beq.n	1a000bc0 <actualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_LETRA;
1a000bda:	2202      	movs	r2, #2
1a000bdc:	4b1c      	ldr	r3, [pc, #112]	; (1a000c50 <actualizarMEF_tecladoMatricial+0xa8>)
1a000bde:	701a      	strb	r2, [r3, #0]
				if (pinesTeclado[segundoDigito] == 'A') {
1a000be0:	4b1c      	ldr	r3, [pc, #112]	; (1a000c54 <actualizarMEF_tecladoMatricial+0xac>)
1a000be2:	881a      	ldrh	r2, [r3, #0]
1a000be4:	4b1c      	ldr	r3, [pc, #112]	; (1a000c58 <actualizarMEF_tecladoMatricial+0xb0>)
1a000be6:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000bea:	2b41      	cmp	r3, #65	; 0x41
1a000bec:	d00a      	beq.n	1a000c04 <actualizarMEF_tecladoMatricial+0x5c>
				else if (pinesTeclado[confirmar] == 'B') {
1a000bee:	4b1b      	ldr	r3, [pc, #108]	; (1a000c5c <actualizarMEF_tecladoMatricial+0xb4>)
1a000bf0:	881a      	ldrh	r2, [r3, #0]
1a000bf2:	4b19      	ldr	r3, [pc, #100]	; (1a000c58 <actualizarMEF_tecladoMatricial+0xb0>)
1a000bf4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000bf8:	2b42      	cmp	r3, #66	; 0x42
1a000bfa:	d1e1      	bne.n	1a000bc0 <actualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000bfc:	2200      	movs	r2, #0
1a000bfe:	4b14      	ldr	r3, [pc, #80]	; (1a000c50 <actualizarMEF_tecladoMatricial+0xa8>)
1a000c00:	701a      	strb	r2, [r3, #0]
1a000c02:	bd08      	pop	{r3, pc}
					guardarPisoSimple (primerDigito);
1a000c04:	4b16      	ldr	r3, [pc, #88]	; (1a000c60 <actualizarMEF_tecladoMatricial+0xb8>)
1a000c06:	8818      	ldrh	r0, [r3, #0]
1a000c08:	f7ff ff70 	bl	1a000aec <guardarPisoSimple>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000c0c:	2200      	movs	r2, #0
1a000c0e:	4b10      	ldr	r3, [pc, #64]	; (1a000c50 <actualizarMEF_tecladoMatricial+0xa8>)
1a000c10:	701a      	strb	r2, [r3, #0]
1a000c12:	bd08      	pop	{r3, pc}
			if ( ingresarDigito() ) {
1a000c14:	f7ff ff22 	bl	1a000a5c <ingresarDigito>
1a000c18:	2800      	cmp	r0, #0
1a000c1a:	d0d1      	beq.n	1a000bc0 <actualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_LETRA;
1a000c1c:	2202      	movs	r2, #2
1a000c1e:	4b0c      	ldr	r3, [pc, #48]	; (1a000c50 <actualizarMEF_tecladoMatricial+0xa8>)
1a000c20:	701a      	strb	r2, [r3, #0]
				if (pinesTeclado[confirmar] == 'A' ) {
1a000c22:	4b0e      	ldr	r3, [pc, #56]	; (1a000c5c <actualizarMEF_tecladoMatricial+0xb4>)
1a000c24:	881a      	ldrh	r2, [r3, #0]
1a000c26:	4b0c      	ldr	r3, [pc, #48]	; (1a000c58 <actualizarMEF_tecladoMatricial+0xb0>)
1a000c28:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
1a000c2c:	2b41      	cmp	r3, #65	; 0x41
1a000c2e:	d005      	beq.n	1a000c3c <actualizarMEF_tecladoMatricial+0x94>
				else if (pinesTeclado[confirmar] == 'B') {
1a000c30:	2b42      	cmp	r3, #66	; 0x42
1a000c32:	d1c5      	bne.n	1a000bc0 <actualizarMEF_tecladoMatricial+0x18>
					estadoMefTecladoMatricial = EN_ESPERA_DE_DIGITO_1;
1a000c34:	2200      	movs	r2, #0
1a000c36:	4b06      	ldr	r3, [pc, #24]	; (1a000c50 <actualizarMEF_tecladoMatricial+0xa8>)
1a000c38:	701a      	strb	r2, [r3, #0]
1a000c3a:	bd08      	pop	{r3, pc}
					estadoMefTecladoMatricial = GUARDAR_PISO;
1a000c3c:	2203      	movs	r2, #3
1a000c3e:	4b04      	ldr	r3, [pc, #16]	; (1a000c50 <actualizarMEF_tecladoMatricial+0xa8>)
1a000c40:	701a      	strb	r2, [r3, #0]
					guardarPisoDoble (primerDigito, segundoDigito);
1a000c42:	4b04      	ldr	r3, [pc, #16]	; (1a000c54 <actualizarMEF_tecladoMatricial+0xac>)
1a000c44:	8819      	ldrh	r1, [r3, #0]
1a000c46:	4b06      	ldr	r3, [pc, #24]	; (1a000c60 <actualizarMEF_tecladoMatricial+0xb8>)
1a000c48:	8818      	ldrh	r0, [r3, #0]
1a000c4a:	f7ff ff75 	bl	1a000b38 <guardarPisoDoble>
1a000c4e:	bd08      	pop	{r3, pc}
1a000c50:	10000171 	.word	0x10000171
1a000c54:	100000bc 	.word	0x100000bc
1a000c58:	1a002548 	.word	0x1a002548
1a000c5c:	10000088 	.word	0x10000088
1a000c60:	100000ba 	.word	0x100000ba

1a000c64 <itoa>:

 */
char* itoa(int value, char* result, int base)
{
   // check that the base if valid
   if (base < 2 || base > 36) { *result = '\0'; return result; }
1a000c64:	1e93      	subs	r3, r2, #2
1a000c66:	2b22      	cmp	r3, #34	; 0x22
1a000c68:	d802      	bhi.n	1a000c70 <itoa+0xc>
{
1a000c6a:	b4f0      	push	{r4, r5, r6, r7}
1a000c6c:	460d      	mov	r5, r1
1a000c6e:	e005      	b.n	1a000c7c <itoa+0x18>
   if (base < 2 || base > 36) { *result = '\0'; return result; }
1a000c70:	2300      	movs	r3, #0
1a000c72:	700b      	strb	r3, [r1, #0]
      tmp_char = *ptr;
      *ptr--= *ptr1;
      *ptr1++ = tmp_char;
   }
   return result;
}
1a000c74:	4608      	mov	r0, r1
1a000c76:	4770      	bx	lr
      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
1a000c78:	4635      	mov	r5, r6
      value /= base;
1a000c7a:	4620      	mov	r0, r4
1a000c7c:	fb90 f4f2 	sdiv	r4, r0, r2
      *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
1a000c80:	1c6e      	adds	r6, r5, #1
1a000c82:	fb02 0314 	mls	r3, r2, r4, r0
1a000c86:	3323      	adds	r3, #35	; 0x23
1a000c88:	4f0f      	ldr	r7, [pc, #60]	; (1a000cc8 <itoa+0x64>)
1a000c8a:	5cfb      	ldrb	r3, [r7, r3]
1a000c8c:	702b      	strb	r3, [r5, #0]
   } while ( value );
1a000c8e:	2c00      	cmp	r4, #0
1a000c90:	d1f2      	bne.n	1a000c78 <itoa+0x14>
   if (tmp_value < 0) *ptr++ = '-';
1a000c92:	2800      	cmp	r0, #0
1a000c94:	db04      	blt.n	1a000ca0 <itoa+0x3c>
   *ptr-- = '\0';
1a000c96:	1e72      	subs	r2, r6, #1
1a000c98:	2300      	movs	r3, #0
1a000c9a:	7033      	strb	r3, [r6, #0]
   char* ptr = result, *ptr1 = result, tmp_char;
1a000c9c:	460b      	mov	r3, r1
   while(ptr1 < ptr) {
1a000c9e:	e00d      	b.n	1a000cbc <itoa+0x58>
   if (tmp_value < 0) *ptr++ = '-';
1a000ca0:	232d      	movs	r3, #45	; 0x2d
1a000ca2:	7033      	strb	r3, [r6, #0]
1a000ca4:	1cae      	adds	r6, r5, #2
1a000ca6:	e7f6      	b.n	1a000c96 <itoa+0x32>
      tmp_char = *ptr;
1a000ca8:	4614      	mov	r4, r2
1a000caa:	f814 0901 	ldrb.w	r0, [r4], #-1
      *ptr--= *ptr1;
1a000cae:	461d      	mov	r5, r3
1a000cb0:	f815 6b01 	ldrb.w	r6, [r5], #1
1a000cb4:	7016      	strb	r6, [r2, #0]
      *ptr1++ = tmp_char;
1a000cb6:	7018      	strb	r0, [r3, #0]
1a000cb8:	462b      	mov	r3, r5
      *ptr--= *ptr1;
1a000cba:	4622      	mov	r2, r4
   while(ptr1 < ptr) {
1a000cbc:	429a      	cmp	r2, r3
1a000cbe:	d8f3      	bhi.n	1a000ca8 <itoa+0x44>
}
1a000cc0:	4608      	mov	r0, r1
1a000cc2:	bcf0      	pop	{r4, r5, r6, r7}
1a000cc4:	4770      	bx	lr
1a000cc6:	bf00      	nop
1a000cc8:	1a0027bc 	.word	0x1a0027bc

1a000ccc <uartWriteMiDato>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void uartWriteMiDato(char* str, int value, int base)
{
1a000ccc:	b570      	push	{r4, r5, r6, lr}
1a000cce:	460d      	mov	r5, r1
1a000cd0:	4616      	mov	r6, r2

uartWriteString(UART_USB, str);
1a000cd2:	4601      	mov	r1, r0
1a000cd4:	2000      	movs	r0, #0
1a000cd6:	f001 fa99 	bl	1a00220c <uartWriteString>
itoa( value, numeroEnString, base);         
1a000cda:	4c07      	ldr	r4, [pc, #28]	; (1a000cf8 <uartWriteMiDato+0x2c>)
1a000cdc:	4632      	mov	r2, r6
1a000cde:	4621      	mov	r1, r4
1a000ce0:	4628      	mov	r0, r5
1a000ce2:	f7ff ffbf 	bl	1a000c64 <itoa>
uartWriteString( UART_USB, numeroEnString );  
1a000ce6:	4621      	mov	r1, r4
1a000ce8:	2000      	movs	r0, #0
1a000cea:	f001 fa8f 	bl	1a00220c <uartWriteString>
uartWriteString( UART_USB, "\r\n" );  
1a000cee:	4903      	ldr	r1, [pc, #12]	; (1a000cfc <uartWriteMiDato+0x30>)
1a000cf0:	2000      	movs	r0, #0
1a000cf2:	f001 fa8b 	bl	1a00220c <uartWriteString>
1a000cf6:	bd70      	pop	{r4, r5, r6, pc}
1a000cf8:	1000019c 	.word	0x1000019c
1a000cfc:	1a0026d0 	.word	0x1a0026d0

1a000d00 <EstadoInterno>:

//*********************************************************************************************************************
//
//*********************************************************************************************************************
void EstadoInterno(void)
{
1a000d00:	b510      	push	{r4, lr}
// Esta linea permite el borrado de la terminal en la PC usando RealTerm.
uartWriteString( UART_USB, "\x1b[2J\x1b[H" );  	
1a000d02:	495a      	ldr	r1, [pc, #360]	; (1a000e6c <EstadoInterno+0x16c>)
1a000d04:	2000      	movs	r0, #0
1a000d06:	f001 fa81 	bl	1a00220c <uartWriteString>


uartWriteMiDato("almacenarPisos[0] = ", almacenarPisos[0], 10);
1a000d0a:	4c59      	ldr	r4, [pc, #356]	; (1a000e70 <EstadoInterno+0x170>)
1a000d0c:	220a      	movs	r2, #10
1a000d0e:	6821      	ldr	r1, [r4, #0]
1a000d10:	4858      	ldr	r0, [pc, #352]	; (1a000e74 <EstadoInterno+0x174>)
1a000d12:	f7ff ffdb 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[1] = ", almacenarPisos[1], 10);
1a000d16:	220a      	movs	r2, #10
1a000d18:	6861      	ldr	r1, [r4, #4]
1a000d1a:	4857      	ldr	r0, [pc, #348]	; (1a000e78 <EstadoInterno+0x178>)
1a000d1c:	f7ff ffd6 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[2] = ", almacenarPisos[2], 10);
1a000d20:	220a      	movs	r2, #10
1a000d22:	68a1      	ldr	r1, [r4, #8]
1a000d24:	4855      	ldr	r0, [pc, #340]	; (1a000e7c <EstadoInterno+0x17c>)
1a000d26:	f7ff ffd1 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[3] = ", almacenarPisos[3], 10);
1a000d2a:	220a      	movs	r2, #10
1a000d2c:	68e1      	ldr	r1, [r4, #12]
1a000d2e:	4854      	ldr	r0, [pc, #336]	; (1a000e80 <EstadoInterno+0x180>)
1a000d30:	f7ff ffcc 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[4] = ", almacenarPisos[4], 10);
1a000d34:	220a      	movs	r2, #10
1a000d36:	6921      	ldr	r1, [r4, #16]
1a000d38:	4852      	ldr	r0, [pc, #328]	; (1a000e84 <EstadoInterno+0x184>)
1a000d3a:	f7ff ffc7 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[5] = ", almacenarPisos[5], 10);
1a000d3e:	220a      	movs	r2, #10
1a000d40:	6961      	ldr	r1, [r4, #20]
1a000d42:	4851      	ldr	r0, [pc, #324]	; (1a000e88 <EstadoInterno+0x188>)
1a000d44:	f7ff ffc2 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[6] = ", almacenarPisos[6], 10);
1a000d48:	220a      	movs	r2, #10
1a000d4a:	69a1      	ldr	r1, [r4, #24]
1a000d4c:	484f      	ldr	r0, [pc, #316]	; (1a000e8c <EstadoInterno+0x18c>)
1a000d4e:	f7ff ffbd 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[7] = ", almacenarPisos[7], 10);
1a000d52:	220a      	movs	r2, #10
1a000d54:	69e1      	ldr	r1, [r4, #28]
1a000d56:	484e      	ldr	r0, [pc, #312]	; (1a000e90 <EstadoInterno+0x190>)
1a000d58:	f7ff ffb8 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[8] = ", almacenarPisos[8], 10);
1a000d5c:	220a      	movs	r2, #10
1a000d5e:	6a21      	ldr	r1, [r4, #32]
1a000d60:	484c      	ldr	r0, [pc, #304]	; (1a000e94 <EstadoInterno+0x194>)
1a000d62:	f7ff ffb3 	bl	1a000ccc <uartWriteMiDato>
uartWriteMiDato("almacenarPisos[9] = ", almacenarPisos[9], 10);
1a000d66:	220a      	movs	r2, #10
1a000d68:	6a61      	ldr	r1, [r4, #36]	; 0x24
1a000d6a:	484b      	ldr	r0, [pc, #300]	; (1a000e98 <EstadoInterno+0x198>)
1a000d6c:	f7ff ffae 	bl	1a000ccc <uartWriteMiDato>

// uartWriteMiDato("PrimerDigito = ", primerDigito, 10);

// uartWriteMiDato("SegundoDigito = ", segundoDigito, 10);

uartWriteMiDato("Indice = ", indice, 10);
1a000d70:	220a      	movs	r2, #10
1a000d72:	4b4a      	ldr	r3, [pc, #296]	; (1a000e9c <EstadoInterno+0x19c>)
1a000d74:	6819      	ldr	r1, [r3, #0]
1a000d76:	484a      	ldr	r0, [pc, #296]	; (1a000ea0 <EstadoInterno+0x1a0>)
1a000d78:	f7ff ffa8 	bl	1a000ccc <uartWriteMiDato>


if (Ask_PideNuevoPisoFlag)
1a000d7c:	4b49      	ldr	r3, [pc, #292]	; (1a000ea4 <EstadoInterno+0x1a4>)
1a000d7e:	681b      	ldr	r3, [r3, #0]
1a000d80:	f013 0f10 	tst.w	r3, #16
1a000d84:	d01f      	beq.n	1a000dc6 <EstadoInterno+0xc6>
	uartWriteMiDato("pideNuevoPiso = ", 1, 10);
1a000d86:	220a      	movs	r2, #10
1a000d88:	2101      	movs	r1, #1
1a000d8a:	4847      	ldr	r0, [pc, #284]	; (1a000ea8 <EstadoInterno+0x1a8>)
1a000d8c:	f7ff ff9e 	bl	1a000ccc <uartWriteMiDato>
else	uartWriteMiDato("pideNuevoPiso = ", 0, 10);

uartWriteMiDato ("Piso Destino = ", pisoDestino, 10);
1a000d90:	220a      	movs	r2, #10
1a000d92:	4b46      	ldr	r3, [pc, #280]	; (1a000eac <EstadoInterno+0x1ac>)
1a000d94:	f993 1000 	ldrsb.w	r1, [r3]
1a000d98:	4845      	ldr	r0, [pc, #276]	; (1a000eb0 <EstadoInterno+0x1b0>)
1a000d9a:	f7ff ff97 	bl	1a000ccc <uartWriteMiDato>

uartWriteMiDato ("Piso Actual = ", pisoActual, 10);
1a000d9e:	220a      	movs	r2, #10
1a000da0:	4b44      	ldr	r3, [pc, #272]	; (1a000eb4 <EstadoInterno+0x1b4>)
1a000da2:	f993 1000 	ldrsb.w	r1, [r3]
1a000da6:	4844      	ldr	r0, [pc, #272]	; (1a000eb8 <EstadoInterno+0x1b8>)
1a000da8:	f7ff ff90 	bl	1a000ccc <uartWriteMiDato>


	

uartWriteString(UART_USB, "estadoActualAsc = ");
1a000dac:	4943      	ldr	r1, [pc, #268]	; (1a000ebc <EstadoInterno+0x1bc>)
1a000dae:	2000      	movs	r0, #0
1a000db0:	f001 fa2c 	bl	1a00220c <uartWriteString>
switch(estadoActualAsc)
1a000db4:	4b42      	ldr	r3, [pc, #264]	; (1a000ec0 <EstadoInterno+0x1c0>)
1a000db6:	781b      	ldrb	r3, [r3, #0]
1a000db8:	2b05      	cmp	r3, #5
1a000dba:	d80e      	bhi.n	1a000dda <EstadoInterno+0xda>
1a000dbc:	e8df f003 	tbb	[pc, r3]
1a000dc0:	241f1a09 	.word	0x241f1a09
1a000dc4:	2e29      	.short	0x2e29
else	uartWriteMiDato("pideNuevoPiso = ", 0, 10);
1a000dc6:	220a      	movs	r2, #10
1a000dc8:	2100      	movs	r1, #0
1a000dca:	4837      	ldr	r0, [pc, #220]	; (1a000ea8 <EstadoInterno+0x1a8>)
1a000dcc:	f7ff ff7e 	bl	1a000ccc <uartWriteMiDato>
1a000dd0:	e7de      	b.n	1a000d90 <EstadoInterno+0x90>
	{
	case EN_PLANTA_BAJA:
		uartWriteString(UART_USB, "En Planta Baja\r\n");
1a000dd2:	493c      	ldr	r1, [pc, #240]	; (1a000ec4 <EstadoInterno+0x1c4>)
1a000dd4:	2000      	movs	r0, #0
1a000dd6:	f001 fa19 	bl	1a00220c <uartWriteString>

		break;
 	}      	
	
	
uartWriteString(UART_USB, "estadoActualPuerta = ");	
1a000dda:	493b      	ldr	r1, [pc, #236]	; (1a000ec8 <EstadoInterno+0x1c8>)
1a000ddc:	2000      	movs	r0, #0
1a000dde:	f001 fa15 	bl	1a00220c <uartWriteString>
switch(estadoActualPuerta)
1a000de2:	4b3a      	ldr	r3, [pc, #232]	; (1a000ecc <EstadoInterno+0x1cc>)
1a000de4:	781b      	ldrb	r3, [r3, #0]
1a000de6:	2b05      	cmp	r3, #5
1a000de8:	d821      	bhi.n	1a000e2e <EstadoInterno+0x12e>
1a000dea:	e8df f003 	tbb	[pc, r3]
1a000dee:	251c      	.short	0x251c
1a000df0:	39342f2a 	.word	0x39342f2a
		uartWriteString(UART_USB, "Subiendo\r\n");
1a000df4:	4936      	ldr	r1, [pc, #216]	; (1a000ed0 <EstadoInterno+0x1d0>)
1a000df6:	2000      	movs	r0, #0
1a000df8:	f001 fa08 	bl	1a00220c <uartWriteString>
		break;
1a000dfc:	e7ed      	b.n	1a000dda <EstadoInterno+0xda>
		uartWriteString(UART_USB, "Bajando\r\n");	
1a000dfe:	4935      	ldr	r1, [pc, #212]	; (1a000ed4 <EstadoInterno+0x1d4>)
1a000e00:	2000      	movs	r0, #0
1a000e02:	f001 fa03 	bl	1a00220c <uartWriteString>
		break;
1a000e06:	e7e8      	b.n	1a000dda <EstadoInterno+0xda>
		uartWriteString(UART_USB, "Parado\r\n");	
1a000e08:	4933      	ldr	r1, [pc, #204]	; (1a000ed8 <EstadoInterno+0x1d8>)
1a000e0a:	2000      	movs	r0, #0
1a000e0c:	f001 f9fe 	bl	1a00220c <uartWriteString>
		break;
1a000e10:	e7e3      	b.n	1a000dda <EstadoInterno+0xda>
		uartWriteString(UART_USB, "Yendo a Planta Baja\r\n");	
1a000e12:	4932      	ldr	r1, [pc, #200]	; (1a000edc <EstadoInterno+0x1dc>)
1a000e14:	2000      	movs	r0, #0
1a000e16:	f001 f9f9 	bl	1a00220c <uartWriteString>
		break;
1a000e1a:	e7de      	b.n	1a000dda <EstadoInterno+0xda>
		uartWriteString(UART_USB, "Modo Configuracion\r\n");
1a000e1c:	4930      	ldr	r1, [pc, #192]	; (1a000ee0 <EstadoInterno+0x1e0>)
1a000e1e:	2000      	movs	r0, #0
1a000e20:	f001 f9f4 	bl	1a00220c <uartWriteString>
		break;
1a000e24:	e7d9      	b.n	1a000dda <EstadoInterno+0xda>
	{
	case PUERTA_CERRADA:
		uartWriteString(UART_USB, "Puertas Cerradas\r\n");
1a000e26:	492f      	ldr	r1, [pc, #188]	; (1a000ee4 <EstadoInterno+0x1e4>)
1a000e28:	2000      	movs	r0, #0
1a000e2a:	f001 f9ef 	bl	1a00220c <uartWriteString>
	default:

		break;
 	}      

uartWriteString(UART_USB, "\r\n");
1a000e2e:	492e      	ldr	r1, [pc, #184]	; (1a000ee8 <EstadoInterno+0x1e8>)
1a000e30:	2000      	movs	r0, #0
1a000e32:	f001 f9eb 	bl	1a00220c <uartWriteString>
1a000e36:	bd10      	pop	{r4, pc}
		uartWriteString(UART_USB, "Abriendo Puertas\r\n");
1a000e38:	492c      	ldr	r1, [pc, #176]	; (1a000eec <EstadoInterno+0x1ec>)
1a000e3a:	2000      	movs	r0, #0
1a000e3c:	f001 f9e6 	bl	1a00220c <uartWriteString>
		break;
1a000e40:	e7f5      	b.n	1a000e2e <EstadoInterno+0x12e>
		uartWriteString(UART_USB, "Puertas Abiertas\r\n");
1a000e42:	492b      	ldr	r1, [pc, #172]	; (1a000ef0 <EstadoInterno+0x1f0>)
1a000e44:	2000      	movs	r0, #0
1a000e46:	f001 f9e1 	bl	1a00220c <uartWriteString>
		break;
1a000e4a:	e7f0      	b.n	1a000e2e <EstadoInterno+0x12e>
		uartWriteString(UART_USB, "Intentado Cerrar Puertas\r\n");
1a000e4c:	4929      	ldr	r1, [pc, #164]	; (1a000ef4 <EstadoInterno+0x1f4>)
1a000e4e:	2000      	movs	r0, #0
1a000e50:	f001 f9dc 	bl	1a00220c <uartWriteString>
		break;
1a000e54:	e7eb      	b.n	1a000e2e <EstadoInterno+0x12e>
		uartWriteString(UART_USB, "Cerrando Puertas\r\n");
1a000e56:	4928      	ldr	r1, [pc, #160]	; (1a000ef8 <EstadoInterno+0x1f8>)
1a000e58:	2000      	movs	r0, #0
1a000e5a:	f001 f9d7 	bl	1a00220c <uartWriteString>
		break;
1a000e5e:	e7e6      	b.n	1a000e2e <EstadoInterno+0x12e>
		uartWriteString(UART_USB, "Alarma Puertas Abiertas\r\n");
1a000e60:	4926      	ldr	r1, [pc, #152]	; (1a000efc <EstadoInterno+0x1fc>)
1a000e62:	2000      	movs	r0, #0
1a000e64:	f001 f9d2 	bl	1a00220c <uartWriteString>
		break;
1a000e68:	e7e1      	b.n	1a000e2e <EstadoInterno+0x12e>
1a000e6a:	bf00      	nop
1a000e6c:	1a002568 	.word	0x1a002568
1a000e70:	10000174 	.word	0x10000174
1a000e74:	1a002570 	.word	0x1a002570
1a000e78:	1a002588 	.word	0x1a002588
1a000e7c:	1a0025a0 	.word	0x1a0025a0
1a000e80:	1a0025b8 	.word	0x1a0025b8
1a000e84:	1a0025d0 	.word	0x1a0025d0
1a000e88:	1a0025e8 	.word	0x1a0025e8
1a000e8c:	1a002600 	.word	0x1a002600
1a000e90:	1a002618 	.word	0x1a002618
1a000e94:	1a002630 	.word	0x1a002630
1a000e98:	1a002648 	.word	0x1a002648
1a000e9c:	100000ac 	.word	0x100000ac
1a000ea0:	1a002660 	.word	0x1a002660
1a000ea4:	10000080 	.word	0x10000080
1a000ea8:	1a00266c 	.word	0x1a00266c
1a000eac:	10000087 	.word	0x10000087
1a000eb0:	1a002680 	.word	0x1a002680
1a000eb4:	10000086 	.word	0x10000086
1a000eb8:	1a002690 	.word	0x1a002690
1a000ebc:	1a0026a0 	.word	0x1a0026a0
1a000ec0:	10000118 	.word	0x10000118
1a000ec4:	1a0026b4 	.word	0x1a0026b4
1a000ec8:	1a00271c 	.word	0x1a00271c
1a000ecc:	10000138 	.word	0x10000138
1a000ed0:	1a0026c8 	.word	0x1a0026c8
1a000ed4:	1a0026d4 	.word	0x1a0026d4
1a000ed8:	1a0026e0 	.word	0x1a0026e0
1a000edc:	1a0026ec 	.word	0x1a0026ec
1a000ee0:	1a002704 	.word	0x1a002704
1a000ee4:	1a002734 	.word	0x1a002734
1a000ee8:	1a0026d0 	.word	0x1a0026d0
1a000eec:	1a002748 	.word	0x1a002748
1a000ef0:	1a00275c 	.word	0x1a00275c
1a000ef4:	1a002770 	.word	0x1a002770
1a000ef8:	1a00278c 	.word	0x1a00278c
1a000efc:	1a0027a0 	.word	0x1a0027a0

1a000f00 <ConfigDisplay>:

//*************************************************************************************************
//			Configura pines para los dgitos
//*************************************************************************************************
void ConfigDisplay(void)
{
1a000f00:	b538      	push	{r3, r4, r5, lr}
uint8_t i = 0;

// Se setean los pines correspondientes a los segmentos como salida y en cero.
for (i=0; i<8; i++)
1a000f02:	2400      	movs	r4, #0
1a000f04:	e00a      	b.n	1a000f1c <ConfigDisplay+0x1c>
	{
	gpioConfig (segmentosdisplayB[i], GPIO_OUTPUT);
1a000f06:	4d0e      	ldr	r5, [pc, #56]	; (1a000f40 <ConfigDisplay+0x40>)
1a000f08:	2101      	movs	r1, #1
1a000f0a:	5d28      	ldrb	r0, [r5, r4]
1a000f0c:	f000 ff40 	bl	1a001d90 <gpioConfig>
	gpioWrite (segmentosdisplayB[i], 1);
1a000f10:	2101      	movs	r1, #1
1a000f12:	5d28      	ldrb	r0, [r5, r4]
1a000f14:	f000 fff6 	bl	1a001f04 <gpioWrite>
for (i=0; i<8; i++)
1a000f18:	3401      	adds	r4, #1
1a000f1a:	b2e4      	uxtb	r4, r4
1a000f1c:	2c07      	cmp	r4, #7
1a000f1e:	d9f2      	bls.n	1a000f06 <ConfigDisplay+0x6>
1a000f20:	2400      	movs	r4, #0
1a000f22:	e00a      	b.n	1a000f3a <ConfigDisplay+0x3a>
	}

// Se setean los pines correspondientes al control de los anodos comn de los dgitos, en salida y cero.
for (i=0; i<4; i++)
	{
	gpioConfig (quedisplayB[i], GPIO_OUTPUT);
1a000f24:	4d07      	ldr	r5, [pc, #28]	; (1a000f44 <ConfigDisplay+0x44>)
1a000f26:	2101      	movs	r1, #1
1a000f28:	5d28      	ldrb	r0, [r5, r4]
1a000f2a:	f000 ff31 	bl	1a001d90 <gpioConfig>
	gpioWrite (quedisplayB[i], 1);
1a000f2e:	2101      	movs	r1, #1
1a000f30:	5d28      	ldrb	r0, [r5, r4]
1a000f32:	f000 ffe7 	bl	1a001f04 <gpioWrite>
for (i=0; i<4; i++)
1a000f36:	3401      	adds	r4, #1
1a000f38:	b2e4      	uxtb	r4, r4
1a000f3a:	2c03      	cmp	r4, #3
1a000f3c:	d9f2      	bls.n	1a000f24 <ConfigDisplay+0x24>
	}
	
}
1a000f3e:	bd38      	pop	{r3, r4, r5, pc}
1a000f40:	10000030 	.word	0x10000030
1a000f44:	1000002c 	.word	0x1000002c

1a000f48 <SacaDigito>:

//*********************************************************************************************************************
//			Actualiza un dgito
//*********************************************************************************************************************
void SacaDigito(uint8_t numero, uint8_t lcdx)
{
1a000f48:	b538      	push	{r3, r4, r5, lr}
1a000f4a:	4605      	mov	r5, r0
1a000f4c:	460c      	mov	r4, r1
uint8_t i = 0;

gpioWrite (LCD1, 1);
1a000f4e:	2101      	movs	r1, #1
1a000f50:	2010      	movs	r0, #16
1a000f52:	f000 ffd7 	bl	1a001f04 <gpioWrite>
gpioWrite (LCD2, 1);
1a000f56:	2101      	movs	r1, #1
1a000f58:	2011      	movs	r0, #17
1a000f5a:	f000 ffd3 	bl	1a001f04 <gpioWrite>
gpioWrite (LCD3, 1);
1a000f5e:	2101      	movs	r1, #1
1a000f60:	2012      	movs	r0, #18
1a000f62:	f000 ffcf 	bl	1a001f04 <gpioWrite>
gpioWrite (LCD4, 1);
1a000f66:	2101      	movs	r1, #1
1a000f68:	2014      	movs	r0, #20
1a000f6a:	f000 ffcb 	bl	1a001f04 <gpioWrite>
gpioWrite (lcdx, 0);
1a000f6e:	2100      	movs	r1, #0
1a000f70:	4620      	mov	r0, r4
1a000f72:	f000 ffc7 	bl	1a001f04 <gpioWrite>

for (i=0; i<=7; i++)
1a000f76:	2400      	movs	r4, #0
1a000f78:	e00d      	b.n	1a000f96 <SacaDigito+0x4e>
	gpioWrite (segmentosdisplayB[i], !(numeroadisplayB[numero] & (1 << i)));
1a000f7a:	4b08      	ldr	r3, [pc, #32]	; (1a000f9c <SacaDigito+0x54>)
1a000f7c:	5d5b      	ldrb	r3, [r3, r5]
1a000f7e:	4123      	asrs	r3, r4
1a000f80:	f013 0f01 	tst.w	r3, #1
1a000f84:	bf0c      	ite	eq
1a000f86:	2101      	moveq	r1, #1
1a000f88:	2100      	movne	r1, #0
1a000f8a:	4b05      	ldr	r3, [pc, #20]	; (1a000fa0 <SacaDigito+0x58>)
1a000f8c:	5d18      	ldrb	r0, [r3, r4]
1a000f8e:	f000 ffb9 	bl	1a001f04 <gpioWrite>
for (i=0; i<=7; i++)
1a000f92:	3401      	adds	r4, #1
1a000f94:	b2e4      	uxtb	r4, r4
1a000f96:	2c07      	cmp	r4, #7
1a000f98:	d9ef      	bls.n	1a000f7a <SacaDigito+0x32>
}
1a000f9a:	bd38      	pop	{r3, r4, r5, pc}
1a000f9c:	10000010 	.word	0x10000010
1a000fa0:	10000030 	.word	0x10000030

1a000fa4 <ConvierteByte>:
//*********************************************************************************************************************
//
//*********************************************************************************************************************
void ConvierteByte(uint8_t X, uint8_t *p)
{   
if (X)
1a000fa4:	4603      	mov	r3, r0
1a000fa6:	b920      	cbnz	r0, 1a000fb2 <ConvierteByte+0xe>
	p[1] = X/10;
	X = X%10;
	p[0] = X;
	}
else	{
	p[2] = 0;
1a000fa8:	2300      	movs	r3, #0
1a000faa:	708b      	strb	r3, [r1, #2]
	p[1] = 0;
1a000fac:	704b      	strb	r3, [r1, #1]
	p[0] = 0;
1a000fae:	700b      	strb	r3, [r1, #0]
1a000fb0:	4770      	bx	lr
	p[2] = X/100;
1a000fb2:	480a      	ldr	r0, [pc, #40]	; (1a000fdc <ConvierteByte+0x38>)
1a000fb4:	fba0 2003 	umull	r2, r0, r0, r3
1a000fb8:	0940      	lsrs	r0, r0, #5
1a000fba:	7088      	strb	r0, [r1, #2]
	X = X%100;
1a000fbc:	2264      	movs	r2, #100	; 0x64
1a000fbe:	fb02 3010 	mls	r0, r2, r0, r3
1a000fc2:	b2c0      	uxtb	r0, r0
	p[1] = X/10;
1a000fc4:	4b06      	ldr	r3, [pc, #24]	; (1a000fe0 <ConvierteByte+0x3c>)
1a000fc6:	fba3 2300 	umull	r2, r3, r3, r0
1a000fca:	08db      	lsrs	r3, r3, #3
1a000fcc:	704b      	strb	r3, [r1, #1]
	X = X%10;
1a000fce:	eb03 0383 	add.w	r3, r3, r3, lsl #2
1a000fd2:	005a      	lsls	r2, r3, #1
1a000fd4:	1a80      	subs	r0, r0, r2
	p[0] = X;
1a000fd6:	7008      	strb	r0, [r1, #0]
1a000fd8:	4770      	bx	lr
1a000fda:	bf00      	nop
1a000fdc:	51eb851f 	.word	0x51eb851f
1a000fe0:	cccccccd 	.word	0xcccccccd

1a000fe4 <PonPisoActualDisplay>:


//*********************************************************************************************************************
//*********************************************************************************************************************
void PonPisoActualDisplay(void)
{
1a000fe4:	b500      	push	{lr}
1a000fe6:	b083      	sub	sp, #12

uint8_t valores[3];

// Esta en planta baja?
if (pisoActual == 0 && estadoActualAsc != SUBIENDO && estadoActualAsc != BAJANDO)
1a000fe8:	4b51      	ldr	r3, [pc, #324]	; (1a001130 <PonPisoActualDisplay+0x14c>)
1a000fea:	f993 0000 	ldrsb.w	r0, [r3]
1a000fee:	b9c8      	cbnz	r0, 1a001024 <PonPisoActualDisplay+0x40>
1a000ff0:	4b50      	ldr	r3, [pc, #320]	; (1a001134 <PonPisoActualDisplay+0x150>)
1a000ff2:	781b      	ldrb	r3, [r3, #0]
1a000ff4:	2b01      	cmp	r3, #1
1a000ff6:	d015      	beq.n	1a001024 <PonPisoActualDisplay+0x40>
1a000ff8:	2b02      	cmp	r3, #2
1a000ffa:	d013      	beq.n	1a001024 <PonPisoActualDisplay+0x40>
	{
	decenasB = LETRA_P;
1a000ffc:	2216      	movs	r2, #22
1a000ffe:	4b4e      	ldr	r3, [pc, #312]	; (1a001138 <PonPisoActualDisplay+0x154>)
1a001000:	701a      	strb	r2, [r3, #0]
	unidadesB = LETRA_b;
1a001002:	220b      	movs	r2, #11
1a001004:	4b4d      	ldr	r3, [pc, #308]	; (1a00113c <PonPisoActualDisplay+0x158>)
1a001006:	701a      	strb	r2, [r3, #0]
	centenasB = DIGITOAPAGADO;
1a001008:	231a      	movs	r3, #26
1a00100a:	4a4d      	ldr	r2, [pc, #308]	; (1a001140 <PonPisoActualDisplay+0x15c>)
1a00100c:	7013      	strb	r3, [r2, #0]
	unidadesmilB = DIGITOAPAGADO;
1a00100e:	4a4d      	ldr	r2, [pc, #308]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a001010:	7013      	strb	r3, [r2, #0]
		unidadesmilB = LETRA_b;
}
	
	

switch (secuenciaB){
1a001012:	4b4d      	ldr	r3, [pc, #308]	; (1a001148 <PonPisoActualDisplay+0x164>)
1a001014:	781b      	ldrb	r3, [r3, #0]
1a001016:	2b03      	cmp	r3, #3
1a001018:	f200 8084 	bhi.w	1a001124 <PonPisoActualDisplay+0x140>
1a00101c:	e8df f003 	tbb	[pc, r3]
1a001020:	7d73695f 	.word	0x7d73695f
	ConvierteByte(abs(pisoActual), valores);
1a001024:	2800      	cmp	r0, #0
1a001026:	bfb8      	it	lt
1a001028:	4240      	neglt	r0, r0
1a00102a:	a901      	add	r1, sp, #4
1a00102c:	b2c0      	uxtb	r0, r0
1a00102e:	f7ff ffb9 	bl	1a000fa4 <ConvierteByte>
	if (pisoActual == 0)
1a001032:	4b3f      	ldr	r3, [pc, #252]	; (1a001130 <PonPisoActualDisplay+0x14c>)
1a001034:	f993 3000 	ldrsb.w	r3, [r3]
1a001038:	b9c3      	cbnz	r3, 1a00106c <PonPisoActualDisplay+0x88>
		decenasB = LETRA_P;
1a00103a:	2216      	movs	r2, #22
1a00103c:	4b3e      	ldr	r3, [pc, #248]	; (1a001138 <PonPisoActualDisplay+0x154>)
1a00103e:	701a      	strb	r2, [r3, #0]
		unidadesB = LETRA_b;
1a001040:	220b      	movs	r2, #11
1a001042:	4b3e      	ldr	r3, [pc, #248]	; (1a00113c <PonPisoActualDisplay+0x158>)
1a001044:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a001046:	231a      	movs	r3, #26
1a001048:	4a3d      	ldr	r2, [pc, #244]	; (1a001140 <PonPisoActualDisplay+0x15c>)
1a00104a:	7013      	strb	r3, [r2, #0]
		unidadesmilB = DIGITOAPAGADO;
1a00104c:	4a3d      	ldr	r2, [pc, #244]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a00104e:	7013      	strb	r3, [r2, #0]
	if (estadoActualAsc == YENDO_A_PLANTA_BAJA)
1a001050:	4b38      	ldr	r3, [pc, #224]	; (1a001134 <PonPisoActualDisplay+0x150>)
1a001052:	781b      	ldrb	r3, [r3, #0]
1a001054:	2b04      	cmp	r3, #4
1a001056:	d027      	beq.n	1a0010a8 <PonPisoActualDisplay+0xc4>
	else if (estadoActualAsc == PARADO)
1a001058:	2b03      	cmp	r3, #3
1a00105a:	d038      	beq.n	1a0010ce <PonPisoActualDisplay+0xea>
	else if (estadoActualAsc == SUBIENDO)
1a00105c:	2b01      	cmp	r3, #1
1a00105e:	d03a      	beq.n	1a0010d6 <PonPisoActualDisplay+0xf2>
	else if (estadoActualAsc == BAJANDO)
1a001060:	2b02      	cmp	r3, #2
1a001062:	d1d6      	bne.n	1a001012 <PonPisoActualDisplay+0x2e>
		unidadesmilB = LETRA_b;
1a001064:	220b      	movs	r2, #11
1a001066:	4b37      	ldr	r3, [pc, #220]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a001068:	701a      	strb	r2, [r3, #0]
1a00106a:	e7d2      	b.n	1a001012 <PonPisoActualDisplay+0x2e>
	else if (pisoActual > 0)
1a00106c:	2b00      	cmp	r3, #0
1a00106e:	dd10      	ble.n	1a001092 <PonPisoActualDisplay+0xae>
		if (!valores[1])
1a001070:	f89d 3005 	ldrb.w	r3, [sp, #5]
1a001074:	b953      	cbnz	r3, 1a00108c <PonPisoActualDisplay+0xa8>
			decenasB = DIGITOAPAGADO;
1a001076:	221a      	movs	r2, #26
1a001078:	4b2f      	ldr	r3, [pc, #188]	; (1a001138 <PonPisoActualDisplay+0x154>)
1a00107a:	701a      	strb	r2, [r3, #0]
		unidadesB = valores[0];
1a00107c:	f89d 2004 	ldrb.w	r2, [sp, #4]
1a001080:	4b2e      	ldr	r3, [pc, #184]	; (1a00113c <PonPisoActualDisplay+0x158>)
1a001082:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a001084:	221a      	movs	r2, #26
1a001086:	4b2e      	ldr	r3, [pc, #184]	; (1a001140 <PonPisoActualDisplay+0x15c>)
1a001088:	701a      	strb	r2, [r3, #0]
1a00108a:	e7e1      	b.n	1a001050 <PonPisoActualDisplay+0x6c>
		else	decenasB = valores[1];
1a00108c:	4a2a      	ldr	r2, [pc, #168]	; (1a001138 <PonPisoActualDisplay+0x154>)
1a00108e:	7013      	strb	r3, [r2, #0]
1a001090:	e7f4      	b.n	1a00107c <PonPisoActualDisplay+0x98>
		decenasB = 25;
1a001092:	2219      	movs	r2, #25
1a001094:	4b28      	ldr	r3, [pc, #160]	; (1a001138 <PonPisoActualDisplay+0x154>)
1a001096:	701a      	strb	r2, [r3, #0]
		unidadesB = valores[0];
1a001098:	f89d 2004 	ldrb.w	r2, [sp, #4]
1a00109c:	4b27      	ldr	r3, [pc, #156]	; (1a00113c <PonPisoActualDisplay+0x158>)
1a00109e:	701a      	strb	r2, [r3, #0]
		centenasB = DIGITOAPAGADO;
1a0010a0:	221a      	movs	r2, #26
1a0010a2:	4b27      	ldr	r3, [pc, #156]	; (1a001140 <PonPisoActualDisplay+0x15c>)
1a0010a4:	701a      	strb	r2, [r3, #0]
1a0010a6:	e7d3      	b.n	1a001050 <PonPisoActualDisplay+0x6c>
		if (pisoActual > 0)
1a0010a8:	4b21      	ldr	r3, [pc, #132]	; (1a001130 <PonPisoActualDisplay+0x14c>)
1a0010aa:	f993 3000 	ldrsb.w	r3, [r3]
1a0010ae:	2b00      	cmp	r3, #0
1a0010b0:	dd03      	ble.n	1a0010ba <PonPisoActualDisplay+0xd6>
			unidadesmilB = LETRA_b;
1a0010b2:	220b      	movs	r2, #11
1a0010b4:	4b23      	ldr	r3, [pc, #140]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a0010b6:	701a      	strb	r2, [r3, #0]
1a0010b8:	e7ab      	b.n	1a001012 <PonPisoActualDisplay+0x2e>
		else if (pisoActual < 0) 
1a0010ba:	2b00      	cmp	r3, #0
1a0010bc:	db03      	blt.n	1a0010c6 <PonPisoActualDisplay+0xe2>
		else	unidadesmilB = DIGITOAPAGADO;
1a0010be:	221a      	movs	r2, #26
1a0010c0:	4b20      	ldr	r3, [pc, #128]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a0010c2:	701a      	strb	r2, [r3, #0]
1a0010c4:	e7a5      	b.n	1a001012 <PonPisoActualDisplay+0x2e>
			unidadesmilB = LETRA_S;
1a0010c6:	2205      	movs	r2, #5
1a0010c8:	4b1e      	ldr	r3, [pc, #120]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a0010ca:	701a      	strb	r2, [r3, #0]
1a0010cc:	e7a1      	b.n	1a001012 <PonPisoActualDisplay+0x2e>
		unidadesmilB = DIGITOAPAGADO;
1a0010ce:	221a      	movs	r2, #26
1a0010d0:	4b1c      	ldr	r3, [pc, #112]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a0010d2:	701a      	strb	r2, [r3, #0]
1a0010d4:	e79d      	b.n	1a001012 <PonPisoActualDisplay+0x2e>
		unidadesmilB = LETRA_S;
1a0010d6:	2205      	movs	r2, #5
1a0010d8:	4b1a      	ldr	r3, [pc, #104]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a0010da:	701a      	strb	r2, [r3, #0]
1a0010dc:	e799      	b.n	1a001012 <PonPisoActualDisplay+0x2e>
	case 0:
		SacaDigito (unidadesB, LCD1);
1a0010de:	2110      	movs	r1, #16
1a0010e0:	4b16      	ldr	r3, [pc, #88]	; (1a00113c <PonPisoActualDisplay+0x158>)
1a0010e2:	7818      	ldrb	r0, [r3, #0]
1a0010e4:	f7ff ff30 	bl	1a000f48 <SacaDigito>
		secuenciaB++;
1a0010e8:	4a17      	ldr	r2, [pc, #92]	; (1a001148 <PonPisoActualDisplay+0x164>)
1a0010ea:	7813      	ldrb	r3, [r2, #0]
1a0010ec:	3301      	adds	r3, #1
1a0010ee:	7013      	strb	r3, [r2, #0]
		break;
1a0010f0:	e01b      	b.n	1a00112a <PonPisoActualDisplay+0x146>
	case 1:
		SacaDigito (decenasB, LCD2);
1a0010f2:	2111      	movs	r1, #17
1a0010f4:	4b10      	ldr	r3, [pc, #64]	; (1a001138 <PonPisoActualDisplay+0x154>)
1a0010f6:	7818      	ldrb	r0, [r3, #0]
1a0010f8:	f7ff ff26 	bl	1a000f48 <SacaDigito>
		secuenciaB++;
1a0010fc:	4a12      	ldr	r2, [pc, #72]	; (1a001148 <PonPisoActualDisplay+0x164>)
1a0010fe:	7813      	ldrb	r3, [r2, #0]
1a001100:	3301      	adds	r3, #1
1a001102:	7013      	strb	r3, [r2, #0]
		break;
1a001104:	e011      	b.n	1a00112a <PonPisoActualDisplay+0x146>
	case 2:
		SacaDigito (centenasB, LCD3);
1a001106:	2112      	movs	r1, #18
1a001108:	4b0d      	ldr	r3, [pc, #52]	; (1a001140 <PonPisoActualDisplay+0x15c>)
1a00110a:	7818      	ldrb	r0, [r3, #0]
1a00110c:	f7ff ff1c 	bl	1a000f48 <SacaDigito>
		secuenciaB++;
1a001110:	4a0d      	ldr	r2, [pc, #52]	; (1a001148 <PonPisoActualDisplay+0x164>)
1a001112:	7813      	ldrb	r3, [r2, #0]
1a001114:	3301      	adds	r3, #1
1a001116:	7013      	strb	r3, [r2, #0]
		break;
1a001118:	e007      	b.n	1a00112a <PonPisoActualDisplay+0x146>
	case 3:
		SacaDigito (unidadesmilB, LCD4);
1a00111a:	2114      	movs	r1, #20
1a00111c:	4b09      	ldr	r3, [pc, #36]	; (1a001144 <PonPisoActualDisplay+0x160>)
1a00111e:	7818      	ldrb	r0, [r3, #0]
1a001120:	f7ff ff12 	bl	1a000f48 <SacaDigito>
	
	default:
		secuenciaB = 0;
1a001124:	2200      	movs	r2, #0
1a001126:	4b08      	ldr	r3, [pc, #32]	; (1a001148 <PonPisoActualDisplay+0x164>)
1a001128:	701a      	strb	r2, [r3, #0]
		break;
	}
	
}
1a00112a:	b003      	add	sp, #12
1a00112c:	f85d fb04 	ldr.w	pc, [sp], #4
1a001130:	10000086 	.word	0x10000086
1a001134:	10000118 	.word	0x10000118
1a001138:	100000bf 	.word	0x100000bf
1a00113c:	100000c1 	.word	0x100000c1
1a001140:	100000be 	.word	0x100000be
1a001144:	100000c2 	.word	0x100000c2
1a001148:	100000c0 	.word	0x100000c0

1a00114c <SystemCoreClockUpdate>:


/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
1a00114c:	b508      	push	{r3, lr}
   /* CPU core speed */
   SystemCoreClock = Chip_Clock_GetRate(CLK_MX_MXCORE);
1a00114e:	2069      	movs	r0, #105	; 0x69
1a001150:	f000 fa86 	bl	1a001660 <Chip_Clock_GetRate>
1a001154:	4b01      	ldr	r3, [pc, #4]	; (1a00115c <SystemCoreClockUpdate+0x10>)
1a001156:	6018      	str	r0, [r3, #0]
1a001158:	bd08      	pop	{r3, pc}
1a00115a:	bf00      	nop
1a00115c:	100001a8 	.word	0x100001a8

1a001160 <pll_calc_divs>:
       return -val;
   return val;
}

static void pll_calc_divs(uint32_t freq, PLL_PARAM_T *ppll)
{
1a001160:	b5f0      	push	{r4, r5, r6, r7, lr}

   uint32_t prev = freq;
   int n, m, p;

   /* When direct mode is set FBSEL should be a don't care */
   if (ppll->ctrl & (1 << 7)) {
1a001162:	680b      	ldr	r3, [r1, #0]
1a001164:	f013 0f80 	tst.w	r3, #128	; 0x80
1a001168:	d002      	beq.n	1a001170 <pll_calc_divs+0x10>
       ppll->ctrl &= ~(1 << 6);
1a00116a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
1a00116e:	600b      	str	r3, [r1, #0]
1a001170:	4607      	mov	r7, r0
1a001172:	2501      	movs	r5, #1
1a001174:	e03b      	b.n	1a0011ee <pll_calc_divs+0x8e>
           for (m = 1; m <= 256; m++) {
               uint32_t fcco, fout;
               if (ppll->ctrl & (1 << 6)) {
                   fcco = ((m << (p + 1)) * ppll->fin) / n;
               } else {
                   fcco = (m * ppll->fin) / n;
1a001176:	694b      	ldr	r3, [r1, #20]
1a001178:	fb03 f302 	mul.w	r3, r3, r2
1a00117c:	fbb3 f3f5 	udiv	r3, r3, r5
1a001180:	e014      	b.n	1a0011ac <pll_calc_divs+0x4c>
               }
               if (fcco < PLL_MIN_CCO_FREQ) continue;
               if (fcco > PLL_MAX_CCO_FREQ) break;
               if (ppll->ctrl & (1 << 7)) {
                   fout = fcco;
1a001182:	461c      	mov	r4, r3
1a001184:	e020      	b.n	1a0011c8 <pll_calc_divs+0x68>
       return -val;
1a001186:	f1ce 0e00 	rsb	lr, lr, #0
1a00118a:	e020      	b.n	1a0011ce <pll_calc_divs+0x6e>
           for (m = 1; m <= 256; m++) {
1a00118c:	3201      	adds	r2, #1
1a00118e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
1a001192:	dc26      	bgt.n	1a0011e2 <pll_calc_divs+0x82>
               if (ppll->ctrl & (1 << 6)) {
1a001194:	680c      	ldr	r4, [r1, #0]
1a001196:	f014 0f40 	tst.w	r4, #64	; 0x40
1a00119a:	d0ec      	beq.n	1a001176 <pll_calc_divs+0x16>
                   fcco = ((m << (p + 1)) * ppll->fin) / n;
1a00119c:	1c73      	adds	r3, r6, #1
1a00119e:	fa02 fe03 	lsl.w	lr, r2, r3
1a0011a2:	694b      	ldr	r3, [r1, #20]
1a0011a4:	fb03 f30e 	mul.w	r3, r3, lr
1a0011a8:	fbb3 f3f5 	udiv	r3, r3, r5
               if (fcco < PLL_MIN_CCO_FREQ) continue;
1a0011ac:	f8df e048 	ldr.w	lr, [pc, #72]	; 1a0011f8 <pll_calc_divs+0x98>
1a0011b0:	4573      	cmp	r3, lr
1a0011b2:	d9eb      	bls.n	1a00118c <pll_calc_divs+0x2c>
               if (fcco > PLL_MAX_CCO_FREQ) break;
1a0011b4:	f8df e044 	ldr.w	lr, [pc, #68]	; 1a0011fc <pll_calc_divs+0x9c>
1a0011b8:	4573      	cmp	r3, lr
1a0011ba:	d812      	bhi.n	1a0011e2 <pll_calc_divs+0x82>
               if (ppll->ctrl & (1 << 7)) {
1a0011bc:	f014 0f80 	tst.w	r4, #128	; 0x80
1a0011c0:	d1df      	bne.n	1a001182 <pll_calc_divs+0x22>
               } else {
                   fout = fcco >> (p + 1);
1a0011c2:	1c74      	adds	r4, r6, #1
1a0011c4:	fa23 f404 	lsr.w	r4, r3, r4
   if (val < 0)
1a0011c8:	ebb0 0e04 	subs.w	lr, r0, r4
1a0011cc:	d4db      	bmi.n	1a001186 <pll_calc_divs+0x26>
               }

               if (ABS(freq - fout) < prev) {
1a0011ce:	4577      	cmp	r7, lr
1a0011d0:	d9dc      	bls.n	1a00118c <pll_calc_divs+0x2c>
                   ppll->nsel = n;
1a0011d2:	608d      	str	r5, [r1, #8]
                   ppll->psel = p + 1;
1a0011d4:	1c77      	adds	r7, r6, #1
1a0011d6:	60cf      	str	r7, [r1, #12]
                   ppll->msel = m;
1a0011d8:	610a      	str	r2, [r1, #16]
                   ppll->fout = fout;
1a0011da:	618c      	str	r4, [r1, #24]
                   ppll->fcco = fcco;
1a0011dc:	61cb      	str	r3, [r1, #28]
                   prev = ABS(freq - fout);
1a0011de:	4677      	mov	r7, lr
1a0011e0:	e7d4      	b.n	1a00118c <pll_calc_divs+0x2c>
       for (p = 0; p < 4; p ++) {
1a0011e2:	3601      	adds	r6, #1
1a0011e4:	2e03      	cmp	r6, #3
1a0011e6:	dc01      	bgt.n	1a0011ec <pll_calc_divs+0x8c>
1a0011e8:	2201      	movs	r2, #1
1a0011ea:	e7d0      	b.n	1a00118e <pll_calc_divs+0x2e>
   for (n = 1; n <= 4; n++) {
1a0011ec:	3501      	adds	r5, #1
1a0011ee:	2d04      	cmp	r5, #4
1a0011f0:	dc01      	bgt.n	1a0011f6 <pll_calc_divs+0x96>
1a0011f2:	2600      	movs	r6, #0
1a0011f4:	e7f6      	b.n	1a0011e4 <pll_calc_divs+0x84>
               }
           }
       }
   }
}
1a0011f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
1a0011f8:	094c5eff 	.word	0x094c5eff
1a0011fc:	1312d000 	.word	0x1312d000

1a001200 <pll_get_frac>:

static void pll_get_frac(uint32_t freq, PLL_PARAM_T *ppll)
{
1a001200:	b5f0      	push	{r4, r5, r6, r7, lr}
1a001202:	b099      	sub	sp, #100	; 0x64
1a001204:	4605      	mov	r5, r0
1a001206:	460c      	mov	r4, r1
   int diff[3];
   PLL_PARAM_T pll[3] = {{0},{0},{0}};
1a001208:	2260      	movs	r2, #96	; 0x60
1a00120a:	2100      	movs	r1, #0
1a00120c:	4668      	mov	r0, sp
1a00120e:	f001 f993 	bl	1a002538 <memset>

   /* Try direct mode */
   pll[0].ctrl |= (1 << 7);
1a001212:	2380      	movs	r3, #128	; 0x80
1a001214:	9300      	str	r3, [sp, #0]
   pll[0].fin = ppll->fin;
1a001216:	6963      	ldr	r3, [r4, #20]
1a001218:	9305      	str	r3, [sp, #20]
   pll[0].srcin = ppll->srcin;
1a00121a:	7923      	ldrb	r3, [r4, #4]
1a00121c:	f88d 3004 	strb.w	r3, [sp, #4]
   pll_calc_divs(freq, &pll[0]);
1a001220:	4669      	mov	r1, sp
1a001222:	4628      	mov	r0, r5
1a001224:	f7ff ff9c 	bl	1a001160 <pll_calc_divs>
   if (pll[0].fout == freq) {
1a001228:	9b06      	ldr	r3, [sp, #24]
1a00122a:	429d      	cmp	r5, r3
1a00122c:	d02f      	beq.n	1a00128e <pll_get_frac+0x8e>
   if (val < 0)
1a00122e:	1aeb      	subs	r3, r5, r3
1a001230:	d436      	bmi.n	1a0012a0 <pll_get_frac+0xa0>
       *ppll = pll[0];
       return ;
   }
   diff[0] = ABS(freq - pll[0].fout);
1a001232:	461e      	mov	r6, r3

   /* Try non-Integer mode */
   pll[2].ctrl = (1 << 6);
1a001234:	2340      	movs	r3, #64	; 0x40
1a001236:	9310      	str	r3, [sp, #64]	; 0x40
   pll[2].fin = ppll->fin;
1a001238:	6963      	ldr	r3, [r4, #20]
1a00123a:	9315      	str	r3, [sp, #84]	; 0x54
   pll[2].srcin = ppll->srcin;
1a00123c:	7923      	ldrb	r3, [r4, #4]
1a00123e:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
   pll_calc_divs(freq, &pll[2]);
1a001242:	a910      	add	r1, sp, #64	; 0x40
1a001244:	4628      	mov	r0, r5
1a001246:	f7ff ff8b 	bl	1a001160 <pll_calc_divs>
   if (pll[2].fout == freq) {
1a00124a:	9b16      	ldr	r3, [sp, #88]	; 0x58
1a00124c:	429d      	cmp	r5, r3
1a00124e:	d029      	beq.n	1a0012a4 <pll_get_frac+0xa4>
   if (val < 0)
1a001250:	1aeb      	subs	r3, r5, r3
1a001252:	d42f      	bmi.n	1a0012b4 <pll_get_frac+0xb4>
       *ppll = pll[2];
       return ;
   }

   diff[2] = ABS(freq - pll[2].fout);
1a001254:	461f      	mov	r7, r3
   /* Try integer mode */
   pll[1].ctrl = (1 << 6);
1a001256:	2340      	movs	r3, #64	; 0x40
1a001258:	9308      	str	r3, [sp, #32]
   pll[1].fin = ppll->fin;
1a00125a:	6963      	ldr	r3, [r4, #20]
1a00125c:	930d      	str	r3, [sp, #52]	; 0x34
   pll[1].srcin = ppll->srcin;
1a00125e:	7923      	ldrb	r3, [r4, #4]
1a001260:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   pll_calc_divs(freq, &pll[1]);
1a001264:	a908      	add	r1, sp, #32
1a001266:	4628      	mov	r0, r5
1a001268:	f7ff ff7a 	bl	1a001160 <pll_calc_divs>
   if (pll[1].fout == freq) {
1a00126c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1a00126e:	429d      	cmp	r5, r3
1a001270:	d022      	beq.n	1a0012b8 <pll_get_frac+0xb8>
   if (val < 0)
1a001272:	1aed      	subs	r5, r5, r3
1a001274:	d428      	bmi.n	1a0012c8 <pll_get_frac+0xc8>
       return ;
   }
   diff[1] = ABS(freq - pll[1].fout);

   /* Find the min of 3 and return */
   if (diff[0] <= diff[1]) {
1a001276:	42ae      	cmp	r6, r5
1a001278:	dc30      	bgt.n	1a0012dc <pll_get_frac+0xdc>
       if (diff[0] <= diff[2]) {
1a00127a:	42be      	cmp	r6, r7
1a00127c:	dc26      	bgt.n	1a0012cc <pll_get_frac+0xcc>
           *ppll = pll[0];
1a00127e:	466d      	mov	r5, sp
1a001280:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001282:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a001284:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a001288:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a00128c:	e006      	b.n	1a00129c <pll_get_frac+0x9c>
       *ppll = pll[0];
1a00128e:	466d      	mov	r5, sp
1a001290:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a001292:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a001294:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a001298:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
           *ppll = pll[1];
       } else {
           *ppll = pll[2];
       }
   }
}
1a00129c:	b019      	add	sp, #100	; 0x64
1a00129e:	bdf0      	pop	{r4, r5, r6, r7, pc}
       return -val;
1a0012a0:	425b      	negs	r3, r3
1a0012a2:	e7c6      	b.n	1a001232 <pll_get_frac+0x32>
       *ppll = pll[2];
1a0012a4:	ad10      	add	r5, sp, #64	; 0x40
1a0012a6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0012a8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0012aa:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0012ae:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
       return ;
1a0012b2:	e7f3      	b.n	1a00129c <pll_get_frac+0x9c>
       return -val;
1a0012b4:	425b      	negs	r3, r3
1a0012b6:	e7cd      	b.n	1a001254 <pll_get_frac+0x54>
       *ppll = pll[1];
1a0012b8:	ad08      	add	r5, sp, #32
1a0012ba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0012bc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0012be:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0012c2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
       return ;
1a0012c6:	e7e9      	b.n	1a00129c <pll_get_frac+0x9c>
       return -val;
1a0012c8:	426d      	negs	r5, r5
1a0012ca:	e7d4      	b.n	1a001276 <pll_get_frac+0x76>
           *ppll = pll[2];
1a0012cc:	ad10      	add	r5, sp, #64	; 0x40
1a0012ce:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0012d0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0012d2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0012d6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a0012da:	e7df      	b.n	1a00129c <pll_get_frac+0x9c>
       if (diff[1] <= diff[2]) {
1a0012dc:	42af      	cmp	r7, r5
1a0012de:	db07      	blt.n	1a0012f0 <pll_get_frac+0xf0>
           *ppll = pll[1];
1a0012e0:	ad08      	add	r5, sp, #32
1a0012e2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0012e4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0012e6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0012ea:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a0012ee:	e7d5      	b.n	1a00129c <pll_get_frac+0x9c>
           *ppll = pll[2];
1a0012f0:	ad10      	add	r5, sp, #64	; 0x40
1a0012f2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a0012f4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a0012f6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a0012fa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a0012fe:	e7cd      	b.n	1a00129c <pll_get_frac+0x9c>

1a001300 <Chip_Clock_FindBaseClock>:
   return Chip_Clock_GetClockInputHz(input) / (div + 1);
}

/* Finds the base clock for the peripheral clock */
static CHIP_CGU_BASE_CLK_T Chip_Clock_FindBaseClock(CHIP_CCU_CLK_T clk)
{
1a001300:	b430      	push	{r4, r5}
1a001302:	4605      	mov	r5, r0
   CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
   int i = 0;
1a001304:	2300      	movs	r3, #0
   CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
1a001306:	201c      	movs	r0, #28

   while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
1a001308:	e000      	b.n	1a00130c <Chip_Clock_FindBaseClock+0xc>
       if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
           baseclk = periph_to_base[i].clkbase;
       }
       else {
           i++;
1a00130a:	3301      	adds	r3, #1
   while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
1a00130c:	281c      	cmp	r0, #28
1a00130e:	d118      	bne.n	1a001342 <Chip_Clock_FindBaseClock+0x42>
1a001310:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a001314:	0051      	lsls	r1, r2, #1
1a001316:	4a0c      	ldr	r2, [pc, #48]	; (1a001348 <Chip_Clock_FindBaseClock+0x48>)
1a001318:	440a      	add	r2, r1
1a00131a:	7914      	ldrb	r4, [r2, #4]
1a00131c:	42a0      	cmp	r0, r4
1a00131e:	d010      	beq.n	1a001342 <Chip_Clock_FindBaseClock+0x42>
       if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
1a001320:	eb03 0143 	add.w	r1, r3, r3, lsl #1
1a001324:	004a      	lsls	r2, r1, #1
1a001326:	4908      	ldr	r1, [pc, #32]	; (1a001348 <Chip_Clock_FindBaseClock+0x48>)
1a001328:	5a8a      	ldrh	r2, [r1, r2]
1a00132a:	42aa      	cmp	r2, r5
1a00132c:	d8ed      	bhi.n	1a00130a <Chip_Clock_FindBaseClock+0xa>
1a00132e:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a001332:	0051      	lsls	r1, r2, #1
1a001334:	4a04      	ldr	r2, [pc, #16]	; (1a001348 <Chip_Clock_FindBaseClock+0x48>)
1a001336:	440a      	add	r2, r1
1a001338:	8852      	ldrh	r2, [r2, #2]
1a00133a:	4295      	cmp	r5, r2
1a00133c:	d8e5      	bhi.n	1a00130a <Chip_Clock_FindBaseClock+0xa>
           baseclk = periph_to_base[i].clkbase;
1a00133e:	4620      	mov	r0, r4
1a001340:	e7e4      	b.n	1a00130c <Chip_Clock_FindBaseClock+0xc>
       }
   }

   return baseclk;
}
1a001342:	bc30      	pop	{r4, r5}
1a001344:	4770      	bx	lr
1a001346:	bf00      	nop
1a001348:	1a002810 	.word	0x1a002810

1a00134c <Chip_Clock_EnableCrystal>:
 * Public functions
 ****************************************************************************/

/* Enables the crystal oscillator */
void Chip_Clock_EnableCrystal(void)
{
1a00134c:	b082      	sub	sp, #8
   volatile uint32_t delay = 1000;
1a00134e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
1a001352:	9301      	str	r3, [sp, #4]

   uint32_t OldCrystalConfig = LPC_CGU->XTAL_OSC_CTRL;
1a001354:	4a0d      	ldr	r2, [pc, #52]	; (1a00138c <Chip_Clock_EnableCrystal+0x40>)
1a001356:	6993      	ldr	r3, [r2, #24]

   /* Clear bypass mode */
   OldCrystalConfig &= (~2);
1a001358:	f023 0102 	bic.w	r1, r3, #2
   if (OldCrystalConfig != LPC_CGU->XTAL_OSC_CTRL) {
1a00135c:	6992      	ldr	r2, [r2, #24]
1a00135e:	4291      	cmp	r1, r2
1a001360:	d001      	beq.n	1a001366 <Chip_Clock_EnableCrystal+0x1a>
       LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
1a001362:	4a0a      	ldr	r2, [pc, #40]	; (1a00138c <Chip_Clock_EnableCrystal+0x40>)
1a001364:	6191      	str	r1, [r2, #24]
   }

   /* Enable crystal oscillator */
   OldCrystalConfig &= (~1);
1a001366:	f023 0303 	bic.w	r3, r3, #3
   if (OscRateIn >= 20000000) {
1a00136a:	4a09      	ldr	r2, [pc, #36]	; (1a001390 <Chip_Clock_EnableCrystal+0x44>)
1a00136c:	6811      	ldr	r1, [r2, #0]
1a00136e:	4a09      	ldr	r2, [pc, #36]	; (1a001394 <Chip_Clock_EnableCrystal+0x48>)
1a001370:	4291      	cmp	r1, r2
1a001372:	d901      	bls.n	1a001378 <Chip_Clock_EnableCrystal+0x2c>
       OldCrystalConfig |= 4;  /* Set high frequency mode */
1a001374:	f043 0304 	orr.w	r3, r3, #4

   }
   LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
1a001378:	4a04      	ldr	r2, [pc, #16]	; (1a00138c <Chip_Clock_EnableCrystal+0x40>)
1a00137a:	6193      	str	r3, [r2, #24]

   /* Delay for 250uSec */
   while(delay--) {}
1a00137c:	9b01      	ldr	r3, [sp, #4]
1a00137e:	1e5a      	subs	r2, r3, #1
1a001380:	9201      	str	r2, [sp, #4]
1a001382:	2b00      	cmp	r3, #0
1a001384:	d1fa      	bne.n	1a00137c <Chip_Clock_EnableCrystal+0x30>
}
1a001386:	b002      	add	sp, #8
1a001388:	4770      	bx	lr
1a00138a:	bf00      	nop
1a00138c:	40050000 	.word	0x40050000
1a001390:	1a0028d8 	.word	0x1a0028d8
1a001394:	01312cff 	.word	0x01312cff

1a001398 <Chip_Clock_GetDividerSource>:
}

/* Gets a CGU clock divider source */
CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider)
{
   uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];
1a001398:	3012      	adds	r0, #18
1a00139a:	4b05      	ldr	r3, [pc, #20]	; (1a0013b0 <Chip_Clock_GetDividerSource+0x18>)
1a00139c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

   if (reg & 1) {  /* divider is powered down */
1a0013a0:	f010 0f01 	tst.w	r0, #1
1a0013a4:	d001      	beq.n	1a0013aa <Chip_Clock_GetDividerSource+0x12>
       return CLKINPUT_PD;
1a0013a6:	2011      	movs	r0, #17
   }

   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
}
1a0013a8:	4770      	bx	lr
   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
1a0013aa:	f3c0 6004 	ubfx	r0, r0, #24, #5
1a0013ae:	4770      	bx	lr
1a0013b0:	40050000 	.word	0x40050000

1a0013b4 <Chip_Clock_GetDividerDivisor>:

/* Gets a CGU clock divider divisor */
uint32_t Chip_Clock_GetDividerDivisor(CHIP_CGU_IDIV_T Divider)
{
   return (CHIP_CGU_CLKIN_T) ((LPC_CGU->IDIV_CTRL[Divider] >> 2) & CHIP_CGU_IDIV_MASK(Divider));
1a0013b4:	f100 0212 	add.w	r2, r0, #18
1a0013b8:	4b03      	ldr	r3, [pc, #12]	; (1a0013c8 <Chip_Clock_GetDividerDivisor+0x14>)
1a0013ba:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
1a0013be:	4b03      	ldr	r3, [pc, #12]	; (1a0013cc <Chip_Clock_GetDividerDivisor+0x18>)
1a0013c0:	5c18      	ldrb	r0, [r3, r0]
}
1a0013c2:	ea00 0092 	and.w	r0, r0, r2, lsr #2
1a0013c6:	4770      	bx	lr
1a0013c8:	40050000 	.word	0x40050000
1a0013cc:	1a002808 	.word	0x1a002808

1a0013d0 <Chip_Clock_GetClockInputHz>:

/* Returns the frequency of the specified input clock source */
uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input)
{
1a0013d0:	b508      	push	{r3, lr}
   uint32_t rate = 0;

   switch (input) {
1a0013d2:	2810      	cmp	r0, #16
1a0013d4:	d80a      	bhi.n	1a0013ec <Chip_Clock_GetClockInputHz+0x1c>
1a0013d6:	e8df f000 	tbb	[pc, r0]
1a0013da:	0b44      	.short	0x0b44
1a0013dc:	0921180d 	.word	0x0921180d
1a0013e0:	2d2a2724 	.word	0x2d2a2724
1a0013e4:	34300909 	.word	0x34300909
1a0013e8:	3c38      	.short	0x3c38
1a0013ea:	40          	.byte	0x40
1a0013eb:	00          	.byte	0x00
   uint32_t rate = 0;
1a0013ec:	2000      	movs	r0, #0
1a0013ee:	bd08      	pop	{r3, pc}
   case CLKIN_32K:
       rate = CRYSTAL_32K_FREQ_IN;
       break;

   case CLKIN_IRC:
       rate = CGU_IRC_FREQ;
1a0013f0:	481e      	ldr	r0, [pc, #120]	; (1a00146c <Chip_Clock_GetClockInputHz+0x9c>)
       break;
1a0013f2:	bd08      	pop	{r3, pc}

   case CLKIN_ENET_RX:
       if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
1a0013f4:	4b1e      	ldr	r3, [pc, #120]	; (1a001470 <Chip_Clock_GetClockInputHz+0xa0>)
1a0013f6:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
1a0013fa:	f003 0307 	and.w	r3, r3, #7
1a0013fe:	2b04      	cmp	r3, #4
1a001400:	d001      	beq.n	1a001406 <Chip_Clock_GetClockInputHz+0x36>
           /* MII mode requires 25MHz clock */
           rate = 25000000;
1a001402:	481c      	ldr	r0, [pc, #112]	; (1a001474 <Chip_Clock_GetClockInputHz+0xa4>)
1a001404:	bd08      	pop	{r3, pc}
   uint32_t rate = 0;
1a001406:	2000      	movs	r0, #0
1a001408:	bd08      	pop	{r3, pc}
       }
       break;

   case CLKIN_ENET_TX:
       if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
1a00140a:	4b19      	ldr	r3, [pc, #100]	; (1a001470 <Chip_Clock_GetClockInputHz+0xa0>)
1a00140c:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
1a001410:	f003 0307 	and.w	r3, r3, #7
1a001414:	2b04      	cmp	r3, #4
1a001416:	d027      	beq.n	1a001468 <Chip_Clock_GetClockInputHz+0x98>
           rate = 25000000; /* MII uses 25 MHz */
1a001418:	4816      	ldr	r0, [pc, #88]	; (1a001474 <Chip_Clock_GetClockInputHz+0xa4>)
1a00141a:	bd08      	pop	{r3, pc}
           rate = 50000000; /* RMII uses 50 MHz */
       }
       break;

   case CLKIN_CLKIN:
       rate = ExtRateIn;
1a00141c:	4b16      	ldr	r3, [pc, #88]	; (1a001478 <Chip_Clock_GetClockInputHz+0xa8>)
1a00141e:	6818      	ldr	r0, [r3, #0]
       break;
1a001420:	bd08      	pop	{r3, pc}

   case CLKIN_CRYSTAL:
       rate = OscRateIn;
1a001422:	4b16      	ldr	r3, [pc, #88]	; (1a00147c <Chip_Clock_GetClockInputHz+0xac>)
1a001424:	6818      	ldr	r0, [r3, #0]
       break;
1a001426:	bd08      	pop	{r3, pc}

   case CLKIN_USBPLL:
       rate = audio_usb_pll_freq[CGU_USB_PLL];
1a001428:	4b15      	ldr	r3, [pc, #84]	; (1a001480 <Chip_Clock_GetClockInputHz+0xb0>)
1a00142a:	6818      	ldr	r0, [r3, #0]
       break;
1a00142c:	bd08      	pop	{r3, pc}

   case CLKIN_AUDIOPLL:
       rate = audio_usb_pll_freq[CGU_AUDIO_PLL];
1a00142e:	4b14      	ldr	r3, [pc, #80]	; (1a001480 <Chip_Clock_GetClockInputHz+0xb0>)
1a001430:	6858      	ldr	r0, [r3, #4]
       break;
1a001432:	bd08      	pop	{r3, pc}

   case CLKIN_MAINPLL:
       rate = Chip_Clock_GetMainPLLHz();
1a001434:	f000 f868 	bl	1a001508 <Chip_Clock_GetMainPLLHz>
       break;
1a001438:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVA:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_A);
1a00143a:	2100      	movs	r1, #0
1a00143c:	f000 f89a 	bl	1a001574 <Chip_Clock_GetDivRate>
       break;
1a001440:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVB:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_B);
1a001442:	2101      	movs	r1, #1
1a001444:	f000 f896 	bl	1a001574 <Chip_Clock_GetDivRate>
       break;
1a001448:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVC:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_C);
1a00144a:	2102      	movs	r1, #2
1a00144c:	f000 f892 	bl	1a001574 <Chip_Clock_GetDivRate>
       break;
1a001450:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVD:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_D);
1a001452:	2103      	movs	r1, #3
1a001454:	f000 f88e 	bl	1a001574 <Chip_Clock_GetDivRate>
       break;
1a001458:	bd08      	pop	{r3, pc}

   case CLKIN_IDIVE:
       rate = Chip_Clock_GetDivRate(input, CLK_IDIV_E);
1a00145a:	2104      	movs	r1, #4
1a00145c:	f000 f88a 	bl	1a001574 <Chip_Clock_GetDivRate>
       break;
1a001460:	bd08      	pop	{r3, pc}
       rate = CRYSTAL_32K_FREQ_IN;
1a001462:	f44f 4000 	mov.w	r0, #32768	; 0x8000
1a001466:	bd08      	pop	{r3, pc}
           rate = 50000000; /* RMII uses 50 MHz */
1a001468:	4806      	ldr	r0, [pc, #24]	; (1a001484 <Chip_Clock_GetClockInputHz+0xb4>)
   default:
       break;
   }

   return rate;
}
1a00146a:	bd08      	pop	{r3, pc}
1a00146c:	00b71b00 	.word	0x00b71b00
1a001470:	40043000 	.word	0x40043000
1a001474:	017d7840 	.word	0x017d7840
1a001478:	1a0028d4 	.word	0x1a0028d4
1a00147c:	1a0028d8 	.word	0x1a0028d8
1a001480:	100000c4 	.word	0x100000c4
1a001484:	02faf080 	.word	0x02faf080

1a001488 <Chip_Clock_CalcMainPLLValue>:
{
1a001488:	b538      	push	{r3, r4, r5, lr}
1a00148a:	4605      	mov	r5, r0
1a00148c:	460c      	mov	r4, r1
   ppll->fin = Chip_Clock_GetClockInputHz(ppll->srcin);
1a00148e:	7908      	ldrb	r0, [r1, #4]
1a001490:	f7ff ff9e 	bl	1a0013d0 <Chip_Clock_GetClockInputHz>
1a001494:	6160      	str	r0, [r4, #20]
   if (freq > MAX_CLOCK_FREQ || freq < (PLL_MIN_CCO_FREQ / 16) || !ppll->fin) {
1a001496:	4b19      	ldr	r3, [pc, #100]	; (1a0014fc <Chip_Clock_CalcMainPLLValue+0x74>)
1a001498:	442b      	add	r3, r5
1a00149a:	4a19      	ldr	r2, [pc, #100]	; (1a001500 <Chip_Clock_CalcMainPLLValue+0x78>)
1a00149c:	4293      	cmp	r3, r2
1a00149e:	d821      	bhi.n	1a0014e4 <Chip_Clock_CalcMainPLLValue+0x5c>
1a0014a0:	b318      	cbz	r0, 1a0014ea <Chip_Clock_CalcMainPLLValue+0x62>
   ppll->ctrl = 1 << 7; /* Enable direct mode [If possible] */
1a0014a2:	2380      	movs	r3, #128	; 0x80
1a0014a4:	6023      	str	r3, [r4, #0]
   ppll->nsel = 0;
1a0014a6:	2300      	movs	r3, #0
1a0014a8:	60a3      	str	r3, [r4, #8]
   ppll->psel = 0;
1a0014aa:	60e3      	str	r3, [r4, #12]
   ppll->msel = freq / ppll->fin;
1a0014ac:	fbb5 f3f0 	udiv	r3, r5, r0
1a0014b0:	6123      	str	r3, [r4, #16]
   if (freq < PLL_MIN_CCO_FREQ || ppll->msel * ppll->fin != freq) {
1a0014b2:	4a14      	ldr	r2, [pc, #80]	; (1a001504 <Chip_Clock_CalcMainPLLValue+0x7c>)
1a0014b4:	4295      	cmp	r5, r2
1a0014b6:	d903      	bls.n	1a0014c0 <Chip_Clock_CalcMainPLLValue+0x38>
1a0014b8:	fb03 f000 	mul.w	r0, r3, r0
1a0014bc:	4285      	cmp	r5, r0
1a0014be:	d007      	beq.n	1a0014d0 <Chip_Clock_CalcMainPLLValue+0x48>
       pll_get_frac(freq, ppll);
1a0014c0:	4621      	mov	r1, r4
1a0014c2:	4628      	mov	r0, r5
1a0014c4:	f7ff fe9c 	bl	1a001200 <pll_get_frac>
       if (!ppll->nsel) {
1a0014c8:	68a3      	ldr	r3, [r4, #8]
1a0014ca:	b18b      	cbz	r3, 1a0014f0 <Chip_Clock_CalcMainPLLValue+0x68>
       ppll->nsel --;
1a0014cc:	3b01      	subs	r3, #1
1a0014ce:	60a3      	str	r3, [r4, #8]
   if (ppll->msel == 0) {
1a0014d0:	6923      	ldr	r3, [r4, #16]
1a0014d2:	b183      	cbz	r3, 1a0014f6 <Chip_Clock_CalcMainPLLValue+0x6e>
   if (ppll->psel) {
1a0014d4:	68e2      	ldr	r2, [r4, #12]
1a0014d6:	b10a      	cbz	r2, 1a0014dc <Chip_Clock_CalcMainPLLValue+0x54>
       ppll->psel --;
1a0014d8:	3a01      	subs	r2, #1
1a0014da:	60e2      	str	r2, [r4, #12]
   ppll->msel --;
1a0014dc:	3b01      	subs	r3, #1
1a0014de:	6123      	str	r3, [r4, #16]
   return 0;
1a0014e0:	2000      	movs	r0, #0
1a0014e2:	bd38      	pop	{r3, r4, r5, pc}
       return -1;
1a0014e4:	f04f 30ff 	mov.w	r0, #4294967295
1a0014e8:	bd38      	pop	{r3, r4, r5, pc}
1a0014ea:	f04f 30ff 	mov.w	r0, #4294967295
1a0014ee:	bd38      	pop	{r3, r4, r5, pc}
           return -1;
1a0014f0:	f04f 30ff 	mov.w	r0, #4294967295
1a0014f4:	bd38      	pop	{r3, r4, r5, pc}
       return - 1;
1a0014f6:	f04f 30ff 	mov.w	r0, #4294967295
}
1a0014fa:	bd38      	pop	{r3, r4, r5, pc}
1a0014fc:	ff6b3a10 	.word	0xff6b3a10
1a001500:	0b940510 	.word	0x0b940510
1a001504:	094c5eff 	.word	0x094c5eff

1a001508 <Chip_Clock_GetMainPLLHz>:
{
1a001508:	b530      	push	{r4, r5, lr}
1a00150a:	b083      	sub	sp, #12
   uint32_t PLLReg = LPC_CGU->PLL1_CTRL;
1a00150c:	4d17      	ldr	r5, [pc, #92]	; (1a00156c <Chip_Clock_GetMainPLLHz+0x64>)
1a00150e:	6c6c      	ldr	r4, [r5, #68]	; 0x44
   uint32_t freq = Chip_Clock_GetClockInputHz((CHIP_CGU_CLKIN_T) ((PLLReg >> 24) & 0xF));
1a001510:	f3c4 6003 	ubfx	r0, r4, #24, #4
1a001514:	f7ff ff5c 	bl	1a0013d0 <Chip_Clock_GetClockInputHz>
   const uint8_t ptab[] = {1, 2, 4, 8};
1a001518:	4b15      	ldr	r3, [pc, #84]	; (1a001570 <Chip_Clock_GetMainPLLHz+0x68>)
1a00151a:	681b      	ldr	r3, [r3, #0]
1a00151c:	9301      	str	r3, [sp, #4]
   if (!(LPC_CGU->PLL1_STAT & 1)) {
1a00151e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
1a001520:	f013 0f01 	tst.w	r3, #1
1a001524:	d01f      	beq.n	1a001566 <Chip_Clock_GetMainPLLHz+0x5e>
   msel = (PLLReg >> 16) & 0xFF;
1a001526:	f3c4 4207 	ubfx	r2, r4, #16, #8
   nsel = (PLLReg >> 12) & 0x3;
1a00152a:	f3c4 3301 	ubfx	r3, r4, #12, #2
   psel = (PLLReg >> 8) & 0x3;
1a00152e:	f3c4 2101 	ubfx	r1, r4, #8, #2
   fbsel = (PLLReg >> 6) & 0x1;
1a001532:	f3c4 1580 	ubfx	r5, r4, #6, #1
   m = msel + 1;
1a001536:	3201      	adds	r2, #1
   n = nsel + 1;
1a001538:	3301      	adds	r3, #1
   p = ptab[psel];
1a00153a:	f10d 0e08 	add.w	lr, sp, #8
1a00153e:	4471      	add	r1, lr
1a001540:	f811 1c04 	ldrb.w	r1, [r1, #-4]
   if (direct || fbsel) {
1a001544:	f014 0f80 	tst.w	r4, #128	; 0x80
1a001548:	d108      	bne.n	1a00155c <Chip_Clock_GetMainPLLHz+0x54>
1a00154a:	b93d      	cbnz	r5, 1a00155c <Chip_Clock_GetMainPLLHz+0x54>
   return (m / (2 * p)) * (freq / n);
1a00154c:	0049      	lsls	r1, r1, #1
1a00154e:	fbb2 f2f1 	udiv	r2, r2, r1
1a001552:	fbb0 f0f3 	udiv	r0, r0, r3
1a001556:	fb00 f002 	mul.w	r0, r0, r2
1a00155a:	e005      	b.n	1a001568 <Chip_Clock_GetMainPLLHz+0x60>
       return m * (freq / n);
1a00155c:	fbb0 f0f3 	udiv	r0, r0, r3
1a001560:	fb00 f002 	mul.w	r0, r0, r2
1a001564:	e000      	b.n	1a001568 <Chip_Clock_GetMainPLLHz+0x60>
       return 0;
1a001566:	2000      	movs	r0, #0
}
1a001568:	b003      	add	sp, #12
1a00156a:	bd30      	pop	{r4, r5, pc}
1a00156c:	40050000 	.word	0x40050000
1a001570:	1a002804 	.word	0x1a002804

1a001574 <Chip_Clock_GetDivRate>:
{
1a001574:	b538      	push	{r3, r4, r5, lr}
1a001576:	460c      	mov	r4, r1
   input = Chip_Clock_GetDividerSource(divider);
1a001578:	4608      	mov	r0, r1
1a00157a:	f7ff ff0d 	bl	1a001398 <Chip_Clock_GetDividerSource>
1a00157e:	4605      	mov	r5, r0
   div = Chip_Clock_GetDividerDivisor(divider);
1a001580:	4620      	mov	r0, r4
1a001582:	f7ff ff17 	bl	1a0013b4 <Chip_Clock_GetDividerDivisor>
1a001586:	4604      	mov	r4, r0
   return Chip_Clock_GetClockInputHz(input) / (div + 1);
1a001588:	4628      	mov	r0, r5
1a00158a:	f7ff ff21 	bl	1a0013d0 <Chip_Clock_GetClockInputHz>
1a00158e:	3401      	adds	r4, #1
}
1a001590:	fbb0 f0f4 	udiv	r0, r0, r4
1a001594:	bd38      	pop	{r3, r4, r5, pc}
1a001596:	Address 0x1a001596 is out of bounds.


1a001598 <Chip_Clock_SetBaseClock>:
   return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
}

/* Sets a CGU Base Clock clock source */
void Chip_Clock_SetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T Input, bool autoblocken, bool powerdn)
{
1a001598:	b430      	push	{r4, r5}
   uint32_t reg = LPC_CGU->BASE_CLK[BaseClock];
1a00159a:	f100 0416 	add.w	r4, r0, #22
1a00159e:	00a4      	lsls	r4, r4, #2
1a0015a0:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
1a0015a4:	f504 24a0 	add.w	r4, r4, #327680	; 0x50000
1a0015a8:	6865      	ldr	r5, [r4, #4]

   if (BaseClock < CLK_BASE_NONE) {
1a0015aa:	281b      	cmp	r0, #27
1a0015ac:	d813      	bhi.n	1a0015d6 <Chip_Clock_SetBaseClock+0x3e>
       if (Input != CLKINPUT_PD) {
1a0015ae:	2911      	cmp	r1, #17
1a0015b0:	d01a      	beq.n	1a0015e8 <Chip_Clock_SetBaseClock+0x50>
           /* Mask off fields we plan to update */
           reg &= ~((0x1F << 24) | 1 | (1 << 11));
1a0015b2:	4c0e      	ldr	r4, [pc, #56]	; (1a0015ec <Chip_Clock_SetBaseClock+0x54>)
1a0015b4:	402c      	ands	r4, r5

           if (autoblocken) {
1a0015b6:	b10a      	cbz	r2, 1a0015bc <Chip_Clock_SetBaseClock+0x24>
               reg |= (1 << 11);
1a0015b8:	f444 6400 	orr.w	r4, r4, #2048	; 0x800
           }
           if (powerdn) {
1a0015bc:	b10b      	cbz	r3, 1a0015c2 <Chip_Clock_SetBaseClock+0x2a>
               reg |= (1 << 0);
1a0015be:	f044 0401 	orr.w	r4, r4, #1
           }

           /* Set clock source */
           reg |= (Input << 24);
1a0015c2:	ea44 6401 	orr.w	r4, r4, r1, lsl #24

           LPC_CGU->BASE_CLK[BaseClock] = reg;
1a0015c6:	3016      	adds	r0, #22
1a0015c8:	0080      	lsls	r0, r0, #2
1a0015ca:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a0015ce:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a0015d2:	6044      	str	r4, [r0, #4]
1a0015d4:	e008      	b.n	1a0015e8 <Chip_Clock_SetBaseClock+0x50>
       }
   }
   else {
       LPC_CGU->BASE_CLK[BaseClock] = reg | 1; /* Power down this base clock */
1a0015d6:	f045 0501 	orr.w	r5, r5, #1
1a0015da:	3016      	adds	r0, #22
1a0015dc:	0080      	lsls	r0, r0, #2
1a0015de:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a0015e2:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a0015e6:	6045      	str	r5, [r0, #4]
   }
}
1a0015e8:	bc30      	pop	{r4, r5}
1a0015ea:	4770      	bx	lr
1a0015ec:	e0fff7fe 	.word	0xe0fff7fe

1a0015f0 <Chip_Clock_GetBaseClock>:
/* Gets a CGU Base Clock clock source */
CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
{
   uint32_t reg;

   if (BaseClock >= CLK_BASE_NONE) {
1a0015f0:	281b      	cmp	r0, #27
1a0015f2:	d901      	bls.n	1a0015f8 <Chip_Clock_GetBaseClock+0x8>
       return CLKINPUT_PD;
1a0015f4:	2011      	movs	r0, #17
1a0015f6:	4770      	bx	lr
   }

   reg = LPC_CGU->BASE_CLK[BaseClock];
1a0015f8:	3016      	adds	r0, #22
1a0015fa:	0080      	lsls	r0, r0, #2
1a0015fc:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
1a001600:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
1a001604:	6840      	ldr	r0, [r0, #4]

   /* base clock is powered down? */
   if (reg & 1) {
1a001606:	f010 0f01 	tst.w	r0, #1
1a00160a:	d001      	beq.n	1a001610 <Chip_Clock_GetBaseClock+0x20>
       return CLKINPUT_PD;
1a00160c:	2011      	movs	r0, #17
   }

   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
}
1a00160e:	4770      	bx	lr
   return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
1a001610:	f3c0 6004 	ubfx	r0, r0, #24, #5
1a001614:	4770      	bx	lr

1a001616 <Chip_Clock_GetBaseClocktHz>:
{
1a001616:	b508      	push	{r3, lr}
   return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
1a001618:	f7ff ffea 	bl	1a0015f0 <Chip_Clock_GetBaseClock>
1a00161c:	f7ff fed8 	bl	1a0013d0 <Chip_Clock_GetClockInputHz>
}
1a001620:	bd08      	pop	{r3, pc}
1a001622:	Address 0x1a001622 is out of bounds.


1a001624 <Chip_Clock_EnableOpts>:
/* Enables a peripheral clock and sets clock states */
void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div)
{
   uint32_t reg = 1;

   if (autoen) {
1a001624:	b969      	cbnz	r1, 1a001642 <Chip_Clock_EnableOpts+0x1e>
   uint32_t reg = 1;
1a001626:	2101      	movs	r1, #1
       reg |= (1 << 1);
   }
   if (wakeupen) {
1a001628:	b10a      	cbz	r2, 1a00162e <Chip_Clock_EnableOpts+0xa>
       reg |= (1 << 2);
1a00162a:	f041 0104 	orr.w	r1, r1, #4
   }

   /* Not all clocks support a divider, but we won't check that here. Only
      dividers of 1 and 2 are allowed. Assume 1 if not 2 */
   if (div == 2) {
1a00162e:	2b02      	cmp	r3, #2
1a001630:	d009      	beq.n	1a001646 <Chip_Clock_EnableOpts+0x22>
       reg |= (1 << 5);
   }

   /* Setup peripheral clock and start running */
   if (clk >= CLK_CCU2_START) {
1a001632:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a001636:	d209      	bcs.n	1a00164c <Chip_Clock_EnableOpts+0x28>
       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
   }
   else {
       LPC_CCU1->CLKCCU[clk].CFG = reg;
1a001638:	3020      	adds	r0, #32
1a00163a:	4b07      	ldr	r3, [pc, #28]	; (1a001658 <Chip_Clock_EnableOpts+0x34>)
1a00163c:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
1a001640:	4770      	bx	lr
       reg |= (1 << 1);
1a001642:	2103      	movs	r1, #3
1a001644:	e7f0      	b.n	1a001628 <Chip_Clock_EnableOpts+0x4>
       reg |= (1 << 5);
1a001646:	f041 0120 	orr.w	r1, r1, #32
1a00164a:	e7f2      	b.n	1a001632 <Chip_Clock_EnableOpts+0xe>
       LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
1a00164c:	f5a0 7091 	sub.w	r0, r0, #290	; 0x122
1a001650:	4b02      	ldr	r3, [pc, #8]	; (1a00165c <Chip_Clock_EnableOpts+0x38>)
1a001652:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
1a001656:	4770      	bx	lr
1a001658:	40051000 	.word	0x40051000
1a00165c:	40052000 	.word	0x40052000

1a001660 <Chip_Clock_GetRate>:
   LPC_CCU2->PM = 0;
}

/* Returns a peripheral clock rate */
uint32_t Chip_Clock_GetRate(CHIP_CCU_CLK_T clk)
{
1a001660:	b510      	push	{r4, lr}
   CHIP_CGU_BASE_CLK_T baseclk;
   uint32_t reg, div, rate;

   /* Get CCU config register for clock */
   if (clk >= CLK_CCU2_START) {
1a001662:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a001666:	d309      	bcc.n	1a00167c <Chip_Clock_GetRate+0x1c>
       reg = LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG;
1a001668:	f5a0 7391 	sub.w	r3, r0, #290	; 0x122
1a00166c:	4a0d      	ldr	r2, [pc, #52]	; (1a0016a4 <Chip_Clock_GetRate+0x44>)
1a00166e:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
   else {
       reg = LPC_CCU1->CLKCCU[clk].CFG;
   }

   /* Is the clock enabled? */
   if (reg & 1) {
1a001672:	f014 0f01 	tst.w	r4, #1
1a001676:	d107      	bne.n	1a001688 <Chip_Clock_GetRate+0x28>

       }
       rate = rate / div;
   }
   else {
       rate = 0;
1a001678:	2000      	movs	r0, #0
   }

   return rate;
}
1a00167a:	bd10      	pop	{r4, pc}
       reg = LPC_CCU1->CLKCCU[clk].CFG;
1a00167c:	f100 0320 	add.w	r3, r0, #32
1a001680:	4a09      	ldr	r2, [pc, #36]	; (1a0016a8 <Chip_Clock_GetRate+0x48>)
1a001682:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
1a001686:	e7f4      	b.n	1a001672 <Chip_Clock_GetRate+0x12>
       baseclk = Chip_Clock_FindBaseClock(clk);
1a001688:	f7ff fe3a 	bl	1a001300 <Chip_Clock_FindBaseClock>
       rate = Chip_Clock_GetBaseClocktHz(baseclk);
1a00168c:	f7ff ffc3 	bl	1a001616 <Chip_Clock_GetBaseClocktHz>
       if (((reg >> 5) & 0x7) == 0) {
1a001690:	f014 0fe0 	tst.w	r4, #224	; 0xe0
1a001694:	d103      	bne.n	1a00169e <Chip_Clock_GetRate+0x3e>
           div = 1;
1a001696:	2301      	movs	r3, #1
       rate = rate / div;
1a001698:	fbb0 f0f3 	udiv	r0, r0, r3
1a00169c:	bd10      	pop	{r4, pc}
           div = 2;/* No other dividers supported */
1a00169e:	2302      	movs	r3, #2
1a0016a0:	e7fa      	b.n	1a001698 <Chip_Clock_GetRate+0x38>
1a0016a2:	bf00      	nop
1a0016a4:	40052000 	.word	0x40052000
1a0016a8:	40051000 	.word	0x40051000

1a0016ac <fpuInit>:
 * Public functions
 ****************************************************************************/

/* Early initialization of the FPU */
void fpuInit(void)
{
1a0016ac:	b084      	sub	sp, #16
   volatile uint32_t Cpacr;
   volatile uint32_t Mvfr0;
   volatile uint32_t Mvfr1;
   char vfpPresent = 0;

   Mvfr0 = *regMvfr0;
1a0016ae:	4b0f      	ldr	r3, [pc, #60]	; (1a0016ec <fpuInit+0x40>)
1a0016b0:	681b      	ldr	r3, [r3, #0]
1a0016b2:	9302      	str	r3, [sp, #8]
   Mvfr1 = *regMvfr1;
1a0016b4:	4b0e      	ldr	r3, [pc, #56]	; (1a0016f0 <fpuInit+0x44>)
1a0016b6:	681b      	ldr	r3, [r3, #0]
1a0016b8:	9301      	str	r3, [sp, #4]

   vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
1a0016ba:	9a02      	ldr	r2, [sp, #8]
1a0016bc:	4b0d      	ldr	r3, [pc, #52]	; (1a0016f4 <fpuInit+0x48>)
1a0016be:	429a      	cmp	r2, r3
1a0016c0:	d00c      	beq.n	1a0016dc <fpuInit+0x30>
1a0016c2:	2300      	movs	r3, #0

   if (vfpPresent) {
1a0016c4:	b143      	cbz	r3, 1a0016d8 <fpuInit+0x2c>
       Cpacr = *regCpacr;
1a0016c6:	4a0c      	ldr	r2, [pc, #48]	; (1a0016f8 <fpuInit+0x4c>)
1a0016c8:	6813      	ldr	r3, [r2, #0]
1a0016ca:	9303      	str	r3, [sp, #12]
       Cpacr |= (0xF << 20);
1a0016cc:	9b03      	ldr	r3, [sp, #12]
1a0016ce:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
1a0016d2:	9303      	str	r3, [sp, #12]
       *regCpacr = Cpacr;  // enable CP10 and CP11 for full access
1a0016d4:	9b03      	ldr	r3, [sp, #12]
1a0016d6:	6013      	str	r3, [r2, #0]
   }
#endif /* __FPU_PRESENT != 0 */
}
1a0016d8:	b004      	add	sp, #16
1a0016da:	4770      	bx	lr
   vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
1a0016dc:	9a01      	ldr	r2, [sp, #4]
1a0016de:	4b07      	ldr	r3, [pc, #28]	; (1a0016fc <fpuInit+0x50>)
1a0016e0:	429a      	cmp	r2, r3
1a0016e2:	d001      	beq.n	1a0016e8 <fpuInit+0x3c>
1a0016e4:	2300      	movs	r3, #0
1a0016e6:	e7ed      	b.n	1a0016c4 <fpuInit+0x18>
1a0016e8:	2301      	movs	r3, #1
1a0016ea:	e7eb      	b.n	1a0016c4 <fpuInit+0x18>
1a0016ec:	e000ef40 	.word	0xe000ef40
1a0016f0:	e000ef44 	.word	0xe000ef44
1a0016f4:	10110021 	.word	0x10110021
1a0016f8:	e000ed88 	.word	0xe000ed88
1a0016fc:	11000011 	.word	0x11000011

1a001700 <Chip_GPIO_Init>:
 * Public functions
 ****************************************************************************/

/* Initialize GPIO block */
void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
{
1a001700:	4770      	bx	lr

1a001702 <Chip_GPIO_SetDir>:
}

/* Set Direction for a GPIO port */
void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
{
   if (out) {
1a001702:	b943      	cbnz	r3, 1a001716 <Chip_GPIO_SetDir+0x14>
       pGPIO->DIR[portNum] |= bitValue;
   }
   else {
       pGPIO->DIR[portNum] &= ~bitValue;
1a001704:	f501 6100 	add.w	r1, r1, #2048	; 0x800
1a001708:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
1a00170c:	ea23 0202 	bic.w	r2, r3, r2
1a001710:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
1a001714:	4770      	bx	lr
       pGPIO->DIR[portNum] |= bitValue;
1a001716:	f501 6100 	add.w	r1, r1, #2048	; 0x800
1a00171a:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
1a00171e:	431a      	orrs	r2, r3
1a001720:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
1a001724:	4770      	bx	lr
1a001726:	Address 0x1a001726 is out of bounds.


1a001728 <Chip_SetupCoreClock>:
/*****************************************************************************
 * Public functions
 ****************************************************************************/
/* Setup Chip Core clock */
void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase)
{
1a001728:	b570      	push	{r4, r5, r6, lr}
1a00172a:	b092      	sub	sp, #72	; 0x48
1a00172c:	4605      	mov	r5, r0
1a00172e:	460e      	mov	r6, r1
1a001730:	4614      	mov	r4, r2
   int i;
   volatile uint32_t delay = 5500;
1a001732:	f241 537c 	movw	r3, #5500	; 0x157c
1a001736:	9311      	str	r3, [sp, #68]	; 0x44
   uint32_t direct = 0;
   PLL_PARAM_T ppll;

   if (clkin == CLKIN_CRYSTAL) {
1a001738:	2806      	cmp	r0, #6
1a00173a:	d044      	beq.n	1a0017c6 <Chip_SetupCoreClock+0x9e>
       /* Switch main system clocking to crystal */
       Chip_Clock_EnableCrystal();
   }
   Chip_Clock_SetBaseClock(CLK_BASE_MX, clkin, true, false);
1a00173c:	2300      	movs	r3, #0
1a00173e:	2201      	movs	r2, #1
1a001740:	4629      	mov	r1, r5
1a001742:	2004      	movs	r0, #4
1a001744:	f7ff ff28 	bl	1a001598 <Chip_Clock_SetBaseClock>
 * Saves power if the main PLL is not needed.
 */
__STATIC_INLINE void Chip_Clock_DisableMainPLL(void)
{
   /* power down main PLL */
   LPC_CGU->PLL1_CTRL |= 1;
1a001748:	4a4a      	ldr	r2, [pc, #296]	; (1a001874 <Chip_SetupCoreClock+0x14c>)
1a00174a:	6c53      	ldr	r3, [r2, #68]	; 0x44
1a00174c:	f043 0301 	orr.w	r3, r3, #1
1a001750:	6453      	str	r3, [r2, #68]	; 0x44
   Chip_Clock_DisableMainPLL(); /* Disable PLL */

   /* Calculate the PLL Parameters */
   ppll.srcin = clkin;
1a001752:	f88d 5028 	strb.w	r5, [sp, #40]	; 0x28
   Chip_Clock_CalcMainPLLValue(core_freq, &ppll);
1a001756:	a909      	add	r1, sp, #36	; 0x24
1a001758:	4630      	mov	r0, r6
1a00175a:	f7ff fe95 	bl	1a001488 <Chip_Clock_CalcMainPLLValue>

   if (core_freq > 110000000UL) {
1a00175e:	4b46      	ldr	r3, [pc, #280]	; (1a001878 <Chip_SetupCoreClock+0x150>)
1a001760:	429e      	cmp	r6, r3
1a001762:	d938      	bls.n	1a0017d6 <Chip_SetupCoreClock+0xae>
       if (!(ppll.ctrl & (1 << 7)) || ppll.psel) {
1a001764:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a001766:	f013 0f80 	tst.w	r3, #128	; 0x80
1a00176a:	d001      	beq.n	1a001770 <Chip_SetupCoreClock+0x48>
1a00176c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a00176e:	b36a      	cbz	r2, 1a0017cc <Chip_SetupCoreClock+0xa4>
           PLL_PARAM_T lpll;
           /* Calculate the PLL Parameters */
           lpll.srcin = clkin;
1a001770:	f88d 5008 	strb.w	r5, [sp, #8]
           Chip_Clock_CalcMainPLLValue(110000000UL, &lpll);
1a001774:	a901      	add	r1, sp, #4
1a001776:	4840      	ldr	r0, [pc, #256]	; (1a001878 <Chip_SetupCoreClock+0x150>)
1a001778:	f7ff fe86 	bl	1a001488 <Chip_Clock_CalcMainPLLValue>
 * Make sure the main PLL is enabled.
 */
__STATIC_INLINE void Chip_Clock_SetupMainPLL(const PLL_PARAM_T *ppll)
{
   /* power up main PLL */
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a00177c:	f89d 2008 	ldrb.w	r2, [sp, #8]
1a001780:	9b01      	ldr	r3, [sp, #4]
1a001782:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a001786:	9a05      	ldr	r2, [sp, #20]
1a001788:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a00178c:	9a03      	ldr	r2, [sp, #12]
1a00178e:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a001792:	9a04      	ldr	r2, [sp, #16]
1a001794:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a001798:	4a36      	ldr	r2, [pc, #216]	; (1a001874 <Chip_SetupCoreClock+0x14c>)
1a00179a:	6453      	str	r3, [r2, #68]	; 0x44
 * @note   The main PLL should be locked prior to using it as a clock input for a base clock.
 */
__STATIC_INLINE int Chip_Clock_MainPLLLocked(void)
{
   /* Return true if locked */
   return (LPC_CGU->PLL1_STAT & 1) != 0;
1a00179c:	4b35      	ldr	r3, [pc, #212]	; (1a001874 <Chip_SetupCoreClock+0x14c>)
1a00179e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
           Chip_Clock_SetupMainPLL(&lpll);
           /* Wait for the PLL to lock */
           while(!Chip_Clock_MainPLLLocked()) {}
1a0017a0:	f013 0f01 	tst.w	r3, #1
1a0017a4:	d0fa      	beq.n	1a00179c <Chip_SetupCoreClock+0x74>
           Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
1a0017a6:	2300      	movs	r3, #0
1a0017a8:	2201      	movs	r2, #1
1a0017aa:	2109      	movs	r1, #9
1a0017ac:	2004      	movs	r0, #4
1a0017ae:	f7ff fef3 	bl	1a001598 <Chip_Clock_SetBaseClock>
           while(delay --){}
1a0017b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a0017b4:	1e5a      	subs	r2, r3, #1
1a0017b6:	9211      	str	r2, [sp, #68]	; 0x44
1a0017b8:	2b00      	cmp	r3, #0
1a0017ba:	d1fa      	bne.n	1a0017b2 <Chip_SetupCoreClock+0x8a>
           delay = 5500;
1a0017bc:	f241 537c 	movw	r3, #5500	; 0x157c
1a0017c0:	9311      	str	r3, [sp, #68]	; 0x44
   uint32_t direct = 0;
1a0017c2:	2500      	movs	r5, #0
       if (!(ppll.ctrl & (1 << 7)) || ppll.psel) {
1a0017c4:	e008      	b.n	1a0017d8 <Chip_SetupCoreClock+0xb0>
       Chip_Clock_EnableCrystal();
1a0017c6:	f7ff fdc1 	bl	1a00134c <Chip_Clock_EnableCrystal>
1a0017ca:	e7b7      	b.n	1a00173c <Chip_SetupCoreClock+0x14>
       } else {
           direct = 1;
           ppll.ctrl &= ~(1 << 7);
1a0017cc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1a0017d0:	9309      	str	r3, [sp, #36]	; 0x24
           direct = 1;
1a0017d2:	2501      	movs	r5, #1
1a0017d4:	e000      	b.n	1a0017d8 <Chip_SetupCoreClock+0xb0>
   uint32_t direct = 0;
1a0017d6:	2500      	movs	r5, #0
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a0017d8:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
1a0017dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a0017de:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a0017e2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
1a0017e4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a0017e8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
1a0017ea:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a0017ee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a0017f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a0017f4:	4a1f      	ldr	r2, [pc, #124]	; (1a001874 <Chip_SetupCoreClock+0x14c>)
1a0017f6:	6453      	str	r3, [r2, #68]	; 0x44
   return (LPC_CGU->PLL1_STAT & 1) != 0;
1a0017f8:	4b1e      	ldr	r3, [pc, #120]	; (1a001874 <Chip_SetupCoreClock+0x14c>)
1a0017fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40

   /* Setup and start the PLL */
   Chip_Clock_SetupMainPLL(&ppll);

   /* Wait for the PLL to lock */
   while(!Chip_Clock_MainPLLLocked()) {}
1a0017fc:	f013 0f01 	tst.w	r3, #1
1a001800:	d0fa      	beq.n	1a0017f8 <Chip_SetupCoreClock+0xd0>

   /* Set core clock base as PLL1 */
   Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
1a001802:	2300      	movs	r3, #0
1a001804:	2201      	movs	r2, #1
1a001806:	2109      	movs	r1, #9
1a001808:	2004      	movs	r0, #4
1a00180a:	f7ff fec5 	bl	1a001598 <Chip_Clock_SetBaseClock>

   while(delay --){} /* Wait for approx 50 uSec */
1a00180e:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a001810:	1e5a      	subs	r2, r3, #1
1a001812:	9211      	str	r2, [sp, #68]	; 0x44
1a001814:	2b00      	cmp	r3, #0
1a001816:	d1fa      	bne.n	1a00180e <Chip_SetupCoreClock+0xe6>
   if (direct) {
1a001818:	b1d5      	cbz	r5, 1a001850 <Chip_SetupCoreClock+0x128>
       delay = 5500;
1a00181a:	f241 537c 	movw	r3, #5500	; 0x157c
1a00181e:	9311      	str	r3, [sp, #68]	; 0x44
       ppll.ctrl |= 1 << 7;
1a001820:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a001822:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1a001826:	9309      	str	r3, [sp, #36]	; 0x24
   LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8);
1a001828:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
1a00182c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a001830:	9a0d      	ldr	r2, [sp, #52]	; 0x34
1a001832:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a001836:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
1a001838:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a00183c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1a00183e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a001842:	4a0c      	ldr	r2, [pc, #48]	; (1a001874 <Chip_SetupCoreClock+0x14c>)
1a001844:	6453      	str	r3, [r2, #68]	; 0x44
       Chip_Clock_SetupMainPLL(&ppll); /* Set DIRECT to operate at full frequency */
       while(delay --){} /* Wait for approx 50 uSec */
1a001846:	9b11      	ldr	r3, [sp, #68]	; 0x44
1a001848:	1e5a      	subs	r2, r3, #1
1a00184a:	9211      	str	r2, [sp, #68]	; 0x44
1a00184c:	2b00      	cmp	r3, #0
1a00184e:	d1fa      	bne.n	1a001846 <Chip_SetupCoreClock+0x11e>
   }

   if (setbase) {
1a001850:	b174      	cbz	r4, 1a001870 <Chip_SetupCoreClock+0x148>
1a001852:	2400      	movs	r4, #0
1a001854:	e00a      	b.n	1a00186c <Chip_SetupCoreClock+0x144>
       /* Setup system base clocks and initial states. This won't enable and
          disable individual clocks, but sets up the base clock sources for
          each individual peripheral clock. */
       for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
           Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
1a001856:	4809      	ldr	r0, [pc, #36]	; (1a00187c <Chip_SetupCoreClock+0x154>)
1a001858:	eb00 0184 	add.w	r1, r0, r4, lsl #2
1a00185c:	78cb      	ldrb	r3, [r1, #3]
1a00185e:	788a      	ldrb	r2, [r1, #2]
1a001860:	7849      	ldrb	r1, [r1, #1]
1a001862:	f810 0024 	ldrb.w	r0, [r0, r4, lsl #2]
1a001866:	f7ff fe97 	bl	1a001598 <Chip_Clock_SetBaseClock>
       for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a00186a:	3401      	adds	r4, #1
1a00186c:	2c11      	cmp	r4, #17
1a00186e:	d9f2      	bls.n	1a001856 <Chip_SetupCoreClock+0x12e>
                                   InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
       }
   }
}
1a001870:	b012      	add	sp, #72	; 0x48
1a001872:	bd70      	pop	{r4, r5, r6, pc}
1a001874:	40050000 	.word	0x40050000
1a001878:	068e7780 	.word	0x068e7780
1a00187c:	1a00287c 	.word	0x1a00287c

1a001880 <Chip_UART_GetIndex>:

/* Returns clock index for the peripheral block */
static int Chip_UART_GetIndex(LPC_USART_T *pUART)
{
   uint32_t base = (uint32_t) pUART;
   switch(base) {
1a001880:	4b09      	ldr	r3, [pc, #36]	; (1a0018a8 <Chip_UART_GetIndex+0x28>)
1a001882:	4298      	cmp	r0, r3
1a001884:	d009      	beq.n	1a00189a <Chip_UART_GetIndex+0x1a>
1a001886:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
1a00188a:	4298      	cmp	r0, r3
1a00188c:	d007      	beq.n	1a00189e <Chip_UART_GetIndex+0x1e>
1a00188e:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
1a001892:	4298      	cmp	r0, r3
1a001894:	d005      	beq.n	1a0018a2 <Chip_UART_GetIndex+0x22>
       case LPC_USART0_BASE:
           return 0;
1a001896:	2000      	movs	r0, #0
1a001898:	4770      	bx	lr
       case LPC_UART1_BASE:
           return 1;
       case LPC_USART2_BASE:
           return 2;
1a00189a:	2002      	movs	r0, #2
1a00189c:	4770      	bx	lr
       case LPC_USART3_BASE:
           return 3;
1a00189e:	2003      	movs	r0, #3
1a0018a0:	4770      	bx	lr
           return 1;
1a0018a2:	2001      	movs	r0, #1
       default:
           return 0; /* Should never come here */
   }
}
1a0018a4:	4770      	bx	lr
1a0018a6:	bf00      	nop
1a0018a8:	400c1000 	.word	0x400c1000

1a0018ac <Chip_UART_Init>:
 * Public functions
 ****************************************************************************/

/* Initializes the pUART peripheral */
void Chip_UART_Init(LPC_USART_T *pUART)
{
1a0018ac:	b530      	push	{r4, r5, lr}
1a0018ae:	b083      	sub	sp, #12
1a0018b0:	4604      	mov	r4, r0
    volatile uint32_t tmp;

   /* Enable UART clocking. UART base clock(s) must already be enabled */
   Chip_Clock_EnableOpts(UART_PClock[Chip_UART_GetIndex(pUART)], true, true, 1);
1a0018b2:	f7ff ffe5 	bl	1a001880 <Chip_UART_GetIndex>
1a0018b6:	2301      	movs	r3, #1
1a0018b8:	461a      	mov	r2, r3
1a0018ba:	4619      	mov	r1, r3
1a0018bc:	4d0e      	ldr	r5, [pc, #56]	; (1a0018f8 <Chip_UART_Init+0x4c>)
1a0018be:	f835 0010 	ldrh.w	r0, [r5, r0, lsl #1]
1a0018c2:	f7ff feaf 	bl	1a001624 <Chip_Clock_EnableOpts>
 *         with a RX trip level of 8 characters, use something like
 *         (UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2)
 */
STATIC INLINE void Chip_UART_SetupFIFOS(LPC_USART_T *pUART, uint32_t fcr)
{
   pUART->FCR = fcr;
1a0018c6:	2307      	movs	r3, #7
1a0018c8:	60a3      	str	r3, [r4, #8]
    pUART->TER2 = 0;
1a0018ca:	2300      	movs	r3, #0
1a0018cc:	65e3      	str	r3, [r4, #92]	; 0x5c

    /* Disable Tx */
    Chip_UART_TXDisable(pUART);

    /* Disable interrupts */
   pUART->IER = 0;
1a0018ce:	6063      	str	r3, [r4, #4]
   /* Set LCR to default state */
   pUART->LCR = 0;
1a0018d0:	60e3      	str	r3, [r4, #12]
   /* Set ACR to default state */
   pUART->ACR = 0;
1a0018d2:	6223      	str	r3, [r4, #32]
    /* Set RS485 control to default state */
   pUART->RS485CTRL = 0;
1a0018d4:	64e3      	str	r3, [r4, #76]	; 0x4c
   /* Set RS485 delay timer to default state */
   pUART->RS485DLY = 0;
1a0018d6:	6563      	str	r3, [r4, #84]	; 0x54
   /* Set RS485 addr match to default state */
   pUART->RS485ADRMATCH = 0;
1a0018d8:	6523      	str	r3, [r4, #80]	; 0x50

    /* Clear MCR */
    if (pUART == LPC_UART1) {
1a0018da:	4b08      	ldr	r3, [pc, #32]	; (1a0018fc <Chip_UART_Init+0x50>)
1a0018dc:	429c      	cmp	r4, r3
1a0018de:	d005      	beq.n	1a0018ec <Chip_UART_Init+0x40>
 *         stop bit, and even (enabled) parity would be
 *         (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
   pUART->LCR = config;
1a0018e0:	2303      	movs	r3, #3
1a0018e2:	60e3      	str	r3, [r4, #12]

   /* Default 8N1, with DLAB disabled */
   Chip_UART_ConfigData(pUART, (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS));

   /* Disable fractional divider */
   pUART->FDR = 0x10;
1a0018e4:	2310      	movs	r3, #16
1a0018e6:	62a3      	str	r3, [r4, #40]	; 0x28
}
1a0018e8:	b003      	add	sp, #12
1a0018ea:	bd30      	pop	{r4, r5, pc}
       pUART->MCR = 0;
1a0018ec:	2300      	movs	r3, #0
1a0018ee:	6123      	str	r3, [r4, #16]
       tmp = pUART->MSR;
1a0018f0:	69a3      	ldr	r3, [r4, #24]
1a0018f2:	9301      	str	r3, [sp, #4]
1a0018f4:	e7f4      	b.n	1a0018e0 <Chip_UART_Init+0x34>
1a0018f6:	bf00      	nop
1a0018f8:	1a0028cc 	.word	0x1a0028cc
1a0018fc:	40082000 	.word	0x40082000

1a001900 <Chip_UART_SetBaud>:
   return readBytes;
}

/* Determines and sets best dividers to get a target bit rate */
uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
{
1a001900:	b538      	push	{r3, r4, r5, lr}
1a001902:	4605      	mov	r5, r0
1a001904:	460c      	mov	r4, r1
   uint32_t div, divh, divl, clkin;

   /* Determine UART clock in rate without FDR */
   clkin = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
1a001906:	f7ff ffbb 	bl	1a001880 <Chip_UART_GetIndex>
1a00190a:	4b0c      	ldr	r3, [pc, #48]	; (1a00193c <Chip_UART_SetBaud+0x3c>)
1a00190c:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1a001910:	f7ff fea6 	bl	1a001660 <Chip_Clock_GetRate>
   div = clkin / (baudrate * 16);
1a001914:	0123      	lsls	r3, r4, #4
1a001916:	fbb0 f3f3 	udiv	r3, r0, r3
1a00191a:	b2d9      	uxtb	r1, r3
 * @param  pUART   : Pointer to selected UART peripheral
 * @return Nothing
 */
STATIC INLINE void Chip_UART_EnableDivisorAccess(LPC_USART_T *pUART)
{
   pUART->LCR |= UART_LCR_DLAB_EN;
1a00191c:	68ea      	ldr	r2, [r5, #12]
1a00191e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
1a001922:	60ea      	str	r2, [r5, #12]
 *         order to access the USART Divisor Latches. This function
 *         doesn't alter the DLAB state.
 */
STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
{
   pUART->DLL = (uint32_t) dll;
1a001924:	6029      	str	r1, [r5, #0]
1a001926:	f3c3 2207 	ubfx	r2, r3, #8, #8
   pUART->DLM = (uint32_t) dlm;
1a00192a:	606a      	str	r2, [r5, #4]
   pUART->LCR &= ~UART_LCR_DLAB_EN;
1a00192c:	68ea      	ldr	r2, [r5, #12]
1a00192e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
1a001932:	60ea      	str	r2, [r5, #12]
   Chip_UART_DisableDivisorAccess(pUART);

   /* Fractional FDR alreadt setup for 1 in UART init */

   return clkin / div;
}
1a001934:	fbb0 f0f3 	udiv	r0, r0, r3
1a001938:	bd38      	pop	{r3, r4, r5, pc}
1a00193a:	bf00      	nop
1a00193c:	1a0028c4 	.word	0x1a0028c4

1a001940 <Chip_UART_SetBaudFDR>:
    Chip_UART_ABIntHandler(pUART);
}

/* Determines and sets best dividers to get a target baud rate */
uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud)
{
1a001940:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1a001944:	b083      	sub	sp, #12
1a001946:	4683      	mov	fp, r0
1a001948:	4688      	mov	r8, r1
   uint32_t sdiv = 0, sm = 1, sd = 0;
   uint32_t pclk, m, d;
   uint32_t odiff = -1UL; /* old best diff */

   /* Get base clock for the corresponding UART */
   pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
1a00194a:	f7ff ff99 	bl	1a001880 <Chip_UART_GetIndex>
1a00194e:	4b35      	ldr	r3, [pc, #212]	; (1a001a24 <Chip_UART_SetBaudFDR+0xe4>)
1a001950:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1a001954:	f7ff fe84 	bl	1a001660 <Chip_Clock_GetRate>
1a001958:	4606      	mov	r6, r0
   uint32_t odiff = -1UL; /* old best diff */
1a00195a:	f04f 37ff 	mov.w	r7, #4294967295

   /* Loop through all possible fractional divider values */
   for (m = 1; odiff && m < 16; m++) {
1a00195e:	2401      	movs	r4, #1
   uint32_t sdiv = 0, sm = 1, sd = 0;
1a001960:	2300      	movs	r3, #0
1a001962:	9301      	str	r3, [sp, #4]
1a001964:	46a2      	mov	sl, r4
1a001966:	4699      	mov	r9, r3
   for (m = 1; odiff && m < 16; m++) {
1a001968:	e02a      	b.n	1a0019c0 <Chip_UART_SetBaudFDR+0x80>
           /* Upper 32-bit of dval has div */
           div = (uint32_t) (dval >> 32);

           /* Closer to next div */
           if ((int)diff < 0) {
               diff = -diff;
1a00196a:	4243      	negs	r3, r0
               div ++;
1a00196c:	1c4a      	adds	r2, r1, #1
1a00196e:	e017      	b.n	1a0019a0 <Chip_UART_SetBaudFDR+0x60>
           sd = d;
           sm = m;
           odiff = diff;

           /* On perfect match, break loop */
           if(!diff) {
1a001970:	b30b      	cbz	r3, 1a0019b6 <Chip_UART_SetBaudFDR+0x76>
           odiff = diff;
1a001972:	461f      	mov	r7, r3
           sd = d;
1a001974:	9501      	str	r5, [sp, #4]
           sm = m;
1a001976:	46a2      	mov	sl, r4
           sdiv = div;
1a001978:	4691      	mov	r9, r2
       for (d = 0; d < m; d++) {
1a00197a:	3501      	adds	r5, #1
1a00197c:	42ac      	cmp	r4, r5
1a00197e:	d91e      	bls.n	1a0019be <Chip_UART_SetBaudFDR+0x7e>
           uint64_t dval = (((uint64_t) pclk << 28) * m) / (baud * (m + d));
1a001980:	0933      	lsrs	r3, r6, #4
1a001982:	0730      	lsls	r0, r6, #28
1a001984:	fba4 0100 	umull	r0, r1, r4, r0
1a001988:	fb04 1103 	mla	r1, r4, r3, r1
1a00198c:	1962      	adds	r2, r4, r5
1a00198e:	fb08 f202 	mul.w	r2, r8, r2
1a001992:	2300      	movs	r3, #0
1a001994:	f000 fc48 	bl	1a002228 <__aeabi_uldivmod>
           diff = (uint32_t) dval;
1a001998:	4603      	mov	r3, r0
           div = (uint32_t) (dval >> 32);
1a00199a:	460a      	mov	r2, r1
           if ((int)diff < 0) {
1a00199c:	2800      	cmp	r0, #0
1a00199e:	dbe4      	blt.n	1a00196a <Chip_UART_SetBaudFDR+0x2a>
           if (odiff < diff || !div || (div >> 16) || (div < 3 && d)) {
1a0019a0:	429f      	cmp	r7, r3
1a0019a2:	d3ea      	bcc.n	1a00197a <Chip_UART_SetBaudFDR+0x3a>
1a0019a4:	2a00      	cmp	r2, #0
1a0019a6:	d0e8      	beq.n	1a00197a <Chip_UART_SetBaudFDR+0x3a>
1a0019a8:	0c11      	lsrs	r1, r2, #16
1a0019aa:	d1e6      	bne.n	1a00197a <Chip_UART_SetBaudFDR+0x3a>
1a0019ac:	2a02      	cmp	r2, #2
1a0019ae:	d8df      	bhi.n	1a001970 <Chip_UART_SetBaudFDR+0x30>
1a0019b0:	2d00      	cmp	r5, #0
1a0019b2:	d1e2      	bne.n	1a00197a <Chip_UART_SetBaudFDR+0x3a>
1a0019b4:	e7dc      	b.n	1a001970 <Chip_UART_SetBaudFDR+0x30>
           odiff = diff;
1a0019b6:	461f      	mov	r7, r3
           sd = d;
1a0019b8:	9501      	str	r5, [sp, #4]
           sm = m;
1a0019ba:	46a2      	mov	sl, r4
           sdiv = div;
1a0019bc:	4691      	mov	r9, r2
   for (m = 1; odiff && m < 16; m++) {
1a0019be:	3401      	adds	r4, #1
1a0019c0:	b11f      	cbz	r7, 1a0019ca <Chip_UART_SetBaudFDR+0x8a>
1a0019c2:	2c0f      	cmp	r4, #15
1a0019c4:	d801      	bhi.n	1a0019ca <Chip_UART_SetBaudFDR+0x8a>
1a0019c6:	2500      	movs	r5, #0
1a0019c8:	e7d8      	b.n	1a00197c <Chip_UART_SetBaudFDR+0x3c>
           }
       }
   }

   /* Return 0 if a vaild divisor is not possible */
   if (!sdiv) {
1a0019ca:	f1b9 0f00 	cmp.w	r9, #0
1a0019ce:	d024      	beq.n	1a001a1a <Chip_UART_SetBaudFDR+0xda>
   pUART->LCR |= UART_LCR_DLAB_EN;
1a0019d0:	f8db 300c 	ldr.w	r3, [fp, #12]
1a0019d4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1a0019d8:	f8cb 300c 	str.w	r3, [fp, #12]
1a0019dc:	fa5f f389 	uxtb.w	r3, r9
   pUART->DLL = (uint32_t) dll;
1a0019e0:	f8cb 3000 	str.w	r3, [fp]
1a0019e4:	f3c9 2307 	ubfx	r3, r9, #8, #8
   pUART->DLM = (uint32_t) dlm;
1a0019e8:	f8cb 3004 	str.w	r3, [fp, #4]
   pUART->LCR &= ~UART_LCR_DLAB_EN;
1a0019ec:	f8db 300c 	ldr.w	r3, [fp, #12]
1a0019f0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1a0019f4:	f8cb 300c 	str.w	r3, [fp, #12]
   Chip_UART_EnableDivisorAccess(pUART);
   Chip_UART_SetDivisorLatches(pUART, UART_LOAD_DLL(sdiv), UART_LOAD_DLM(sdiv));
   Chip_UART_DisableDivisorAccess(pUART);

   /* Set best fractional divider */
   pUART->FDR = (UART_FDR_MULVAL(sm) | UART_FDR_DIVADDVAL(sd));
1a0019f8:	ea4f 130a 	mov.w	r3, sl, lsl #4
1a0019fc:	b2db      	uxtb	r3, r3
1a0019fe:	9901      	ldr	r1, [sp, #4]
1a001a00:	f001 020f 	and.w	r2, r1, #15
1a001a04:	4313      	orrs	r3, r2
1a001a06:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28

   /* Return actual baud rate */
   return (pclk >> 4) * sm / (sdiv * (sm + sd));
1a001a0a:	0933      	lsrs	r3, r6, #4
1a001a0c:	fb03 f30a 	mul.w	r3, r3, sl
1a001a10:	448a      	add	sl, r1
1a001a12:	fb0a f909 	mul.w	r9, sl, r9
1a001a16:	fbb3 f9f9 	udiv	r9, r3, r9
}
1a001a1a:	4648      	mov	r0, r9
1a001a1c:	b003      	add	sp, #12
1a001a1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1a001a22:	bf00      	nop
1a001a24:	1a0028c4 	.word	0x1a0028c4

1a001a28 <Board_LED_Init>:

static void Board_LED_Init()
{
   uint32_t idx;

   for (idx = 0; idx < (sizeof(gpioLEDBits) / sizeof(io_port_t)); ++idx) {
1a001a28:	2200      	movs	r2, #0
1a001a2a:	2a05      	cmp	r2, #5
1a001a2c:	d819      	bhi.n	1a001a62 <Board_LED_Init+0x3a>
{
1a001a2e:	b470      	push	{r4, r5, r6}
       /* Set pin direction and init to off */
       Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, gpioLEDBits[idx].port, gpioLEDBits[idx].pin);
1a001a30:	490c      	ldr	r1, [pc, #48]	; (1a001a64 <Board_LED_Init+0x3c>)
1a001a32:	f811 5012 	ldrb.w	r5, [r1, r2, lsl #1]
1a001a36:	eb01 0142 	add.w	r1, r1, r2, lsl #1
1a001a3a:	784c      	ldrb	r4, [r1, #1]
 * @param  pin     : GPIO pin to set direction on as output
 * @return Nothing
 */
STATIC INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
   pGPIO->DIR[port] |= 1UL << pin;
1a001a3c:	4b0a      	ldr	r3, [pc, #40]	; (1a001a68 <Board_LED_Init+0x40>)
1a001a3e:	f505 6600 	add.w	r6, r5, #2048	; 0x800
1a001a42:	f853 1026 	ldr.w	r1, [r3, r6, lsl #2]
1a001a46:	2001      	movs	r0, #1
1a001a48:	40a0      	lsls	r0, r4
1a001a4a:	4301      	orrs	r1, r0
1a001a4c:	f843 1026 	str.w	r1, [r3, r6, lsl #2]
   pGPIO->B[port][pin] = setting;
1a001a50:	eb03 1345 	add.w	r3, r3, r5, lsl #5
1a001a54:	2100      	movs	r1, #0
1a001a56:	5519      	strb	r1, [r3, r4]
   for (idx = 0; idx < (sizeof(gpioLEDBits) / sizeof(io_port_t)); ++idx) {
1a001a58:	3201      	adds	r2, #1
1a001a5a:	2a05      	cmp	r2, #5
1a001a5c:	d9e8      	bls.n	1a001a30 <Board_LED_Init+0x8>
       Chip_GPIO_SetPinState(LPC_GPIO_PORT, gpioLEDBits[idx].port, gpioLEDBits[idx].pin, (bool) false);
   }
}
1a001a5e:	bc70      	pop	{r4, r5, r6}
1a001a60:	4770      	bx	lr
1a001a62:	4770      	bx	lr
1a001a64:	1a0028dc 	.word	0x1a0028dc
1a001a68:	400f4000 	.word	0x400f4000

1a001a6c <Board_UART_Init>:
 * @note   Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
 * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
 */
STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
{
   LPC_SCU->SFSP[port][pin] = modefunc;
1a001a6c:	4b03      	ldr	r3, [pc, #12]	; (1a001a7c <Board_UART_Init+0x10>)
1a001a6e:	2212      	movs	r2, #18
1a001a70:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
1a001a74:	22d1      	movs	r2, #209	; 0xd1
1a001a76:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
1a001a7a:	4770      	bx	lr
1a001a7c:	40086000 	.word	0x40086000

1a001a80 <Board_Debug_Init>:
{
1a001a80:	b510      	push	{r4, lr}
   Board_UART_Init(DEBUG_UART);
1a001a82:	4c08      	ldr	r4, [pc, #32]	; (1a001aa4 <Board_Debug_Init+0x24>)
1a001a84:	4620      	mov	r0, r4
1a001a86:	f7ff fff1 	bl	1a001a6c <Board_UART_Init>
   Chip_UART_Init(DEBUG_UART);
1a001a8a:	4620      	mov	r0, r4
1a001a8c:	f7ff ff0e 	bl	1a0018ac <Chip_UART_Init>
   Chip_UART_SetBaudFDR(DEBUG_UART, 115200);
1a001a90:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
1a001a94:	4620      	mov	r0, r4
1a001a96:	f7ff ff53 	bl	1a001940 <Chip_UART_SetBaudFDR>
   pUART->LCR = config;
1a001a9a:	2303      	movs	r3, #3
1a001a9c:	60e3      	str	r3, [r4, #12]
    pUART->TER2 = UART_TER2_TXEN;
1a001a9e:	2301      	movs	r3, #1
1a001aa0:	65e3      	str	r3, [r4, #92]	; 0x5c
1a001aa2:	bd10      	pop	{r4, pc}
1a001aa4:	400c1000 	.word	0x400c1000

1a001aa8 <Board_Init>:
}

/* Set up and initialize all required blocks and functions related to the
   board hardware */
void Board_Init(void)
{
1a001aa8:	b508      	push	{r3, lr}
   /* Sets up DEBUG UART */
   DEBUGINIT();
1a001aaa:	f7ff ffe9 	bl	1a001a80 <Board_Debug_Init>

   /* Initializes GPIO */
   Chip_GPIO_Init(LPC_GPIO_PORT);
1a001aae:	4806      	ldr	r0, [pc, #24]	; (1a001ac8 <Board_Init+0x20>)
1a001ab0:	f7ff fe26 	bl	1a001700 <Chip_GPIO_Init>

   /* Initialize LEDs */
   Board_LED_Init();
1a001ab4:	f7ff ffb8 	bl	1a001a28 <Board_LED_Init>
 * RMII PHY, and must be called before calling any Ethernet
 * functions.
 */
STATIC INLINE void Chip_ENET_RMIIEnable(LPC_ENET_T *pENET)
{
   LPC_CREG->CREG6 |= 0x4;
1a001ab8:	4a04      	ldr	r2, [pc, #16]	; (1a001acc <Board_Init+0x24>)
1a001aba:	f8d2 312c 	ldr.w	r3, [r2, #300]	; 0x12c
1a001abe:	f043 0304 	orr.w	r3, r3, #4
1a001ac2:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
1a001ac6:	bd08      	pop	{r3, pc}
1a001ac8:	400f4000 	.word	0x400f4000
1a001acc:	40043000 	.word	0x40043000

1a001ad0 <Board_SetupMuxing>:
 * @return Nothing
 */
STATIC INLINE void Chip_SCU_SetPinMuxing(const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
{
   uint32_t ix;
   for (ix = 0; ix < arrayLength; ix++ ) {
1a001ad0:	2300      	movs	r3, #0
1a001ad2:	2b17      	cmp	r3, #23
1a001ad4:	d812      	bhi.n	1a001afc <Board_SetupMuxing+0x2c>
 * Public functions
 ****************************************************************************/

/* Sets up system pin muxing */
void Board_SetupMuxing(void)
{
1a001ad6:	b410      	push	{r4}
       Chip_SCU_PinMuxSet(pinArray[ix].pingrp, pinArray[ix].pinnum, pinArray[ix].modefunc);
1a001ad8:	4a09      	ldr	r2, [pc, #36]	; (1a001b00 <Board_SetupMuxing+0x30>)
1a001ada:	eb02 0183 	add.w	r1, r2, r3, lsl #2
1a001ade:	f812 4023 	ldrb.w	r4, [r2, r3, lsl #2]
1a001ae2:	784a      	ldrb	r2, [r1, #1]
1a001ae4:	8848      	ldrh	r0, [r1, #2]
   LPC_SCU->SFSP[port][pin] = modefunc;
1a001ae6:	eb02 1244 	add.w	r2, r2, r4, lsl #5
1a001aea:	4906      	ldr	r1, [pc, #24]	; (1a001b04 <Board_SetupMuxing+0x34>)
1a001aec:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
   for (ix = 0; ix < arrayLength; ix++ ) {
1a001af0:	3301      	adds	r3, #1
1a001af2:	2b17      	cmp	r3, #23
1a001af4:	d9f0      	bls.n	1a001ad8 <Board_SetupMuxing+0x8>
   /* Setup system level pin muxing */
   Chip_SCU_SetPinMuxing(pinmuxing, sizeof(pinmuxing) / sizeof(PINMUX_GRP_T));
}
1a001af6:	f85d 4b04 	ldr.w	r4, [sp], #4
1a001afa:	4770      	bx	lr
1a001afc:	4770      	bx	lr
1a001afe:	bf00      	nop
1a001b00:	1a0028f4 	.word	0x1a0028f4
1a001b04:	40086000 	.word	0x40086000

1a001b08 <Board_SetupClocking>:

/* Set up and initialize clocking prior to call to main */
void Board_SetupClocking(void)
{
1a001b08:	b510      	push	{r4, lr}
 */
STATIC INLINE void Chip_CREG_SetFlashAcceleration(uint32_t Hz)
{
   uint32_t FAValue = Hz / 21510000;

   LPC_CREG->FLASHCFGA = (LPC_CREG->FLASHCFGA & (~(0xF << 12))) | (FAValue << 12);
1a001b0a:	4a17      	ldr	r2, [pc, #92]	; (1a001b68 <Board_SetupClocking+0x60>)
1a001b0c:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
1a001b10:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
1a001b14:	f443 4310 	orr.w	r3, r3, #36864	; 0x9000
1a001b18:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
   LPC_CREG->FLASHCFGB = (LPC_CREG->FLASHCFGB & (~(0xF << 12))) | (FAValue << 12);
1a001b1c:	f8d2 3124 	ldr.w	r3, [r2, #292]	; 0x124
1a001b20:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
1a001b24:	f443 4310 	orr.w	r3, r3, #36864	; 0x9000
1a001b28:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124

   /* Enable Flash acceleration and setup wait states */
   Chip_CREG_SetFlashAcceleration(MAX_CLOCK_FREQ);

   /* Setup System core frequency to MAX_CLOCK_FREQ */
   Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);
1a001b2c:	2201      	movs	r2, #1
1a001b2e:	490f      	ldr	r1, [pc, #60]	; (1a001b6c <Board_SetupClocking+0x64>)
1a001b30:	2006      	movs	r0, #6
1a001b32:	f7ff fdf9 	bl	1a001728 <Chip_SetupCoreClock>

   /* Setup system base clocks and initial states. This won't enable and
      disable individual clocks, but sets up the base clock sources for
      each individual peripheral clock. */
   for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a001b36:	2400      	movs	r4, #0
1a001b38:	e00a      	b.n	1a001b50 <Board_SetupClocking+0x48>
       Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
1a001b3a:	480d      	ldr	r0, [pc, #52]	; (1a001b70 <Board_SetupClocking+0x68>)
1a001b3c:	eb00 0184 	add.w	r1, r0, r4, lsl #2
1a001b40:	78cb      	ldrb	r3, [r1, #3]
1a001b42:	788a      	ldrb	r2, [r1, #2]
1a001b44:	7849      	ldrb	r1, [r1, #1]
1a001b46:	f810 0024 	ldrb.w	r0, [r0, r4, lsl #2]
1a001b4a:	f7ff fd25 	bl	1a001598 <Chip_Clock_SetBaseClock>
   for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a001b4e:	3401      	adds	r4, #1
1a001b50:	2c02      	cmp	r4, #2
1a001b52:	d9f2      	bls.n	1a001b3a <Board_SetupClocking+0x32>
                               InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
   }

   /* Reset and enable 32Khz oscillator */
   LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));
1a001b54:	4b04      	ldr	r3, [pc, #16]	; (1a001b68 <Board_SetupClocking+0x60>)
1a001b56:	685a      	ldr	r2, [r3, #4]
1a001b58:	f022 020c 	bic.w	r2, r2, #12
1a001b5c:	605a      	str	r2, [r3, #4]
   LPC_CREG->CREG0 |= (1 << 1) | (1 << 0);
1a001b5e:	685a      	ldr	r2, [r3, #4]
1a001b60:	f042 0203 	orr.w	r2, r2, #3
1a001b64:	605a      	str	r2, [r3, #4]
1a001b66:	bd10      	pop	{r4, pc}
1a001b68:	40043000 	.word	0x40043000
1a001b6c:	0c28cb00 	.word	0x0c28cb00
1a001b70:	1a0028e8 	.word	0x1a0028e8

1a001b74 <Board_SystemInit>:
}

/* Set up and initialize hardware prior to call to main */
void Board_SystemInit(void)
{
1a001b74:	b508      	push	{r3, lr}
   /* Setup system clocking and memory. This is done early to allow the
      application and tools to clear memory and use scatter loading to
      external memory. */
   Board_SetupMuxing();
1a001b76:	f7ff ffab 	bl	1a001ad0 <Board_SetupMuxing>
   Board_SetupClocking();
1a001b7a:	f7ff ffc5 	bl	1a001b08 <Board_SetupClocking>
1a001b7e:	bd08      	pop	{r3, pc}

1a001b80 <ResetISR>:
void ResetISR(void) {
1a001b80:	b510      	push	{r4, lr}
    __asm volatile ("cpsid i");
1a001b82:	b672      	cpsid	i
    *(RESET_CONTROL + 0) = 0x10DF1000;
1a001b84:	4a16      	ldr	r2, [pc, #88]	; (1a001be0 <ResetISR+0x60>)
1a001b86:	4b17      	ldr	r3, [pc, #92]	; (1a001be4 <ResetISR+0x64>)
1a001b88:	601a      	str	r2, [r3, #0]
    *(RESET_CONTROL + 1) = 0x01DFF7FF;
1a001b8a:	4a17      	ldr	r2, [pc, #92]	; (1a001be8 <ResetISR+0x68>)
1a001b8c:	3304      	adds	r3, #4
1a001b8e:	601a      	str	r2, [r3, #0]
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
1a001b90:	2300      	movs	r3, #0
1a001b92:	e005      	b.n	1a001ba0 <ResetISR+0x20>
        *(NVIC_ICPR + irqpendloop) = 0xFFFFFFFF;
1a001b94:	f04f 31ff 	mov.w	r1, #4294967295
1a001b98:	4a14      	ldr	r2, [pc, #80]	; (1a001bec <ResetISR+0x6c>)
1a001b9a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
1a001b9e:	3301      	adds	r3, #1
1a001ba0:	2b07      	cmp	r3, #7
1a001ba2:	d9f7      	bls.n	1a001b94 <ResetISR+0x14>
    __asm volatile ("cpsie i");
1a001ba4:	b662      	cpsie	i
    SystemInit();
1a001ba6:	f000 f829 	bl	1a001bfc <SystemInit>
    SectionTableAddr = &__data_section_table;
1a001baa:	4b11      	ldr	r3, [pc, #68]	; (1a001bf0 <ResetISR+0x70>)
    while (SectionTableAddr < &__data_section_table_end) {
1a001bac:	e007      	b.n	1a001bbe <ResetISR+0x3e>
        SectionLen = *SectionTableAddr++;
1a001bae:	f103 040c 	add.w	r4, r3, #12
        data_init(LoadAddr, ExeAddr, SectionLen);
1a001bb2:	689a      	ldr	r2, [r3, #8]
1a001bb4:	6859      	ldr	r1, [r3, #4]
1a001bb6:	6818      	ldr	r0, [r3, #0]
1a001bb8:	f7fe fae8 	bl	1a00018c <data_init>
        SectionLen = *SectionTableAddr++;
1a001bbc:	4623      	mov	r3, r4
    while (SectionTableAddr < &__data_section_table_end) {
1a001bbe:	4a0d      	ldr	r2, [pc, #52]	; (1a001bf4 <ResetISR+0x74>)
1a001bc0:	4293      	cmp	r3, r2
1a001bc2:	d3f4      	bcc.n	1a001bae <ResetISR+0x2e>
1a001bc4:	e006      	b.n	1a001bd4 <ResetISR+0x54>
        ExeAddr = *SectionTableAddr++;
1a001bc6:	461c      	mov	r4, r3
        bss_init(ExeAddr, SectionLen);
1a001bc8:	6859      	ldr	r1, [r3, #4]
1a001bca:	f854 0b08 	ldr.w	r0, [r4], #8
1a001bce:	f7fe faec 	bl	1a0001aa <bss_init>
        SectionLen = *SectionTableAddr++;
1a001bd2:	4623      	mov	r3, r4
    while (SectionTableAddr < &__bss_section_table_end) {
1a001bd4:	4a08      	ldr	r2, [pc, #32]	; (1a001bf8 <ResetISR+0x78>)
1a001bd6:	4293      	cmp	r3, r2
1a001bd8:	d3f5      	bcc.n	1a001bc6 <ResetISR+0x46>
    main();
1a001bda:	f7fe fb97 	bl	1a00030c <main>
1a001bde:	e7fe      	b.n	1a001bde <ResetISR+0x5e>
1a001be0:	10df1000 	.word	0x10df1000
1a001be4:	40053100 	.word	0x40053100
1a001be8:	01dff7ff 	.word	0x01dff7ff
1a001bec:	e000e280 	.word	0xe000e280
1a001bf0:	1a000114 	.word	0x1a000114
1a001bf4:	1a000150 	.word	0x1a000150
1a001bf8:	1a000178 	.word	0x1a000178

1a001bfc <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
1a001bfc:	b508      	push	{r3, lr}

   *pSCB_VTOR = (unsigned int) &__Vectors;
#endif

#if defined(__FPU_PRESENT) && __FPU_PRESENT == 1
   fpuInit();
1a001bfe:	f7ff fd55 	bl	1a0016ac <fpuInit>
#if defined(NO_BOARD_LIB)
   /* Chip specific SystemInit */
   Chip_SystemInit();
#else
   /* Board specific SystemInit */
   Board_SystemInit();
1a001c02:	f7ff ffb7 	bl	1a001b74 <Board_SystemInit>
1a001c06:	bd08      	pop	{r3, pc}

1a001c08 <boardConfig>:
/*==================[internal functions definition]==========================*/

/*==================[external functions definition]==========================*/

/* Set up and initialize board hardware */
void boardConfig(void) {
1a001c08:	b508      	push	{r3, lr}

   /* Read clock settings and update SystemCoreClock variable */
   SystemCoreClockUpdate();
1a001c0a:	f7ff fa9f 	bl	1a00114c <SystemCoreClockUpdate>

   Board_Init(); // From Board module (modules/lpc4337_m4/board)
1a001c0e:	f7ff ff4b 	bl	1a001aa8 <Board_Init>

   /* Inicializar el conteo de Ticks con resoluci贸n de 1ms, sin tickHook */
   tickConfig( 1, 0 );
1a001c12:	2200      	movs	r2, #0
1a001c14:	2001      	movs	r0, #1
1a001c16:	2100      	movs	r1, #0
1a001c18:	f000 f9d4 	bl	1a001fc4 <tickConfig>

   /* Inicializar GPIOs */
   gpioConfig( 0, GPIO_ENABLE );
1a001c1c:	2105      	movs	r1, #5
1a001c1e:	2000      	movs	r0, #0
1a001c20:	f000 f8b6 	bl	1a001d90 <gpioConfig>

   /* Configuraci贸n de pines de entrada para Teclas de la EDU-CIAA-NXP */
   gpioConfig( TEC1, GPIO_INPUT );
1a001c24:	2100      	movs	r1, #0
1a001c26:	2024      	movs	r0, #36	; 0x24
1a001c28:	f000 f8b2 	bl	1a001d90 <gpioConfig>
   gpioConfig( TEC2, GPIO_INPUT );
1a001c2c:	2100      	movs	r1, #0
1a001c2e:	2025      	movs	r0, #37	; 0x25
1a001c30:	f000 f8ae 	bl	1a001d90 <gpioConfig>
   gpioConfig( TEC3, GPIO_INPUT );
1a001c34:	2100      	movs	r1, #0
1a001c36:	2026      	movs	r0, #38	; 0x26
1a001c38:	f000 f8aa 	bl	1a001d90 <gpioConfig>
   gpioConfig( TEC4, GPIO_INPUT );
1a001c3c:	2100      	movs	r1, #0
1a001c3e:	2027      	movs	r0, #39	; 0x27
1a001c40:	f000 f8a6 	bl	1a001d90 <gpioConfig>

   /* Configuraci贸n de pines de salida para Leds de la EDU-CIAA-NXP */
   gpioConfig( LEDR, GPIO_OUTPUT );
1a001c44:	2101      	movs	r1, #1
1a001c46:	2028      	movs	r0, #40	; 0x28
1a001c48:	f000 f8a2 	bl	1a001d90 <gpioConfig>
   gpioConfig( LEDG, GPIO_OUTPUT );
1a001c4c:	2101      	movs	r1, #1
1a001c4e:	2029      	movs	r0, #41	; 0x29
1a001c50:	f000 f89e 	bl	1a001d90 <gpioConfig>
   gpioConfig( LEDB, GPIO_OUTPUT );
1a001c54:	2101      	movs	r1, #1
1a001c56:	202a      	movs	r0, #42	; 0x2a
1a001c58:	f000 f89a 	bl	1a001d90 <gpioConfig>
   gpioConfig( LED1, GPIO_OUTPUT );
1a001c5c:	2101      	movs	r1, #1
1a001c5e:	202b      	movs	r0, #43	; 0x2b
1a001c60:	f000 f896 	bl	1a001d90 <gpioConfig>
   gpioConfig( LED2, GPIO_OUTPUT );
1a001c64:	2101      	movs	r1, #1
1a001c66:	202c      	movs	r0, #44	; 0x2c
1a001c68:	f000 f892 	bl	1a001d90 <gpioConfig>
   gpioConfig( LED3, GPIO_OUTPUT );
1a001c6c:	2101      	movs	r1, #1
1a001c6e:	202d      	movs	r0, #45	; 0x2d
1a001c70:	f000 f88e 	bl	1a001d90 <gpioConfig>


   /* Configuraci贸n de pines de entrada de la CIAA-NXP */
   gpioConfig( DI0, GPIO_INPUT );
1a001c74:	2100      	movs	r1, #0
1a001c76:	202e      	movs	r0, #46	; 0x2e
1a001c78:	f000 f88a 	bl	1a001d90 <gpioConfig>
   gpioConfig( DI1, GPIO_INPUT );
1a001c7c:	2100      	movs	r1, #0
1a001c7e:	202f      	movs	r0, #47	; 0x2f
1a001c80:	f000 f886 	bl	1a001d90 <gpioConfig>
   gpioConfig( DI2, GPIO_INPUT );
1a001c84:	2100      	movs	r1, #0
1a001c86:	2030      	movs	r0, #48	; 0x30
1a001c88:	f000 f882 	bl	1a001d90 <gpioConfig>
   gpioConfig( DI3, GPIO_INPUT );
1a001c8c:	2100      	movs	r1, #0
1a001c8e:	2031      	movs	r0, #49	; 0x31
1a001c90:	f000 f87e 	bl	1a001d90 <gpioConfig>
   gpioConfig( DI4, GPIO_INPUT );
1a001c94:	2100      	movs	r1, #0
1a001c96:	2032      	movs	r0, #50	; 0x32
1a001c98:	f000 f87a 	bl	1a001d90 <gpioConfig>
   gpioConfig( DI5, GPIO_INPUT );
1a001c9c:	2100      	movs	r1, #0
1a001c9e:	2033      	movs	r0, #51	; 0x33
1a001ca0:	f000 f876 	bl	1a001d90 <gpioConfig>
   gpioConfig( DI6, GPIO_INPUT );
1a001ca4:	2100      	movs	r1, #0
1a001ca6:	2034      	movs	r0, #52	; 0x34
1a001ca8:	f000 f872 	bl	1a001d90 <gpioConfig>
   gpioConfig( DI7, GPIO_INPUT );
1a001cac:	2100      	movs	r1, #0
1a001cae:	2035      	movs	r0, #53	; 0x35
1a001cb0:	f000 f86e 	bl	1a001d90 <gpioConfig>

   /* Configuraci贸n de pines de salida de la CIAA-NXP */
   gpioConfig( DO0, GPIO_OUTPUT );
1a001cb4:	2101      	movs	r1, #1
1a001cb6:	2036      	movs	r0, #54	; 0x36
1a001cb8:	f000 f86a 	bl	1a001d90 <gpioConfig>
   gpioConfig( DO1, GPIO_OUTPUT );
1a001cbc:	2101      	movs	r1, #1
1a001cbe:	2037      	movs	r0, #55	; 0x37
1a001cc0:	f000 f866 	bl	1a001d90 <gpioConfig>
   gpioConfig( DO2, GPIO_OUTPUT );
1a001cc4:	2101      	movs	r1, #1
1a001cc6:	2038      	movs	r0, #56	; 0x38
1a001cc8:	f000 f862 	bl	1a001d90 <gpioConfig>
   gpioConfig( DO3, GPIO_OUTPUT );
1a001ccc:	2101      	movs	r1, #1
1a001cce:	2039      	movs	r0, #57	; 0x39
1a001cd0:	f000 f85e 	bl	1a001d90 <gpioConfig>
   gpioConfig( DO4, GPIO_OUTPUT );
1a001cd4:	2101      	movs	r1, #1
1a001cd6:	203a      	movs	r0, #58	; 0x3a
1a001cd8:	f000 f85a 	bl	1a001d90 <gpioConfig>
   gpioConfig( DO5, GPIO_OUTPUT );
1a001cdc:	2101      	movs	r1, #1
1a001cde:	203b      	movs	r0, #59	; 0x3b
1a001ce0:	f000 f856 	bl	1a001d90 <gpioConfig>
   gpioConfig( DO6, GPIO_OUTPUT );
1a001ce4:	2101      	movs	r1, #1
1a001ce6:	203c      	movs	r0, #60	; 0x3c
1a001ce8:	f000 f852 	bl	1a001d90 <gpioConfig>
   gpioConfig( DO7, GPIO_OUTPUT );
1a001cec:	2101      	movs	r1, #1
1a001cee:	203d      	movs	r0, #61	; 0x3d
1a001cf0:	f000 f84e 	bl	1a001d90 <gpioConfig>
1a001cf4:	bd08      	pop	{r3, pc}

1a001cf6 <sAPI_NullFuncPtr>:
 * param:  void * - Not used
 * return: bool_t - Return always true
 */
bool_t sAPI_NullFuncPtr(void *ptr){
   return 1;
}
1a001cf6:	2001      	movs	r0, #1
1a001cf8:	4770      	bx	lr
1a001cfa:	Address 0x1a001cfa is out of bounds.


1a001cfc <delayConfig>:
 }


/* ---- Non Blocking Delay ---- */

void delayConfig( delay_t * delay, tick_t duration ){
1a001cfc:	b510      	push	{r4, lr}
1a001cfe:	4604      	mov	r4, r0
1a001d00:	4610      	mov	r0, r2
1a001d02:	4619      	mov	r1, r3
   delay->duration = duration/tickRateMS;
1a001d04:	4b04      	ldr	r3, [pc, #16]	; (1a001d18 <delayConfig+0x1c>)
1a001d06:	e9d3 2300 	ldrd	r2, r3, [r3]
1a001d0a:	f000 fa8d 	bl	1a002228 <__aeabi_uldivmod>
1a001d0e:	e9c4 0102 	strd	r0, r1, [r4, #8]
   delay->running = 0;
1a001d12:	2300      	movs	r3, #0
1a001d14:	7423      	strb	r3, [r4, #16]
1a001d16:	bd10      	pop	{r4, pc}
1a001d18:	100001b8 	.word	0x100001b8

1a001d1c <delayRead>:
}

bool_t delayRead( delay_t * delay ){
1a001d1c:	b538      	push	{r3, r4, r5, lr}
1a001d1e:	4604      	mov	r4, r0

   bool_t timeArrived = 0;

   if( !delay->running ){
1a001d20:	7c05      	ldrb	r5, [r0, #16]
1a001d22:	b185      	cbz	r5, 1a001d46 <delayRead+0x2a>
      delay->startTime = tickRead();
      delay->running = 1;
   }
   else{
      if ( (tickRead() - delay->startTime) >= delay->duration ){
1a001d24:	f000 f98a 	bl	1a00203c <tickRead>
1a001d28:	e9d4 2300 	ldrd	r2, r3, [r4]
1a001d2c:	1a80      	subs	r0, r0, r2
1a001d2e:	eb61 0103 	sbc.w	r1, r1, r3
1a001d32:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
1a001d36:	4299      	cmp	r1, r3
1a001d38:	bf08      	it	eq
1a001d3a:	4290      	cmpeq	r0, r2
1a001d3c:	d30b      	bcc.n	1a001d56 <delayRead+0x3a>
         timeArrived = 1;
         delay->running = 0;
1a001d3e:	2300      	movs	r3, #0
1a001d40:	7423      	strb	r3, [r4, #16]
         timeArrived = 1;
1a001d42:	2501      	movs	r5, #1
1a001d44:	e005      	b.n	1a001d52 <delayRead+0x36>
      delay->startTime = tickRead();
1a001d46:	f000 f979 	bl	1a00203c <tickRead>
1a001d4a:	e9c4 0100 	strd	r0, r1, [r4]
      delay->running = 1;
1a001d4e:	2301      	movs	r3, #1
1a001d50:	7423      	strb	r3, [r4, #16]
      }
   }

   return timeArrived;
}
1a001d52:	4628      	mov	r0, r5
1a001d54:	bd38      	pop	{r3, r4, r5, pc}
   bool_t timeArrived = 0;
1a001d56:	2500      	movs	r5, #0
1a001d58:	e7fb      	b.n	1a001d52 <delayRead+0x36>
1a001d5a:	Address 0x1a001d5a is out of bounds.


1a001d5c <gpioObtainPinConfig>:
/*==================[internal functions definition]==========================*/

static void gpioObtainPinConfig( gpioMap_t pin,
                                int8_t *pinNamePort, int8_t *pinNamePin,
																int8_t *func, int8_t *gpioPort,
																int8_t *gpioPin ){
1a001d5c:	b430      	push	{r4, r5}

   *pinNamePort = gpioPinsConfig[pin].pinName.port;
1a001d5e:	4d0b      	ldr	r5, [pc, #44]	; (1a001d8c <gpioObtainPinConfig+0x30>)
1a001d60:	eb00 0080 	add.w	r0, r0, r0, lsl #2
1a001d64:	182c      	adds	r4, r5, r0
1a001d66:	5628      	ldrsb	r0, [r5, r0]
1a001d68:	7008      	strb	r0, [r1, #0]
   *pinNamePin  = gpioPinsConfig[pin].pinName.pin;
1a001d6a:	f994 1001 	ldrsb.w	r1, [r4, #1]
1a001d6e:	7011      	strb	r1, [r2, #0]
   *func        = gpioPinsConfig[pin].func;
1a001d70:	f994 2002 	ldrsb.w	r2, [r4, #2]
1a001d74:	701a      	strb	r2, [r3, #0]
   *gpioPort    = gpioPinsConfig[pin].gpio.port;
1a001d76:	f994 2003 	ldrsb.w	r2, [r4, #3]
1a001d7a:	9b02      	ldr	r3, [sp, #8]
1a001d7c:	701a      	strb	r2, [r3, #0]
   *gpioPin     = gpioPinsConfig[pin].gpio.pin;
1a001d7e:	f994 2004 	ldrsb.w	r2, [r4, #4]
1a001d82:	9b03      	ldr	r3, [sp, #12]
1a001d84:	701a      	strb	r2, [r3, #0]
}
1a001d86:	bc30      	pop	{r4, r5}
1a001d88:	4770      	bx	lr
1a001d8a:	bf00      	nop
1a001d8c:	1a002954 	.word	0x1a002954

1a001d90 <gpioConfig>:

/*==================[external functions definition]==========================*/

bool_t gpioConfig( gpioMap_t pin, gpioConfig_t config ){
1a001d90:	b530      	push	{r4, r5, lr}
1a001d92:	b085      	sub	sp, #20
1a001d94:	460c      	mov	r4, r1

   bool_t ret_val     = 1;

   int8_t pinNamePort = 0;
1a001d96:	2300      	movs	r3, #0
1a001d98:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a001d9c:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a001da0:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a001da4:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a001da8:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a001dac:	f10d 030b 	add.w	r3, sp, #11
1a001db0:	9301      	str	r3, [sp, #4]
1a001db2:	ab03      	add	r3, sp, #12
1a001db4:	9300      	str	r3, [sp, #0]
1a001db6:	f10d 030d 	add.w	r3, sp, #13
1a001dba:	f10d 020e 	add.w	r2, sp, #14
1a001dbe:	f10d 010f 	add.w	r1, sp, #15
1a001dc2:	f7ff ffcb 	bl	1a001d5c <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   switch(config){
1a001dc6:	2c05      	cmp	r4, #5
1a001dc8:	f200 8096 	bhi.w	1a001ef8 <gpioConfig+0x168>
1a001dcc:	e8df f004 	tbb	[pc, r4]
1a001dd0:	3d237109 	.word	0x3d237109
1a001dd4:	0357      	.short	0x0357

      case GPIO_ENABLE:
		   /* Initializes GPIO */
		   Chip_GPIO_Init(LPC_GPIO_PORT);
1a001dd6:	4849      	ldr	r0, [pc, #292]	; (1a001efc <gpioConfig+0x16c>)
1a001dd8:	f7ff fc92 	bl	1a001700 <Chip_GPIO_Init>
   bool_t ret_val     = 1;
1a001ddc:	2001      	movs	r0, #1
      break;
   }

   return ret_val;

}
1a001dde:	b005      	add	sp, #20
1a001de0:	bd30      	pop	{r4, r5, pc}
         Chip_SCU_PinMux(
1a001de2:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001de6:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001dea:	f89d 200d 	ldrb.w	r2, [sp, #13]
   LPC_SCU->SFSP[port][pin] = modefunc;
1a001dee:	f042 02d0 	orr.w	r2, r2, #208	; 0xd0
1a001df2:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001df6:	4942      	ldr	r1, [pc, #264]	; (1a001f00 <gpioConfig+0x170>)
1a001df8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a001dfc:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001e00:	2401      	movs	r4, #1
1a001e02:	2300      	movs	r3, #0
1a001e04:	fa04 f202 	lsl.w	r2, r4, r2
1a001e08:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001e0c:	483b      	ldr	r0, [pc, #236]	; (1a001efc <gpioConfig+0x16c>)
1a001e0e:	f7ff fc78 	bl	1a001702 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a001e12:	4620      	mov	r0, r4
      break;
1a001e14:	e7e3      	b.n	1a001dde <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a001e16:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001e1a:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001e1e:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a001e22:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
1a001e26:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001e2a:	4935      	ldr	r1, [pc, #212]	; (1a001f00 <gpioConfig+0x170>)
1a001e2c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a001e30:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001e34:	2401      	movs	r4, #1
1a001e36:	2300      	movs	r3, #0
1a001e38:	fa04 f202 	lsl.w	r2, r4, r2
1a001e3c:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001e40:	482e      	ldr	r0, [pc, #184]	; (1a001efc <gpioConfig+0x16c>)
1a001e42:	f7ff fc5e 	bl	1a001702 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a001e46:	4620      	mov	r0, r4
      break;
1a001e48:	e7c9      	b.n	1a001dde <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a001e4a:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001e4e:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001e52:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a001e56:	f042 02d8 	orr.w	r2, r2, #216	; 0xd8
1a001e5a:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001e5e:	4928      	ldr	r1, [pc, #160]	; (1a001f00 <gpioConfig+0x170>)
1a001e60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a001e64:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001e68:	2401      	movs	r4, #1
1a001e6a:	2300      	movs	r3, #0
1a001e6c:	fa04 f202 	lsl.w	r2, r4, r2
1a001e70:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001e74:	4821      	ldr	r0, [pc, #132]	; (1a001efc <gpioConfig+0x16c>)
1a001e76:	f7ff fc44 	bl	1a001702 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a001e7a:	4620      	mov	r0, r4
      break;
1a001e7c:	e7af      	b.n	1a001dde <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a001e7e:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001e82:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001e86:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a001e8a:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
1a001e8e:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001e92:	491b      	ldr	r1, [pc, #108]	; (1a001f00 <gpioConfig+0x170>)
1a001e94:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_INPUT );
1a001e98:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001e9c:	2401      	movs	r4, #1
1a001e9e:	2300      	movs	r3, #0
1a001ea0:	fa04 f202 	lsl.w	r2, r4, r2
1a001ea4:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001ea8:	4814      	ldr	r0, [pc, #80]	; (1a001efc <gpioConfig+0x16c>)
1a001eaa:	f7ff fc2a 	bl	1a001702 <Chip_GPIO_SetDir>
   bool_t ret_val     = 1;
1a001eae:	4620      	mov	r0, r4
      break;
1a001eb0:	e795      	b.n	1a001dde <gpioConfig+0x4e>
         Chip_SCU_PinMux(
1a001eb2:	f89d 100f 	ldrb.w	r1, [sp, #15]
1a001eb6:	f89d 300e 	ldrb.w	r3, [sp, #14]
1a001eba:	f89d 200d 	ldrb.w	r2, [sp, #13]
1a001ebe:	f042 02d0 	orr.w	r2, r2, #208	; 0xd0
1a001ec2:	eb03 1341 	add.w	r3, r3, r1, lsl #5
1a001ec6:	490e      	ldr	r1, [pc, #56]	; (1a001f00 <gpioConfig+0x170>)
1a001ec8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
         Chip_GPIO_SetDir( LPC_GPIO_PORT, gpioPort, ( 1 << gpioPin ), GPIO_OUTPUT );
1a001ecc:	f99d 200b 	ldrsb.w	r2, [sp, #11]
1a001ed0:	2401      	movs	r4, #1
1a001ed2:	4d0a      	ldr	r5, [pc, #40]	; (1a001efc <gpioConfig+0x16c>)
1a001ed4:	4623      	mov	r3, r4
1a001ed6:	fa04 f202 	lsl.w	r2, r4, r2
1a001eda:	f89d 100c 	ldrb.w	r1, [sp, #12]
1a001ede:	4628      	mov	r0, r5
1a001ee0:	f7ff fc0f 	bl	1a001702 <Chip_GPIO_SetDir>
         Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, 0);
1a001ee4:	f89d 200c 	ldrb.w	r2, [sp, #12]
1a001ee8:	f89d 300b 	ldrb.w	r3, [sp, #11]
1a001eec:	eb05 1542 	add.w	r5, r5, r2, lsl #5
1a001ef0:	2200      	movs	r2, #0
1a001ef2:	54ea      	strb	r2, [r5, r3]
   bool_t ret_val     = 1;
1a001ef4:	4620      	mov	r0, r4
1a001ef6:	e772      	b.n	1a001dde <gpioConfig+0x4e>
         ret_val = 0;
1a001ef8:	2000      	movs	r0, #0
1a001efa:	e770      	b.n	1a001dde <gpioConfig+0x4e>
1a001efc:	400f4000 	.word	0x400f4000
1a001f00:	40086000 	.word	0x40086000

1a001f04 <gpioWrite>:


bool_t gpioWrite( gpioMap_t pin, bool_t value ){
1a001f04:	b510      	push	{r4, lr}
1a001f06:	b084      	sub	sp, #16
1a001f08:	460c      	mov	r4, r1

   bool_t ret_val     = 1;

   int8_t pinNamePort = 0;
1a001f0a:	2300      	movs	r3, #0
1a001f0c:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a001f10:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a001f14:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a001f18:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a001f1c:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a001f20:	f10d 030b 	add.w	r3, sp, #11
1a001f24:	9301      	str	r3, [sp, #4]
1a001f26:	ab03      	add	r3, sp, #12
1a001f28:	9300      	str	r3, [sp, #0]
1a001f2a:	f10d 030d 	add.w	r3, sp, #13
1a001f2e:	f10d 020e 	add.w	r2, sp, #14
1a001f32:	f10d 010f 	add.w	r1, sp, #15
1a001f36:	f7ff ff11 	bl	1a001d5c <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   Chip_GPIO_SetPinState( LPC_GPIO_PORT, gpioPort, gpioPin, value);
1a001f3a:	f89d 300c 	ldrb.w	r3, [sp, #12]
1a001f3e:	f89d 200b 	ldrb.w	r2, [sp, #11]
1a001f42:	3400      	adds	r4, #0
1a001f44:	bf18      	it	ne
1a001f46:	2401      	movne	r4, #1
1a001f48:	015b      	lsls	r3, r3, #5
1a001f4a:	f103 2340 	add.w	r3, r3, #1073758208	; 0x40004000
1a001f4e:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
1a001f52:	549c      	strb	r4, [r3, r2]

   return ret_val;
}
1a001f54:	2001      	movs	r0, #1
1a001f56:	b004      	add	sp, #16
1a001f58:	bd10      	pop	{r4, pc}

1a001f5a <gpioRead>:

   return gpioWrite( pin, !gpioRead(pin) );
}


bool_t gpioRead( gpioMap_t pin ){
1a001f5a:	b500      	push	{lr}
1a001f5c:	b085      	sub	sp, #20

   bool_t ret_val     = OFF;

   int8_t pinNamePort = 0;
1a001f5e:	2300      	movs	r3, #0
1a001f60:	f88d 300f 	strb.w	r3, [sp, #15]
   int8_t pinNamePin  = 0;
1a001f64:	f88d 300e 	strb.w	r3, [sp, #14]

   int8_t func        = 0;
1a001f68:	f88d 300d 	strb.w	r3, [sp, #13]

   int8_t gpioPort    = 0;
1a001f6c:	f88d 300c 	strb.w	r3, [sp, #12]
   int8_t gpioPin     = 0;
1a001f70:	f88d 300b 	strb.w	r3, [sp, #11]

   gpioObtainPinConfig( pin, &pinNamePort, &pinNamePin, &func,
1a001f74:	f10d 030b 	add.w	r3, sp, #11
1a001f78:	9301      	str	r3, [sp, #4]
1a001f7a:	ab03      	add	r3, sp, #12
1a001f7c:	9300      	str	r3, [sp, #0]
1a001f7e:	f10d 030d 	add.w	r3, sp, #13
1a001f82:	f10d 020e 	add.w	r2, sp, #14
1a001f86:	f10d 010f 	add.w	r1, sp, #15
1a001f8a:	f7ff fee7 	bl	1a001d5c <gpioObtainPinConfig>
                           &gpioPort, &gpioPin );

   ret_val = (bool_t) Chip_GPIO_ReadPortBit( LPC_GPIO_PORT, gpioPort, gpioPin );
1a001f8e:	f99d 300c 	ldrsb.w	r3, [sp, #12]
1a001f92:	f89d 200b 	ldrb.w	r2, [sp, #11]
   return (bool) pGPIO->B[port][pin];
1a001f96:	015b      	lsls	r3, r3, #5
1a001f98:	f103 2340 	add.w	r3, r3, #1073758208	; 0x40004000
1a001f9c:	f503 2370 	add.w	r3, r3, #983040	; 0xf0000
1a001fa0:	5c98      	ldrb	r0, [r3, r2]

   return ret_val;
}
1a001fa2:	3000      	adds	r0, #0
1a001fa4:	bf18      	it	ne
1a001fa6:	2001      	movne	r0, #1
1a001fa8:	b005      	add	sp, #20
1a001faa:	f85d fb04 	ldr.w	pc, [sp], #4

1a001fae <gpioToggle>:
bool_t gpioToggle( gpioMap_t pin ){
1a001fae:	b510      	push	{r4, lr}
1a001fb0:	4604      	mov	r4, r0
   return gpioWrite( pin, !gpioRead(pin) );
1a001fb2:	f7ff ffd2 	bl	1a001f5a <gpioRead>
1a001fb6:	fab0 f180 	clz	r1, r0
1a001fba:	0949      	lsrs	r1, r1, #5
1a001fbc:	4620      	mov	r0, r4
1a001fbe:	f7ff ffa1 	bl	1a001f04 <gpioWrite>
}
1a001fc2:	bd10      	pop	{r4, pc}

1a001fc4 <tickConfig>:
/*==================[internal functions definition]==========================*/

/*==================[external functions definition]==========================*/

/* Tick rate configuration 1 to 50 ms */
bool_t tickConfig(tick_t tickRateMSvalue, sAPI_FuncPtr_t tickHook ) {
1a001fc4:	b508      	push	{r3, lr}

   bool_t ret_val = 1;
   tick_t tickRateHz = 0;

   if( tickHook ){
1a001fc6:	b112      	cbz	r2, 1a001fce <tickConfig+0xa>
1a001fc8:	4613      	mov	r3, r2
      tickHookFunction = tickHook;
1a001fca:	4a17      	ldr	r2, [pc, #92]	; (1a002028 <tickConfig+0x64>)
1a001fcc:	6013      	str	r3, [r2, #0]
   }

   if( (tickRateMSvalue >= 1) && (tickRateMSvalue <= 50) ){
1a001fce:	f110 32ff 	adds.w	r2, r0, #4294967295
1a001fd2:	f141 33ff 	adc.w	r3, r1, #4294967295
1a001fd6:	2b00      	cmp	r3, #0
1a001fd8:	bf08      	it	eq
1a001fda:	2a32      	cmpeq	r2, #50	; 0x32
1a001fdc:	d220      	bcs.n	1a002020 <tickConfig+0x5c>
1a001fde:	4602      	mov	r2, r0
1a001fe0:	460b      	mov	r3, r1

		tickRateMS = tickRateMSvalue;
1a001fe2:	4912      	ldr	r1, [pc, #72]	; (1a00202c <tickConfig+0x68>)
1a001fe4:	e9c1 2300 	strd	r2, r3, [r1]
      tickRateHz = 1000 => 1000 ticks per second =>  1 ms tick
      tickRateHz =  200 =>  200 ticks per second =>  5 ms tick
      tickRateHz =  100 =>  100 ticks per second => 10 ms tick
      tickRateHz =   20 =>   20 ticks per second => 50 ms tick
      */
      tickRateHz = 1000 / tickRateMSvalue;
1a001fe8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
1a001fec:	2100      	movs	r1, #0
1a001fee:	f000 f91b 	bl	1a002228 <__aeabi_uldivmod>

      /* Init SysTick interrupt, tickRateHz ticks per second */
      SysTick_Config( SystemCoreClock / tickRateHz);
1a001ff2:	4602      	mov	r2, r0
1a001ff4:	460b      	mov	r3, r1
1a001ff6:	490e      	ldr	r1, [pc, #56]	; (1a002030 <tickConfig+0x6c>)
1a001ff8:	6808      	ldr	r0, [r1, #0]
1a001ffa:	2100      	movs	r1, #0
1a001ffc:	f000 f914 	bl	1a002228 <__aeabi_uldivmod>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
1a002000:	3801      	subs	r0, #1
1a002002:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
1a002006:	d20d      	bcs.n	1a002024 <tickConfig+0x60>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
1a002008:	4b0a      	ldr	r3, [pc, #40]	; (1a002034 <tickConfig+0x70>)
1a00200a:	6058      	str	r0, [r3, #4]
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
1a00200c:	21e0      	movs	r1, #224	; 0xe0
1a00200e:	4a0a      	ldr	r2, [pc, #40]	; (1a002038 <tickConfig+0x74>)
1a002010:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
1a002014:	2200      	movs	r2, #0
1a002016:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
1a002018:	2207      	movs	r2, #7
1a00201a:	601a      	str	r2, [r3, #0]
   bool_t ret_val = 1;
1a00201c:	2001      	movs	r0, #1
1a00201e:	bd08      	pop	{r3, pc}
   }
   else{
      /* Error, tickRateMS variable not in range (1 <= tickRateMS <= 50) */
      ret_val = 0;
1a002020:	2000      	movs	r0, #0
1a002022:	bd08      	pop	{r3, pc}
   bool_t ret_val = 1;
1a002024:	2001      	movs	r0, #1
   }

   return ret_val;
}
1a002026:	bd08      	pop	{r3, pc}
1a002028:	10000038 	.word	0x10000038
1a00202c:	100001b8 	.word	0x100001b8
1a002030:	100001a8 	.word	0x100001a8
1a002034:	e000e010 	.word	0xe000e010
1a002038:	e000ed00 	.word	0xe000ed00

1a00203c <tickRead>:


/* Read Tick Counter */
tick_t tickRead( void ) {
   return tickCounter;
}
1a00203c:	4b01      	ldr	r3, [pc, #4]	; (1a002044 <tickRead+0x8>)
1a00203e:	e9d3 0100 	ldrd	r0, r1, [r3]
1a002042:	4770      	bx	lr
1a002044:	100001b0 	.word	0x100001b0

1a002048 <SysTick_Handler>:
/*==================[ISR external functions definition]======================*/

//__attribute__ ((section(".after_vectors")))

/* SysTick Timer ISR Handler */
void SysTick_Handler(void) {
1a002048:	b508      	push	{r3, lr}
   tickCounter++;
1a00204a:	4906      	ldr	r1, [pc, #24]	; (1a002064 <SysTick_Handler+0x1c>)
1a00204c:	e9d1 2300 	ldrd	r2, r3, [r1]
1a002050:	3201      	adds	r2, #1
1a002052:	f143 0300 	adc.w	r3, r3, #0
1a002056:	e9c1 2300 	strd	r2, r3, [r1]

	/* Execute Tick Hook function */
	(* tickHookFunction )( 0 );
1a00205a:	4b03      	ldr	r3, [pc, #12]	; (1a002068 <SysTick_Handler+0x20>)
1a00205c:	681b      	ldr	r3, [r3, #0]
1a00205e:	2000      	movs	r0, #0
1a002060:	4798      	blx	r3
1a002062:	bd08      	pop	{r3, pc}
1a002064:	100001b0 	.word	0x100001b0
1a002068:	10000038 	.word	0x10000038

1a00206c <errorOcurred>:
/*==================[internal functions definition]==========================*/

/* Causes:
 * User forgot to initialize the functions for the compare match interrupt on Timer_init call
 */
static void errorOcurred(void){
1a00206c:	e7fe      	b.n	1a00206c <errorOcurred>

1a00206e <doNothing>:
   while(1);
}

static void doNothing(void){
1a00206e:	4770      	bx	lr

1a002070 <TIMER0_IRQHandler>:
/*==================[ISR external functions definition]======================*/
/*
 * @Brief:   Executes the functions passed by parameter in the Timer_init,
 *   at the chosen frequencies
 */
void TIMER0_IRQHandler(void){
1a002070:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a002072:	2400      	movs	r4, #0
1a002074:	e001      	b.n	1a00207a <TIMER0_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a002076:	3401      	adds	r4, #1
1a002078:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a00207a:	2c03      	cmp	r4, #3
1a00207c:	d812      	bhi.n	1a0020a4 <TIMER0_IRQHandler+0x34>
      if( Chip_TIMER_MatchPending(LPC_TIMER0, compareMatchNumber) ){
1a00207e:	b265      	sxtb	r5, r4
 * @note   Determine if the match interrupt for the passed timer and match
 * counter is pending.
 */
STATIC INLINE bool Chip_TIMER_MatchPending(LPC_TIMER_T *pTMR, int8_t matchnum)
{
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a002080:	4b09      	ldr	r3, [pc, #36]	; (1a0020a8 <TIMER0_IRQHandler+0x38>)
1a002082:	681a      	ldr	r2, [r3, #0]
1a002084:	f004 010f 	and.w	r1, r4, #15
1a002088:	2301      	movs	r3, #1
1a00208a:	408b      	lsls	r3, r1
1a00208c:	421a      	tst	r2, r3
1a00208e:	d0f2      	beq.n	1a002076 <TIMER0_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER0].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a002090:	4b06      	ldr	r3, [pc, #24]	; (1a0020ac <TIMER0_IRQHandler+0x3c>)
1a002092:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
1a002096:	4798      	blx	r3
 * @return Nothing
 * @note   Clears a pending timer match interrupt.
 */
STATIC INLINE void Chip_TIMER_ClearMatch(LPC_TIMER_T *pTMR, int8_t matchnum)
{
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a002098:	2301      	movs	r3, #1
1a00209a:	fa03 f505 	lsl.w	r5, r3, r5
1a00209e:	4b02      	ldr	r3, [pc, #8]	; (1a0020a8 <TIMER0_IRQHandler+0x38>)
1a0020a0:	601d      	str	r5, [r3, #0]
1a0020a2:	e7e8      	b.n	1a002076 <TIMER0_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER0, compareMatchNumber);
      }
   }
}
1a0020a4:	bd38      	pop	{r3, r4, r5, pc}
1a0020a6:	bf00      	nop
1a0020a8:	40084000 	.word	0x40084000
1a0020ac:	1000003c 	.word	0x1000003c

1a0020b0 <TIMER1_IRQHandler>:

void TIMER1_IRQHandler( void ){
1a0020b0:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a0020b2:	2400      	movs	r4, #0
1a0020b4:	e001      	b.n	1a0020ba <TIMER1_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a0020b6:	3401      	adds	r4, #1
1a0020b8:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a0020ba:	2c03      	cmp	r4, #3
1a0020bc:	d813      	bhi.n	1a0020e6 <TIMER1_IRQHandler+0x36>
      if( Chip_TIMER_MatchPending(LPC_TIMER1, compareMatchNumber) ){
1a0020be:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a0020c0:	4b09      	ldr	r3, [pc, #36]	; (1a0020e8 <TIMER1_IRQHandler+0x38>)
1a0020c2:	681a      	ldr	r2, [r3, #0]
1a0020c4:	f004 010f 	and.w	r1, r4, #15
1a0020c8:	2301      	movs	r3, #1
1a0020ca:	408b      	lsls	r3, r1
1a0020cc:	421a      	tst	r2, r3
1a0020ce:	d0f2      	beq.n	1a0020b6 <TIMER1_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER1].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a0020d0:	1d23      	adds	r3, r4, #4
1a0020d2:	4a06      	ldr	r2, [pc, #24]	; (1a0020ec <TIMER1_IRQHandler+0x3c>)
1a0020d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a0020d8:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a0020da:	2301      	movs	r3, #1
1a0020dc:	fa03 f505 	lsl.w	r5, r3, r5
1a0020e0:	4b01      	ldr	r3, [pc, #4]	; (1a0020e8 <TIMER1_IRQHandler+0x38>)
1a0020e2:	601d      	str	r5, [r3, #0]
1a0020e4:	e7e7      	b.n	1a0020b6 <TIMER1_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER1, compareMatchNumber);
      }
   }
}
1a0020e6:	bd38      	pop	{r3, r4, r5, pc}
1a0020e8:	40085000 	.word	0x40085000
1a0020ec:	1000003c 	.word	0x1000003c

1a0020f0 <TIMER2_IRQHandler>:

void TIMER2_IRQHandler( void ){
1a0020f0:	b538      	push	{r3, r4, r5, lr}
   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a0020f2:	2400      	movs	r4, #0
1a0020f4:	e001      	b.n	1a0020fa <TIMER2_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a0020f6:	3401      	adds	r4, #1
1a0020f8:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a0020fa:	2c03      	cmp	r4, #3
1a0020fc:	d814      	bhi.n	1a002128 <TIMER2_IRQHandler+0x38>
      if( Chip_TIMER_MatchPending(LPC_TIMER2, compareMatchNumber) ){
1a0020fe:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a002100:	4b0a      	ldr	r3, [pc, #40]	; (1a00212c <TIMER2_IRQHandler+0x3c>)
1a002102:	681a      	ldr	r2, [r3, #0]
1a002104:	f004 010f 	and.w	r1, r4, #15
1a002108:	2301      	movs	r3, #1
1a00210a:	408b      	lsls	r3, r1
1a00210c:	421a      	tst	r2, r3
1a00210e:	d0f2      	beq.n	1a0020f6 <TIMER2_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER2].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a002110:	f104 0308 	add.w	r3, r4, #8
1a002114:	4a06      	ldr	r2, [pc, #24]	; (1a002130 <TIMER2_IRQHandler+0x40>)
1a002116:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a00211a:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a00211c:	2301      	movs	r3, #1
1a00211e:	fa03 f505 	lsl.w	r5, r3, r5
1a002122:	4b02      	ldr	r3, [pc, #8]	; (1a00212c <TIMER2_IRQHandler+0x3c>)
1a002124:	601d      	str	r5, [r3, #0]
1a002126:	e7e6      	b.n	1a0020f6 <TIMER2_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER2, compareMatchNumber);
      }
   }
}
1a002128:	bd38      	pop	{r3, r4, r5, pc}
1a00212a:	bf00      	nop
1a00212c:	400c3000 	.word	0x400c3000
1a002130:	1000003c 	.word	0x1000003c

1a002134 <TIMER3_IRQHandler>:

/*fixme __attribute__ ((section(".after_vectors")))*/
void TIMER3_IRQHandler( void ){
1a002134:	b538      	push	{r3, r4, r5, lr}

   uint8_t compareMatchNumber = 0;

   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a002136:	2400      	movs	r4, #0
1a002138:	e001      	b.n	1a00213e <TIMER3_IRQHandler+0xa>
        compareMatchNumber <= TIMERCOMPAREMATCH3;
        compareMatchNumber++ ){
1a00213a:	3401      	adds	r4, #1
1a00213c:	b2e4      	uxtb	r4, r4
   for( compareMatchNumber = TIMERCOMPAREMATCH0;
1a00213e:	2c03      	cmp	r4, #3
1a002140:	d814      	bhi.n	1a00216c <TIMER3_IRQHandler+0x38>
      if (Chip_TIMER_MatchPending(LPC_TIMER3, compareMatchNumber)){
1a002142:	b265      	sxtb	r5, r4
   return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
1a002144:	4b0a      	ldr	r3, [pc, #40]	; (1a002170 <TIMER3_IRQHandler+0x3c>)
1a002146:	681a      	ldr	r2, [r3, #0]
1a002148:	f004 010f 	and.w	r1, r4, #15
1a00214c:	2301      	movs	r3, #1
1a00214e:	408b      	lsls	r3, r1
1a002150:	421a      	tst	r2, r3
1a002152:	d0f2      	beq.n	1a00213a <TIMER3_IRQHandler+0x6>
         /*Run the functions saved in the timer dynamic data structure*/
         (*timer_dd[TIMER3].timerCompareMatchFunctionPointer[compareMatchNumber])();
1a002154:	f104 030c 	add.w	r3, r4, #12
1a002158:	4a06      	ldr	r2, [pc, #24]	; (1a002174 <TIMER3_IRQHandler+0x40>)
1a00215a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1a00215e:	4798      	blx	r3
   pTMR->IR = TIMER_IR_CLR(matchnum);
1a002160:	2301      	movs	r3, #1
1a002162:	fa03 f505 	lsl.w	r5, r3, r5
1a002166:	4b02      	ldr	r3, [pc, #8]	; (1a002170 <TIMER3_IRQHandler+0x3c>)
1a002168:	601d      	str	r5, [r3, #0]
1a00216a:	e7e6      	b.n	1a00213a <TIMER3_IRQHandler+0x6>
         Chip_TIMER_ClearMatch(LPC_TIMER3, compareMatchNumber);
      }
   }
}
1a00216c:	bd38      	pop	{r3, r4, r5, pc}
1a00216e:	bf00      	nop
1a002170:	400c4000 	.word	0x400c4000
1a002174:	1000003c 	.word	0x1000003c

1a002178 <uartConfig>:
void uartConfig( uartMap_t uart, uint32_t baudRate ){
1a002178:	b538      	push	{r3, r4, r5, lr}
1a00217a:	460c      	mov	r4, r1
   switch(uart){
1a00217c:	b110      	cbz	r0, 1a002184 <uartConfig+0xc>
1a00217e:	2801      	cmp	r0, #1
1a002180:	d013      	beq.n	1a0021aa <uartConfig+0x32>
1a002182:	bd38      	pop	{r3, r4, r5, pc}
      Chip_UART_Init(UART_USB_LPC);
1a002184:	4d12      	ldr	r5, [pc, #72]	; (1a0021d0 <uartConfig+0x58>)
1a002186:	4628      	mov	r0, r5
1a002188:	f7ff fb90 	bl	1a0018ac <Chip_UART_Init>
      Chip_UART_SetBaud(UART_USB_LPC, baudRate);  /* Set Baud rate */
1a00218c:	4621      	mov	r1, r4
1a00218e:	4628      	mov	r0, r5
1a002190:	f7ff fbb6 	bl	1a001900 <Chip_UART_SetBaud>
   pUART->FCR = fcr;
1a002194:	2301      	movs	r3, #1
1a002196:	60ab      	str	r3, [r5, #8]
    pUART->TER2 = UART_TER2_TXEN;
1a002198:	65eb      	str	r3, [r5, #92]	; 0x5c
1a00219a:	4b0e      	ldr	r3, [pc, #56]	; (1a0021d4 <uartConfig+0x5c>)
1a00219c:	221e      	movs	r2, #30
1a00219e:	f8c3 2384 	str.w	r2, [r3, #900]	; 0x384
1a0021a2:	22d6      	movs	r2, #214	; 0xd6
1a0021a4:	f8c3 2388 	str.w	r2, [r3, #904]	; 0x388
1a0021a8:	bd38      	pop	{r3, r4, r5, pc}
      Chip_UART_Init(UART_232_LPC);
1a0021aa:	4d0b      	ldr	r5, [pc, #44]	; (1a0021d8 <uartConfig+0x60>)
1a0021ac:	4628      	mov	r0, r5
1a0021ae:	f7ff fb7d 	bl	1a0018ac <Chip_UART_Init>
      Chip_UART_SetBaud(UART_232_LPC, baudRate);  /* Set Baud rate */
1a0021b2:	4621      	mov	r1, r4
1a0021b4:	4628      	mov	r0, r5
1a0021b6:	f7ff fba3 	bl	1a001900 <Chip_UART_SetBaud>
   pUART->FCR = fcr;
1a0021ba:	2301      	movs	r3, #1
1a0021bc:	60ab      	str	r3, [r5, #8]
    pUART->TER2 = UART_TER2_TXEN;
1a0021be:	65eb      	str	r3, [r5, #92]	; 0x5c
1a0021c0:	4b04      	ldr	r3, [pc, #16]	; (1a0021d4 <uartConfig+0x5c>)
1a0021c2:	221a      	movs	r2, #26
1a0021c4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
1a0021c8:	22d2      	movs	r2, #210	; 0xd2
1a0021ca:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
1a0021ce:	bd38      	pop	{r3, r4, r5, pc}
1a0021d0:	400c1000 	.word	0x400c1000
1a0021d4:	40086000 	.word	0x40086000
1a0021d8:	400c2000 	.word	0x400c2000

1a0021dc <uartWriteByte>:
   switch(uart){
1a0021dc:	b110      	cbz	r0, 1a0021e4 <uartWriteByte+0x8>
1a0021de:	2801      	cmp	r0, #1
1a0021e0:	d008      	beq.n	1a0021f4 <uartWriteByte+0x18>
1a0021e2:	4770      	bx	lr
 * @note   Mask bits of the returned status value with UART_LSR_*
 *         definitions for specific statuses.
 */
STATIC INLINE uint32_t Chip_UART_ReadLineStatus(LPC_USART_T *pUART)
{
   return pUART->LSR;
1a0021e4:	4b07      	ldr	r3, [pc, #28]	; (1a002204 <uartWriteByte+0x28>)
1a0021e6:	695b      	ldr	r3, [r3, #20]
      while ((Chip_UART_ReadLineStatus(UART_USB_LPC) & UART_LSR_THRE) == 0) {}   // Wait for space in FIFO
1a0021e8:	f013 0f20 	tst.w	r3, #32
1a0021ec:	d0fa      	beq.n	1a0021e4 <uartWriteByte+0x8>
   pUART->THR = (uint32_t) data;
1a0021ee:	4b05      	ldr	r3, [pc, #20]	; (1a002204 <uartWriteByte+0x28>)
1a0021f0:	6019      	str	r1, [r3, #0]
1a0021f2:	4770      	bx	lr
   return pUART->LSR;
1a0021f4:	4b04      	ldr	r3, [pc, #16]	; (1a002208 <uartWriteByte+0x2c>)
1a0021f6:	695b      	ldr	r3, [r3, #20]
      while ((Chip_UART_ReadLineStatus(UART_232_LPC) & UART_LSR_THRE) == 0) {}   // Wait for space in FIFO
1a0021f8:	f013 0f20 	tst.w	r3, #32
1a0021fc:	d0fa      	beq.n	1a0021f4 <uartWriteByte+0x18>
   pUART->THR = (uint32_t) data;
1a0021fe:	4b02      	ldr	r3, [pc, #8]	; (1a002208 <uartWriteByte+0x2c>)
1a002200:	6019      	str	r1, [r3, #0]
1a002202:	4770      	bx	lr
1a002204:	400c1000 	.word	0x400c1000
1a002208:	400c2000 	.word	0x400c2000

1a00220c <uartWriteString>:
void uartWriteString( uartMap_t uart, char* str ){
1a00220c:	b538      	push	{r3, r4, r5, lr}
1a00220e:	4605      	mov	r5, r0
1a002210:	460c      	mov	r4, r1
   while(*str != 0){
1a002212:	e003      	b.n	1a00221c <uartWriteString+0x10>
	  uartWriteByte( uart, (uint8_t)*str );
1a002214:	4628      	mov	r0, r5
1a002216:	f7ff ffe1 	bl	1a0021dc <uartWriteByte>
	  str++;
1a00221a:	3401      	adds	r4, #1
   while(*str != 0){
1a00221c:	7821      	ldrb	r1, [r4, #0]
1a00221e:	2900      	cmp	r1, #0
1a002220:	d1f8      	bne.n	1a002214 <uartWriteString+0x8>
}
1a002222:	bd38      	pop	{r3, r4, r5, pc}

1a002224 <UART2_IRQHandler>:
}

/* 0x2a 0x000000A8 - Handler for ISR UART2 (IRQ 26) */
void UART2_IRQHandler(void){
1a002224:	4770      	bx	lr

1a002226 <UART3_IRQHandler>:
}

/* 0x2b 0x000000AC - Handler for ISR UART3 (IRQ 27) */
void UART3_IRQHandler(void){
1a002226:	4770      	bx	lr

1a002228 <__aeabi_uldivmod>:
1a002228:	b953      	cbnz	r3, 1a002240 <__aeabi_uldivmod+0x18>
1a00222a:	b94a      	cbnz	r2, 1a002240 <__aeabi_uldivmod+0x18>
1a00222c:	2900      	cmp	r1, #0
1a00222e:	bf08      	it	eq
1a002230:	2800      	cmpeq	r0, #0
1a002232:	bf1c      	itt	ne
1a002234:	f04f 31ff 	movne.w	r1, #4294967295
1a002238:	f04f 30ff 	movne.w	r0, #4294967295
1a00223c:	f000 b97a 	b.w	1a002534 <__aeabi_idiv0>
1a002240:	f1ad 0c08 	sub.w	ip, sp, #8
1a002244:	e96d ce04 	strd	ip, lr, [sp, #-16]!
1a002248:	f000 f806 	bl	1a002258 <__udivmoddi4>
1a00224c:	f8dd e004 	ldr.w	lr, [sp, #4]
1a002250:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
1a002254:	b004      	add	sp, #16
1a002256:	4770      	bx	lr

1a002258 <__udivmoddi4>:
1a002258:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
1a00225c:	468c      	mov	ip, r1
1a00225e:	460d      	mov	r5, r1
1a002260:	4604      	mov	r4, r0
1a002262:	9e08      	ldr	r6, [sp, #32]
1a002264:	2b00      	cmp	r3, #0
1a002266:	d151      	bne.n	1a00230c <__udivmoddi4+0xb4>
1a002268:	428a      	cmp	r2, r1
1a00226a:	4617      	mov	r7, r2
1a00226c:	d96d      	bls.n	1a00234a <__udivmoddi4+0xf2>
1a00226e:	fab2 fe82 	clz	lr, r2
1a002272:	f1be 0f00 	cmp.w	lr, #0
1a002276:	d00b      	beq.n	1a002290 <__udivmoddi4+0x38>
1a002278:	f1ce 0c20 	rsb	ip, lr, #32
1a00227c:	fa01 f50e 	lsl.w	r5, r1, lr
1a002280:	fa20 fc0c 	lsr.w	ip, r0, ip
1a002284:	fa02 f70e 	lsl.w	r7, r2, lr
1a002288:	ea4c 0c05 	orr.w	ip, ip, r5
1a00228c:	fa00 f40e 	lsl.w	r4, r0, lr
1a002290:	ea4f 4a17 	mov.w	sl, r7, lsr #16
1a002294:	0c25      	lsrs	r5, r4, #16
1a002296:	fbbc f8fa 	udiv	r8, ip, sl
1a00229a:	fa1f f987 	uxth.w	r9, r7
1a00229e:	fb0a cc18 	mls	ip, sl, r8, ip
1a0022a2:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
1a0022a6:	fb08 f309 	mul.w	r3, r8, r9
1a0022aa:	42ab      	cmp	r3, r5
1a0022ac:	d90a      	bls.n	1a0022c4 <__udivmoddi4+0x6c>
1a0022ae:	19ed      	adds	r5, r5, r7
1a0022b0:	f108 32ff 	add.w	r2, r8, #4294967295
1a0022b4:	f080 8123 	bcs.w	1a0024fe <__udivmoddi4+0x2a6>
1a0022b8:	42ab      	cmp	r3, r5
1a0022ba:	f240 8120 	bls.w	1a0024fe <__udivmoddi4+0x2a6>
1a0022be:	f1a8 0802 	sub.w	r8, r8, #2
1a0022c2:	443d      	add	r5, r7
1a0022c4:	1aed      	subs	r5, r5, r3
1a0022c6:	b2a4      	uxth	r4, r4
1a0022c8:	fbb5 f0fa 	udiv	r0, r5, sl
1a0022cc:	fb0a 5510 	mls	r5, sl, r0, r5
1a0022d0:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
1a0022d4:	fb00 f909 	mul.w	r9, r0, r9
1a0022d8:	45a1      	cmp	r9, r4
1a0022da:	d909      	bls.n	1a0022f0 <__udivmoddi4+0x98>
1a0022dc:	19e4      	adds	r4, r4, r7
1a0022de:	f100 33ff 	add.w	r3, r0, #4294967295
1a0022e2:	f080 810a 	bcs.w	1a0024fa <__udivmoddi4+0x2a2>
1a0022e6:	45a1      	cmp	r9, r4
1a0022e8:	f240 8107 	bls.w	1a0024fa <__udivmoddi4+0x2a2>
1a0022ec:	3802      	subs	r0, #2
1a0022ee:	443c      	add	r4, r7
1a0022f0:	eba4 0409 	sub.w	r4, r4, r9
1a0022f4:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
1a0022f8:	2100      	movs	r1, #0
1a0022fa:	2e00      	cmp	r6, #0
1a0022fc:	d061      	beq.n	1a0023c2 <__udivmoddi4+0x16a>
1a0022fe:	fa24 f40e 	lsr.w	r4, r4, lr
1a002302:	2300      	movs	r3, #0
1a002304:	6034      	str	r4, [r6, #0]
1a002306:	6073      	str	r3, [r6, #4]
1a002308:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a00230c:	428b      	cmp	r3, r1
1a00230e:	d907      	bls.n	1a002320 <__udivmoddi4+0xc8>
1a002310:	2e00      	cmp	r6, #0
1a002312:	d054      	beq.n	1a0023be <__udivmoddi4+0x166>
1a002314:	2100      	movs	r1, #0
1a002316:	e886 0021 	stmia.w	r6, {r0, r5}
1a00231a:	4608      	mov	r0, r1
1a00231c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a002320:	fab3 f183 	clz	r1, r3
1a002324:	2900      	cmp	r1, #0
1a002326:	f040 808e 	bne.w	1a002446 <__udivmoddi4+0x1ee>
1a00232a:	42ab      	cmp	r3, r5
1a00232c:	d302      	bcc.n	1a002334 <__udivmoddi4+0xdc>
1a00232e:	4282      	cmp	r2, r0
1a002330:	f200 80fa 	bhi.w	1a002528 <__udivmoddi4+0x2d0>
1a002334:	1a84      	subs	r4, r0, r2
1a002336:	eb65 0503 	sbc.w	r5, r5, r3
1a00233a:	2001      	movs	r0, #1
1a00233c:	46ac      	mov	ip, r5
1a00233e:	2e00      	cmp	r6, #0
1a002340:	d03f      	beq.n	1a0023c2 <__udivmoddi4+0x16a>
1a002342:	e886 1010 	stmia.w	r6, {r4, ip}
1a002346:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a00234a:	b912      	cbnz	r2, 1a002352 <__udivmoddi4+0xfa>
1a00234c:	2701      	movs	r7, #1
1a00234e:	fbb7 f7f2 	udiv	r7, r7, r2
1a002352:	fab7 fe87 	clz	lr, r7
1a002356:	f1be 0f00 	cmp.w	lr, #0
1a00235a:	d134      	bne.n	1a0023c6 <__udivmoddi4+0x16e>
1a00235c:	1beb      	subs	r3, r5, r7
1a00235e:	0c3a      	lsrs	r2, r7, #16
1a002360:	fa1f fc87 	uxth.w	ip, r7
1a002364:	2101      	movs	r1, #1
1a002366:	fbb3 f8f2 	udiv	r8, r3, r2
1a00236a:	0c25      	lsrs	r5, r4, #16
1a00236c:	fb02 3318 	mls	r3, r2, r8, r3
1a002370:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
1a002374:	fb0c f308 	mul.w	r3, ip, r8
1a002378:	42ab      	cmp	r3, r5
1a00237a:	d907      	bls.n	1a00238c <__udivmoddi4+0x134>
1a00237c:	19ed      	adds	r5, r5, r7
1a00237e:	f108 30ff 	add.w	r0, r8, #4294967295
1a002382:	d202      	bcs.n	1a00238a <__udivmoddi4+0x132>
1a002384:	42ab      	cmp	r3, r5
1a002386:	f200 80d1 	bhi.w	1a00252c <__udivmoddi4+0x2d4>
1a00238a:	4680      	mov	r8, r0
1a00238c:	1aed      	subs	r5, r5, r3
1a00238e:	b2a3      	uxth	r3, r4
1a002390:	fbb5 f0f2 	udiv	r0, r5, r2
1a002394:	fb02 5510 	mls	r5, r2, r0, r5
1a002398:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
1a00239c:	fb0c fc00 	mul.w	ip, ip, r0
1a0023a0:	45a4      	cmp	ip, r4
1a0023a2:	d907      	bls.n	1a0023b4 <__udivmoddi4+0x15c>
1a0023a4:	19e4      	adds	r4, r4, r7
1a0023a6:	f100 33ff 	add.w	r3, r0, #4294967295
1a0023aa:	d202      	bcs.n	1a0023b2 <__udivmoddi4+0x15a>
1a0023ac:	45a4      	cmp	ip, r4
1a0023ae:	f200 80b8 	bhi.w	1a002522 <__udivmoddi4+0x2ca>
1a0023b2:	4618      	mov	r0, r3
1a0023b4:	eba4 040c 	sub.w	r4, r4, ip
1a0023b8:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
1a0023bc:	e79d      	b.n	1a0022fa <__udivmoddi4+0xa2>
1a0023be:	4631      	mov	r1, r6
1a0023c0:	4630      	mov	r0, r6
1a0023c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a0023c6:	f1ce 0420 	rsb	r4, lr, #32
1a0023ca:	fa05 f30e 	lsl.w	r3, r5, lr
1a0023ce:	fa07 f70e 	lsl.w	r7, r7, lr
1a0023d2:	fa20 f804 	lsr.w	r8, r0, r4
1a0023d6:	0c3a      	lsrs	r2, r7, #16
1a0023d8:	fa25 f404 	lsr.w	r4, r5, r4
1a0023dc:	ea48 0803 	orr.w	r8, r8, r3
1a0023e0:	fbb4 f1f2 	udiv	r1, r4, r2
1a0023e4:	ea4f 4518 	mov.w	r5, r8, lsr #16
1a0023e8:	fb02 4411 	mls	r4, r2, r1, r4
1a0023ec:	fa1f fc87 	uxth.w	ip, r7
1a0023f0:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
1a0023f4:	fb01 f30c 	mul.w	r3, r1, ip
1a0023f8:	42ab      	cmp	r3, r5
1a0023fa:	fa00 f40e 	lsl.w	r4, r0, lr
1a0023fe:	d909      	bls.n	1a002414 <__udivmoddi4+0x1bc>
1a002400:	19ed      	adds	r5, r5, r7
1a002402:	f101 30ff 	add.w	r0, r1, #4294967295
1a002406:	f080 808a 	bcs.w	1a00251e <__udivmoddi4+0x2c6>
1a00240a:	42ab      	cmp	r3, r5
1a00240c:	f240 8087 	bls.w	1a00251e <__udivmoddi4+0x2c6>
1a002410:	3902      	subs	r1, #2
1a002412:	443d      	add	r5, r7
1a002414:	1aeb      	subs	r3, r5, r3
1a002416:	fa1f f588 	uxth.w	r5, r8
1a00241a:	fbb3 f0f2 	udiv	r0, r3, r2
1a00241e:	fb02 3310 	mls	r3, r2, r0, r3
1a002422:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
1a002426:	fb00 f30c 	mul.w	r3, r0, ip
1a00242a:	42ab      	cmp	r3, r5
1a00242c:	d907      	bls.n	1a00243e <__udivmoddi4+0x1e6>
1a00242e:	19ed      	adds	r5, r5, r7
1a002430:	f100 38ff 	add.w	r8, r0, #4294967295
1a002434:	d26f      	bcs.n	1a002516 <__udivmoddi4+0x2be>
1a002436:	42ab      	cmp	r3, r5
1a002438:	d96d      	bls.n	1a002516 <__udivmoddi4+0x2be>
1a00243a:	3802      	subs	r0, #2
1a00243c:	443d      	add	r5, r7
1a00243e:	1aeb      	subs	r3, r5, r3
1a002440:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
1a002444:	e78f      	b.n	1a002366 <__udivmoddi4+0x10e>
1a002446:	f1c1 0720 	rsb	r7, r1, #32
1a00244a:	fa22 f807 	lsr.w	r8, r2, r7
1a00244e:	408b      	lsls	r3, r1
1a002450:	fa05 f401 	lsl.w	r4, r5, r1
1a002454:	ea48 0303 	orr.w	r3, r8, r3
1a002458:	fa20 fe07 	lsr.w	lr, r0, r7
1a00245c:	ea4f 4c13 	mov.w	ip, r3, lsr #16
1a002460:	40fd      	lsrs	r5, r7
1a002462:	ea4e 0e04 	orr.w	lr, lr, r4
1a002466:	fbb5 f9fc 	udiv	r9, r5, ip
1a00246a:	ea4f 441e 	mov.w	r4, lr, lsr #16
1a00246e:	fb0c 5519 	mls	r5, ip, r9, r5
1a002472:	fa1f f883 	uxth.w	r8, r3
1a002476:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
1a00247a:	fb09 f408 	mul.w	r4, r9, r8
1a00247e:	42ac      	cmp	r4, r5
1a002480:	fa02 f201 	lsl.w	r2, r2, r1
1a002484:	fa00 fa01 	lsl.w	sl, r0, r1
1a002488:	d908      	bls.n	1a00249c <__udivmoddi4+0x244>
1a00248a:	18ed      	adds	r5, r5, r3
1a00248c:	f109 30ff 	add.w	r0, r9, #4294967295
1a002490:	d243      	bcs.n	1a00251a <__udivmoddi4+0x2c2>
1a002492:	42ac      	cmp	r4, r5
1a002494:	d941      	bls.n	1a00251a <__udivmoddi4+0x2c2>
1a002496:	f1a9 0902 	sub.w	r9, r9, #2
1a00249a:	441d      	add	r5, r3
1a00249c:	1b2d      	subs	r5, r5, r4
1a00249e:	fa1f fe8e 	uxth.w	lr, lr
1a0024a2:	fbb5 f0fc 	udiv	r0, r5, ip
1a0024a6:	fb0c 5510 	mls	r5, ip, r0, r5
1a0024aa:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
1a0024ae:	fb00 f808 	mul.w	r8, r0, r8
1a0024b2:	45a0      	cmp	r8, r4
1a0024b4:	d907      	bls.n	1a0024c6 <__udivmoddi4+0x26e>
1a0024b6:	18e4      	adds	r4, r4, r3
1a0024b8:	f100 35ff 	add.w	r5, r0, #4294967295
1a0024bc:	d229      	bcs.n	1a002512 <__udivmoddi4+0x2ba>
1a0024be:	45a0      	cmp	r8, r4
1a0024c0:	d927      	bls.n	1a002512 <__udivmoddi4+0x2ba>
1a0024c2:	3802      	subs	r0, #2
1a0024c4:	441c      	add	r4, r3
1a0024c6:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
1a0024ca:	eba4 0408 	sub.w	r4, r4, r8
1a0024ce:	fba0 8902 	umull	r8, r9, r0, r2
1a0024d2:	454c      	cmp	r4, r9
1a0024d4:	46c6      	mov	lr, r8
1a0024d6:	464d      	mov	r5, r9
1a0024d8:	d315      	bcc.n	1a002506 <__udivmoddi4+0x2ae>
1a0024da:	d012      	beq.n	1a002502 <__udivmoddi4+0x2aa>
1a0024dc:	b156      	cbz	r6, 1a0024f4 <__udivmoddi4+0x29c>
1a0024de:	ebba 030e 	subs.w	r3, sl, lr
1a0024e2:	eb64 0405 	sbc.w	r4, r4, r5
1a0024e6:	fa04 f707 	lsl.w	r7, r4, r7
1a0024ea:	40cb      	lsrs	r3, r1
1a0024ec:	431f      	orrs	r7, r3
1a0024ee:	40cc      	lsrs	r4, r1
1a0024f0:	6037      	str	r7, [r6, #0]
1a0024f2:	6074      	str	r4, [r6, #4]
1a0024f4:	2100      	movs	r1, #0
1a0024f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1a0024fa:	4618      	mov	r0, r3
1a0024fc:	e6f8      	b.n	1a0022f0 <__udivmoddi4+0x98>
1a0024fe:	4690      	mov	r8, r2
1a002500:	e6e0      	b.n	1a0022c4 <__udivmoddi4+0x6c>
1a002502:	45c2      	cmp	sl, r8
1a002504:	d2ea      	bcs.n	1a0024dc <__udivmoddi4+0x284>
1a002506:	ebb8 0e02 	subs.w	lr, r8, r2
1a00250a:	eb69 0503 	sbc.w	r5, r9, r3
1a00250e:	3801      	subs	r0, #1
1a002510:	e7e4      	b.n	1a0024dc <__udivmoddi4+0x284>
1a002512:	4628      	mov	r0, r5
1a002514:	e7d7      	b.n	1a0024c6 <__udivmoddi4+0x26e>
1a002516:	4640      	mov	r0, r8
1a002518:	e791      	b.n	1a00243e <__udivmoddi4+0x1e6>
1a00251a:	4681      	mov	r9, r0
1a00251c:	e7be      	b.n	1a00249c <__udivmoddi4+0x244>
1a00251e:	4601      	mov	r1, r0
1a002520:	e778      	b.n	1a002414 <__udivmoddi4+0x1bc>
1a002522:	3802      	subs	r0, #2
1a002524:	443c      	add	r4, r7
1a002526:	e745      	b.n	1a0023b4 <__udivmoddi4+0x15c>
1a002528:	4608      	mov	r0, r1
1a00252a:	e708      	b.n	1a00233e <__udivmoddi4+0xe6>
1a00252c:	f1a8 0802 	sub.w	r8, r8, #2
1a002530:	443d      	add	r5, r7
1a002532:	e72b      	b.n	1a00238c <__udivmoddi4+0x134>

1a002534 <__aeabi_idiv0>:
1a002534:	4770      	bx	lr
1a002536:	bf00      	nop

1a002538 <memset>:
1a002538:	4402      	add	r2, r0
1a00253a:	4603      	mov	r3, r0
1a00253c:	4293      	cmp	r3, r2
1a00253e:	d100      	bne.n	1a002542 <memset+0xa>
1a002540:	4770      	bx	lr
1a002542:	f803 1b01 	strb.w	r1, [r3], #1
1a002546:	e7f9      	b.n	1a00253c <memset+0x4>

1a002548 <pinesTeclado>:
1a002548:	0001 0002 0003 0041 0004 0005 0006 0042     ......A.......B.
1a002558:	0007 0008 0009 0043 002a 0000 0023 0044     ......C.*...#.D.
1a002568:	5b1b 4a32 5b1b 0048 6c61 616d 6563 616e     .[2J.[H.almacena
1a002578:	5072 7369 736f 305b 205d 203d 0000 0000     rPisos[0] = ....
1a002588:	6c61 616d 6563 616e 5072 7369 736f 315b     almacenarPisos[1
1a002598:	205d 203d 0000 0000 6c61 616d 6563 616e     ] = ....almacena
1a0025a8:	5072 7369 736f 325b 205d 203d 0000 0000     rPisos[2] = ....
1a0025b8:	6c61 616d 6563 616e 5072 7369 736f 335b     almacenarPisos[3
1a0025c8:	205d 203d 0000 0000 6c61 616d 6563 616e     ] = ....almacena
1a0025d8:	5072 7369 736f 345b 205d 203d 0000 0000     rPisos[4] = ....
1a0025e8:	6c61 616d 6563 616e 5072 7369 736f 355b     almacenarPisos[5
1a0025f8:	205d 203d 0000 0000 6c61 616d 6563 616e     ] = ....almacena
1a002608:	5072 7369 736f 365b 205d 203d 0000 0000     rPisos[6] = ....
1a002618:	6c61 616d 6563 616e 5072 7369 736f 375b     almacenarPisos[7
1a002628:	205d 203d 0000 0000 6c61 616d 6563 616e     ] = ....almacena
1a002638:	5072 7369 736f 385b 205d 203d 0000 0000     rPisos[8] = ....
1a002648:	6c61 616d 6563 616e 5072 7369 736f 395b     almacenarPisos[9
1a002658:	205d 203d 0000 0000 6e49 6964 6563 3d20     ] = ....Indice =
1a002668:	0020 0000 6970 6564 754e 7665 506f 7369      ...pideNuevoPis
1a002678:	206f 203d 0000 0000 6950 6f73 4420 7365     o = ....Piso Des
1a002688:	6974 6f6e 3d20 0020 6950 6f73 4120 7463     tino = .Piso Act
1a002698:	6175 206c 203d 0000 7365 6174 6f64 6341     ual = ..estadoAc
1a0026a8:	7574 6c61 7341 2063 203d 0000 6e45 5020     tualAsc = ..En P
1a0026b8:	616c 746e 2061 6142 616a 0a0d 0000 0000     lanta Baja......
1a0026c8:	7553 6962 6e65 6f64 0a0d 0000 6142 616a     Subiendo....Baja
1a0026d8:	646e 0d6f 000a 0000 6150 6172 6f64 0a0d     ndo.....Parado..
1a0026e8:	0000 0000 6559 646e 206f 2061 6c50 6e61     ....Yendo a Plan
1a0026f8:	6174 4220 6a61 0d61 000a 0000 6f4d 6f64     ta Baja.....Modo
1a002708:	4320 6e6f 6966 7567 6172 6963 6e6f 0a0d      Configuracion..
1a002718:	0000 0000 7365 6174 6f64 6341 7574 6c61     ....estadoActual
1a002728:	7550 7265 6174 3d20 0020 0000 7550 7265     Puerta = ...Puer
1a002738:	6174 2073 6543 7272 6461 7361 0a0d 0000     tas Cerradas....
1a002748:	6241 6972 6e65 6f64 5020 6575 7472 7361     Abriendo Puertas
1a002758:	0a0d 0000 7550 7265 6174 2073 6241 6569     ....Puertas Abie
1a002768:	7472 7361 0a0d 0000 6e49 6574 746e 6461     rtas....Intentad
1a002778:	206f 6543 7272 7261 5020 6575 7472 7361     o Cerrar Puertas
1a002788:	0a0d 0000 6543 7272 6e61 6f64 5020 6575     ....Cerrando Pue
1a002798:	7472 7361 0a0d 0000 6c41 7261 616d 5020     rtas....Alarma P
1a0027a8:	6575 7472 7361 4120 6962 7265 6174 0d73     uertas Abiertas.
1a0027b8:	000a ffff 797a 7778 7576 7374 7172 6f70     ....zyxwvutsrqpo
1a0027c8:	6d6e 6b6c 696a 6768 6566 6364 6162 3839     nmlkjihgfedcba98
1a0027d8:	3637 3435 3233 3031 3231 3433 3635 3837     7654321012345678
1a0027e8:	6139 6362 6564 6766 6968 6b6a 6d6c 6f6e     9abcdefghijklmno
1a0027f8:	7170 7372 7574 7776 7978 007a 0201 0804     pqrstuvwxyz.....
1a002808:	0f03 0f0f 00ff 0000                         ........

1a002810 <periph_to_base>:
1a002810:	0000 0005 000a 0020 0024 0009 0040 0040     ...... .$...@.@.
1a002820:	0005 0060 00a6 0004 00c0 00c3 0002 00e0     ..`.............
1a002830:	00e0 0001 0100 0100 0003 0120 0120 0006     .......... . ...
1a002840:	0140 0140 000c 0142 0142 0019 0162 0162     @.@...B.B...b.b.
1a002850:	0013 0182 0182 0012 01a2 01a2 0011 01c2     ................
1a002860:	01c2 0010 01e2 01e2 000f 0202 0202 000e     ................
1a002870:	0222 0222 000d 0223 0223 001c               "."...#.#...

1a00287c <InitClkStates>:
1a00287c:	0100 0001 0909 0001 090a 0001 0701 0101     ................
1a00288c:	0902 0001 0906 0001 090c 0101 090d 0001     ................
1a00289c:	090e 0001 090f 0001 0910 0001 0911 0001     ................
1a0028ac:	0912 0001 0913 0001 1114 0001 1119 0001     ................
1a0028bc:	111a 0001 111b 0001                         ........

1a0028c4 <UART_BClock>:
1a0028c4:	01c2 01a2 0182 0162                         ......b.

1a0028cc <UART_PClock>:
1a0028cc:	0081 0082 00a1 00a2                         ........

1a0028d4 <ExtRateIn>:
1a0028d4:	0000 0000                                   ....

1a0028d8 <OscRateIn>:
1a0028d8:	1b00 00b7                                   ....

1a0028dc <gpioLEDBits>:
1a0028dc:	0e00 0b01 0c01 0005 0105 0205               ............

1a0028e8 <InitClkStates>:
1a0028e8:	0308 0001 0307 0001 0f01 0101               ............

1a0028f4 <pinmuxing>:
1a0028f4:	0a02 0040 0b02 0040 0c02 0040 0002 0044     ..@...@...@...D.
1a002904:	0102 0044 0202 0044 0302 0052 0402 0052     ..D...D...R...R.
1a002914:	0509 0052 0609 0057 0206 0057 0001 0050     ..R...W...W...P.
1a002924:	0101 0050 0201 0050 0601 0050 0f01 00f3     ..P...P...P.....
1a002934:	1001 00f7 1101 00f3 1201 00b3 1301 00f0     ................
1a002944:	1401 00b3 0707 00b6 0000 00f2 0100 00b6     ................

1a002954 <gpioPinsConfig>:
1a002954:	0104 0200 0701 0005 0d03 0501 0100 0408     ................
1a002964:	0002 0202 0304 0200 0403 0000 0002 0407     ................
1a002974:	0300 030c 0402 0905 0103 0504 0208 0403     ................
1a002984:	0305 0402 0504 0604 000c 0802 0b06 0300     ................
1a002994:	0607 0009 0503 0706 0504 060f 0004 0303     ................
1a0029a4:	0404 0200 0404 0005 0502 0604 0200 0406     ................
1a0029b4:	0408 0c05 0a04 0504 010e 0003 0a00 1401     ................
1a0029c4:	0000 010f 0012 0d00 1101 0000 010c 0010     ................
1a0029d4:	0300 0707 0300 000f 0001 0100 0000 0000     ................
1a0029e4:	0600 000a 0603 0806 0504 0610 0005 0403     ................
1a0029f4:	0106 0300 0400 0409 0d05 0401 0000 010b     ................
1a002a04:	000f 0200 0001 0000 0104 0001 0800 0201     ................
1a002a14:	0000 0109 0006 0901 0002 0504 0200 0401     ................
1a002a24:	0105 0202 0504 0202 000a 0e00 0b02 0100     ................
1a002a34:	020b 000c 0c01 0004 0200 0400 0001 0102     ................
1a002a44:	0204 0200 0402 0003 0302 0307 0300 070b     ................
1a002a54:	0004 0c03 0507 0300 070d 0006 0e03 0102     ................
1a002a64:	0504 0401 0006 0602 0504 0200 0405 0004     ................
1a002a74:	0402 0804 0504 040c 0409 0d05 0a04 0504     ................
1a002a84:	010e 0005 0801 ffff                         ........
